/**
 * Bundle of @devexpress/dx-grid-core
 * Generated: 2020-05-14
 * Version: 2.6.3
 * License: https://js.devexpress.com/Licensing
 */

import { slice, easeOutCubic } from '@devexpress/dx-core';

var GRID_GROUP_TYPE = Symbol('group');
var GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + "_check");
var GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + "_levelKey");
var GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + "_collapsedRows");

var warnIfRowIdUndefined = function (getRowId) { return function (row) {
    var result = getRowId(row);
    if (!row[GRID_GROUP_CHECK] && result === undefined) {
        // tslint:disable-next-line: no-console
        console.warn('The row id is undefined. Check the getRowId function. The row is', row);
    }
    return result;
}; };
var rowIdGetter = function (getRowId, rows) {
    if (!getRowId) {
        var map_1 = new Map(rows.map(function (row, rowIndex) { return [row, rowIndex]; }));
        return function (row) { return map_1.get(row); };
    }
    return warnIfRowIdUndefined(getRowId);
};
var defaultGetCellValue = function (row, columnName) { return row[columnName]; };
var cellValueGetter = function (getCellValue, columns) {
    if (getCellValue === void 0) { getCellValue = defaultGetCellValue; }
    var useFastAccessor = true;
    var map = columns.reduce(function (acc, column) {
        if (column.getCellValue) {
            useFastAccessor = false;
            acc[column.name] = column.getCellValue;
        }
        return acc;
    }, {});
    if (useFastAccessor) {
        return getCellValue;
    }
    return function (row, columnName) { return (map[columnName]
        ? map[columnName](row, columnName)
        : getCellValue(row, columnName)); };
};

var changeColumnSorting = function (state, _a) {
    var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;
    var sorting = state.sorting;
    var nextSorting = [];
    if (keepOther === true) {
        nextSorting = sorting;
    }
    if (Array.isArray(keepOther)) {
        nextSorting = slice(sorting)
            .filter(function (s) {
            return keepOther.indexOf(s.columnName) > -1;
        });
    }
    var columnSortingIndex = sorting.findIndex(function (s) { return s.columnName === columnName; });
    var columnSorting = sorting[columnSortingIndex];
    var newColumnSorting = {
        columnName: columnName,
        direction: direction
            || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),
    };
    if (columnSortingIndex > -1) {
        nextSorting = slice(nextSorting);
        nextSorting.splice(columnSortingIndex, 1);
    }
    if (direction !== null) {
        var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;
        var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;
        nextSorting = slice(nextSorting);
        nextSorting.splice(newIndex, 0, newColumnSorting);
    }
    return {
        sorting: nextSorting,
    };
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var unique = function (arr) { return __spread(Array.from(new Set(arr))); };
var getColumnSortingDirection = function (sorting, columnName) {
    var columnSorting = sorting.filter(function (s) { return s.columnName === columnName; })[0];
    return columnSorting ? columnSorting.direction : null;
};
var getPersistentSortedColumns = function (sorting, columnExtensions) {
    if (columnExtensions === void 0) { columnExtensions = []; }
    return columnExtensions.reduce(function (acc, _a) {
        var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;
        if (sortingEnabled === false) {
            if (sorting.findIndex(function (sortItem) { return sortItem.columnName === columnName; }) > -1) {
                acc.push(columnName);
            }
        }
        return acc;
    }, []);
};
var calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {
    if (persistentSortedColumns === void 0) { persistentSortedColumns = []; }
    if (!persistentSortedColumns.length)
        return keepOther;
    if (!keepOther)
        return persistentSortedColumns;
    return Array.isArray(keepOther)
        ? unique(__spread(keepOther, persistentSortedColumns))
        : unique(__spread(sorting.map(function (item) { return item.columnName; }), persistentSortedColumns));
};

/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */
/* tslint:disable no-increment-decrement */
var merge = function (array, auxiliary, lo, mid, hi, compare) {
    var i = lo;
    var j = mid + 1;
    var k = lo;
    while (true) {
        var cmp = compare(array[i], array[j]);
        if (cmp <= 0) {
            auxiliary[k++] = array[i++];
            if (i > mid) {
                do {
                    auxiliary[k++] = array[j++];
                } while (j <= hi);
                break;
            }
        }
        else {
            auxiliary[k++] = array[j++];
            if (j > hi) {
                do {
                    auxiliary[k++] = array[i++];
                } while (i <= mid);
                break;
            }
        }
    }
};
var sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {
    if (hi < lo)
        return;
    if (hi === lo) {
        auxiliary[lo] = array[lo];
        return;
    }
    var mid = Math.floor(lo + ((hi - lo) / 2));
    sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);
    sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);
    merge(array, auxiliary, lo, mid, hi, compare);
};
var sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {
    if (hi <= lo)
        return;
    var mid = Math.floor(lo + ((hi - lo) / 2));
    sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);
    sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);
    merge(auxiliary, array, lo, mid, hi, compare);
};
var mergeSort = (function (array, compare) {
    if (compare === void 0) { compare = function (a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }; }
    var result = slice(array);
    var auxiliary = slice(array);
    sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);
    return result;
});

var NODE_CHECK = Symbol('node');
var rowsToTree = function (rows, getRowLevelKey) {
    if (!rows.length)
        return rows;
    var levels = [{ children: [] }];
    rows.forEach(function (row) {
        var _a;
        var levelKey = getRowLevelKey(row);
        if (levelKey) {
            var levelIndex = levels.slice(1)
                .findIndex(function (level) { return getRowLevelKey(level.root) === levelKey; }) + 1;
            if (levelIndex > 0) {
                levels.splice(levelIndex, levels.length - levelIndex);
            }
            var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);
            levels[levels.length - 1].children.push(node);
            levels.push(node);
        }
        else {
            levels[levels.length - 1].children.push(row);
        }
    });
    return levels[0].children;
};
var treeToRows = function (tree, rows) {
    if (rows === void 0) { rows = []; }
    if (!tree.length)
        return tree;
    return tree.reduce(function (acc, node) {
        if (node[NODE_CHECK]) {
            acc.push(node.root);
            treeToRows(node.children, rows);
        }
        else {
            acc.push(node);
        }
        return acc;
    }, rows);
};

var defaultCompare = function (a, b) {
    if (a === b)
        return 0;
    if (a === null) {
        return b === undefined ? -1 : 1;
    }
    if (a === undefined) {
        return 1;
    }
    if (b === null || b === undefined) {
        return -1;
    }
    return a < b ? -1 : 1;
};
var createCompare = function (sorting, getColumnCompare, getComparableValue) { return sorting.reduceRight(function (prevCompare, columnSorting) {
    var columnName = columnSorting.columnName;
    var inverse = columnSorting.direction === 'desc';
    var columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;
    return function (aRow, bRow) {
        var a = getComparableValue(aRow, columnName);
        var b = getComparableValue(bRow, columnName);
        var result = columnCompare(a, b);
        if (result !== 0) {
            return inverse ? -result : result;
        }
        return prevCompare(aRow, bRow);
    };
}, function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return 0;
}); };
var sortTree = function (tree, compare) {
    var sortedTree = tree.map(function (node) {
        if (node[NODE_CHECK]) {
            return __assign(__assign({}, node), { children: sortTree(node.children, compare) });
        }
        return node;
    });
    return mergeSort(sortedTree, function (a, b) { return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b); });
};
var sortHierarchicalRows = function (rows, compare, getRowLevelKey) {
    var tree = rowsToTree(rows, getRowLevelKey);
    var sortedTree = sortTree(tree, compare);
    return treeToRows(sortedTree);
};
var sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {
    if (!sorting.length || !rows.length)
        return rows;
    var compare;
    if (!getRowLevelKey) {
        compare = createCompare(sorting, getColumnCompare, getCellValue);
        return mergeSort(rows.slice(), compare);
    }
    compare = createCompare(sorting, getColumnCompare, function (row, columnName) {
        if (isGroupRow && isGroupRow(row)) {
            if (row.groupedBy === columnName) {
                return row.value;
            }
            return undefined;
        }
        return getCellValue(row, columnName);
    });
    return sortHierarchicalRows(rows, compare, getRowLevelKey);
};

var changeColumnFilter = function (filters, _a) {
    var columnName = _a.columnName, config = _a.config;
    var filterIndex = filters.findIndex(function (f) { return f.columnName === columnName; });
    var nextState = slice(filters);
    if (config) {
        var filter = __assign({ columnName: columnName }, config);
        if (filterIndex > -1) {
            nextState.splice(filterIndex, 1, filter);
        }
        else {
            nextState.push(filter);
        }
    }
    else if (filterIndex > -1) {
        nextState.splice(filterIndex, 1);
    }
    return nextState;
};

var getColumnFilterConfig = function (filters, columnName) { return (filters.length && filters.filter(function (s) { return s.columnName === columnName; })[0] || null); };

var filterExpression = function (filters, expression) {
    // tslint:disable-next-line: no-object-literal-type-assertion
    var selfFilterExpr = { filters: filters, operator: 'and' };
    if (!expression) {
        return selfFilterExpr;
    }
    return {
        operator: 'and',
        filters: [expression, selfFilterExpr],
    };
};

var operators = {
    or: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc || predicate(row); }, false)); }; },
    and: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc && predicate(row); }, true)); }; },
};
var toLowerCase = function (value) { return String(value).toLowerCase(); };
var operationPredicates = {
    contains: function (value, filter) { return toLowerCase(value)
        .indexOf(toLowerCase(filter.value)) > -1; },
    notContains: function (value, filter) { return toLowerCase(value)
        .indexOf(toLowerCase(filter.value)) === -1; },
    startsWith: function (value, filter) { return toLowerCase(value)
        .startsWith(toLowerCase(filter.value)); },
    endsWith: function (value, filter) { return toLowerCase(value)
        .endsWith(toLowerCase(filter.value)); },
    equal: function (value, filter) { return String(value) === String(filter.value); },
    notEqual: function (value, filter) { return String(value) !== String(filter.value); },
    greaterThan: function (value, filter) { return value > filter.value; },
    greaterThanOrEqual: function (value, filter) { return value >= filter.value; },
    lessThan: function (value, filter) { return value < filter.value; },
    lessThanOrEqual: function (value, filter) { return value <= filter.value; },
};
var defaultFilterPredicate = function (value, filter) {
    var operation = filter.operation || 'contains';
    return operationPredicates[operation](value, filter);
};
var filterTree = function (tree, predicate) { return tree.reduce(function (acc, node) {
    if (node[NODE_CHECK]) {
        var filteredChildren = filterTree(node.children, predicate);
        if (filteredChildren.length > 0) {
            acc.push(__assign(__assign({}, node), { children: filteredChildren }));
            return acc;
        }
        if (predicate(node.root, true)) {
            acc.push(node.root);
            return acc;
        }
        return acc;
    }
    if (predicate(node)) {
        acc.push(node);
        return acc;
    }
    return acc;
}, []); };
var filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {
    var tree = rowsToTree(rows, getRowLevelKey);
    var collapsedRowsMeta = [];
    var filteredTree = filterTree(tree, function (row, isNode) {
        if (isNode) {
            var collapsedRows = getCollapsedRows && getCollapsedRows(row);
            if (collapsedRows && collapsedRows.length) {
                var filteredCollapsedRows = collapsedRows.filter(predicate);
                collapsedRowsMeta.push([row, filteredCollapsedRows]);
                return !!filteredCollapsedRows.length || predicate(row);
            }
            if (predicate(row)) {
                collapsedRowsMeta.push([row, []]);
                return true;
            }
            return false;
        }
        return predicate(row);
    });
    return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };
};
var buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {
    var getSimplePredicate = function (filter) {
        var columnName = filter.columnName;
        var customPredicate = getColumnPredicate && getColumnPredicate(columnName);
        var predicate = customPredicate || defaultFilterPredicate;
        return function (row) { return predicate(getCellValue(row, columnName), filter, row); };
    };
    var getOperatorPredicate = function (filterExpression) {
        var build = operators[toLowerCase(filterExpression.operator)];
        return build && build(filterExpression.filters.map(getPredicate));
    };
    var getPredicate = function (filterExpression) { return (getOperatorPredicate(filterExpression)
        || getSimplePredicate(filterExpression)); };
    return getPredicate(initialFilterExpression);
};
var filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {
    if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {
        // tslint:disable-next-line:no-object-literal-type-assertion
        return { rows: rows };
    }
    var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);
    return getRowLevelKey
        ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)
        : { rows: rows.filter(predicate) };
};
var filteredCollapsedRowsGetter = function (_a) {
    var collapsedRowsMeta = _a.collapsedRowsMeta;
    return function (row) { return collapsedRowsMeta && collapsedRowsMeta.get(row); };
};
var unwrappedFilteredRows = function (_a) {
    var rows = _a.rows;
    return rows;
};

var GROUP_KEY_SEPARATOR = '|';

var applyColumnGrouping = function (grouping, _a) {
    var columnName = _a.columnName, groupIndex = _a.groupIndex;
    var nextGrouping = grouping;
    var groupingIndex = nextGrouping.findIndex(function (g) { return g.columnName === columnName; });
    var targetIndex = groupIndex;
    if (groupingIndex > -1) {
        nextGrouping = slice(grouping);
        nextGrouping.splice(groupingIndex, 1);
    }
    else if (groupIndex === undefined) {
        targetIndex = nextGrouping.length;
    }
    if (targetIndex > -1) {
        nextGrouping = slice(nextGrouping);
        nextGrouping.splice(targetIndex, 0, {
            columnName: columnName,
        });
    }
    return nextGrouping;
};
var changeColumnGrouping = function (_a, _b) {
    var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
    var columnName = _b.columnName, groupIndex = _b.groupIndex;
    var nextGrouping = applyColumnGrouping(grouping, { columnName: columnName, groupIndex: groupIndex });
    var ungroupedColumnIndex = grouping.findIndex(function (group, index) { return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName; });
    if (ungroupedColumnIndex === -1) {
        return {
            grouping: nextGrouping,
        };
    }
    var filteredExpandedGroups = expandedGroups.filter(function (group) { return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex; });
    if (filteredExpandedGroups.length === expandedGroups.length) {
        return {
            grouping: nextGrouping,
        };
    }
    return {
        grouping: nextGrouping,
        expandedGroups: filteredExpandedGroups,
    };
};
var toggleExpandedGroups = function (state, _a) {
    var groupKey = _a.groupKey;
    var expandedGroups = slice(state.expandedGroups);
    var groupKeyIndex = expandedGroups.indexOf(groupKey);
    if (groupKeyIndex > -1) {
        expandedGroups.splice(groupKeyIndex, 1);
    }
    else {
        expandedGroups.push(groupKey);
    }
    return {
        expandedGroups: expandedGroups,
    };
};
var draftColumnGrouping = function (_a, _b) {
    var grouping = _a.grouping, draftGrouping = _a.draftGrouping;
    var columnName = _b.columnName, groupIndex = _b.groupIndex;
    return ({
        draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName: columnName, groupIndex: groupIndex }),
    });
};
var cancelColumnGroupingDraft = function () { return ({
    draftGrouping: null,
}); };

var adjustSortIndex = function (groupingIndex, grouping, sorting) { return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {
    var columnSortingIndex = sorting.findIndex(function (columnSorting) { return columnSorting.columnName === columnGrouping.columnName; });
    return (columnSortingIndex === -1 ? acc - 1 : acc);
}, groupingIndex), 0); };

var groupRowChecker = function (row) { return row[GRID_GROUP_CHECK]; };
var groupRowLevelKeyGetter = function (row) { return (row ? row[GRID_GROUP_LEVEL_KEY] : undefined); };
var defaultColumnCriteria = function (value) { return ({
    value: value,
    key: String(value),
}); };
var groupedRows = function (rows, grouping, getCellValue, getColumnCriteria, keyPrefix) {
    if (keyPrefix === void 0) { keyPrefix = ''; }
    if (!grouping.length)
        return rows;
    var columnName = grouping[0].columnName;
    var groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))
        || defaultColumnCriteria;
    var groups = new Map();
    rows.forEach(function (row) {
        var rawValue = getCellValue(row, columnName);
        var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;
        var sameKeyItems = groups.get(key);
        if (!sameKeyItems) {
            var groupingValue = value === rawValue ? value : value || key;
            groups.set(key, [groupingValue, key, [row]]);
        }
        else {
            sameKeyItems[2].push(row);
        }
    });
    var groupedBy = grouping[0].columnName;
    var nestedGrouping = grouping.slice(1);
    return __spread(groups.values()).reduce(function (acc, _a) {
        var _b;
        var _c = __read(_a, 3), value = _c[0], key = _c[1], items = _c[2];
        var compoundKey = "" + keyPrefix + key;
        acc.push((_b = {
                groupedBy: groupedBy,
                compoundKey: compoundKey,
                key: key,
                value: value
            },
            _b[GRID_GROUP_CHECK] = true,
            _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
            _b));
        acc.push.apply(acc, __spread(groupedRows(items, nestedGrouping, getCellValue, getColumnCriteria, "" + compoundKey + GROUP_KEY_SEPARATOR)));
        return acc;
    }, []);
};
var expandedGroupRows = function (rows, grouping, expandedGroups, isExporting) {
    if (!grouping.length)
        return rows;
    var groupingColumnNames = grouping.map(function (columnGrouping) { return columnGrouping.columnName; });
    var expandedGroupsSet = new Set(expandedGroups);
    var currentGroupExpanded = true;
    var currentGroupLevel = 0;
    return rows.reduce(function (acc, row) {
        var _a;
        if (!row[GRID_GROUP_CHECK]) {
            if (currentGroupExpanded) {
                acc.push(row);
            }
            else {
                acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);
            }
            return acc;
        }
        var groupLevel = groupingColumnNames.indexOf(row.groupedBy);
        if (groupLevel > currentGroupLevel && !currentGroupExpanded) {
            return acc;
        }
        currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;
        currentGroupLevel = groupLevel;
        if (currentGroupExpanded) {
            acc.push(row);
        }
        else {
            acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));
        }
        return acc;
    }, []);
};
var groupCollapsedRowsGetter = function (getCollapsedRows) { return function (row) { return (row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))); }; };

var customGroupedRows = function (currentRows, grouping, getChildGroups, rootRows, keyPrefix) {
    if (rootRows === void 0) { rootRows = currentRows; }
    if (keyPrefix === void 0) { keyPrefix = ''; }
    if (!currentRows || !currentRows.length)
        return [];
    if (!grouping.length)
        return currentRows;
    var groupedBy = grouping[0].columnName;
    var nestedGrouping = grouping.slice(1);
    return getChildGroups(currentRows, grouping[0], rootRows)
        .reduce(function (acc, _a) {
        var _b;
        var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;
        var compoundKey = "" + keyPrefix + key;
        acc.push((_b = {
                groupedBy: groupedBy,
                compoundKey: compoundKey,
                key: key,
                value: value
            },
            _b[GRID_GROUP_CHECK] = true,
            _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
            _b));
        acc.push.apply(acc, __spread(customGroupedRows(childRows, nestedGrouping, getChildGroups, rootRows, "" + compoundKey + GROUP_KEY_SEPARATOR)));
        return acc;
    }, []);
};
var customGroupingRowIdGetter = function (getRowId, rows) {
    var firstRow = rows.find(function (row) { return !row[GRID_GROUP_CHECK]; });
    if (!firstRow || getRowId(firstRow) !== undefined) {
        return getRowId;
    }
    var map = new Map(rows
        .filter(function (row) { return !row[GRID_GROUP_CHECK]; })
        .map(function (row, rowIndex) { return [row, rowIndex]; }));
    return function (row) { return map.get(row); };
};

var groupingPanelItems = function (columns, grouping, draftGrouping) {
    var items = draftGrouping.map(function (_a) {
        var columnName = _a.columnName;
        return ({
            column: columns.find(function (c) { return c.name === columnName; }),
            draft: !grouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }),
        });
    });
    grouping.forEach(function (_a, index) {
        var columnName = _a.columnName;
        if (draftGrouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }))
            return;
        items.splice(index, 0, {
            column: columns.find(function (c) { return c.name === columnName; }),
            draft: true,
        });
    });
    return items;
};

var setCurrentPage = function (prevPage, page) { return page; };
var setPageSize = function (prevPageSize, size) { return size; };

var clamp = function (value, max) { return (Math.max(Math.min(value, max), 0)); };

// tslint:disable-next-line:max-line-length
var PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';
var paginatedRows = function (rows, pageSize, page) { return (pageSize
    ? rows.slice(pageSize * page, pageSize * (page + 1))
    : rows); };
var rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {
    if (!pageSize || !getRowLevelKey)
        return rows;
    var result = rows.slice();
    var headerRows = [];
    var currentIndex = 0;
    var _loop_1 = function () {
        var row = result[currentIndex];
        var levelKey = getRowLevelKey(row);
        if (levelKey) {
            var headerIndex = headerRows.findIndex(function (headerRow) { return getRowLevelKey(headerRow) === levelKey; });
            // tslint:disable-next-line:prefer-conditional-expression
            if (headerIndex === -1) {
                headerRows = __spread(headerRows, [row]);
            }
            else {
                headerRows = __spread(headerRows.slice(0, headerIndex), [row]);
            }
            if (headerRows.length >= pageSize) {
                throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);
            }
        }
        var indexInPage = currentIndex % pageSize;
        if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {
            result = __spread(result.slice(0, currentIndex), [
                headerRows[indexInPage]
            ], result.slice(currentIndex));
        }
        currentIndex += 1;
    };
    while (result.length > currentIndex) {
        _loop_1();
    }
    return result;
};
var rowCount = function (rows) { return rows.length; };
var pageCount = function (count, pageSize) { return (pageSize ? Math.ceil(count / pageSize) : 1); };
var currentPage = function (page, totalCount, pageSize, setCurrentPage) {
    var totalPages = pageCount(totalCount, pageSize);
    var adjustedCurrentPage = clamp(page, totalPages - 1);
    if (page !== adjustedCurrentPage) {
        setTimeout(function () { return setCurrentPage(adjustedCurrentPage); });
    }
    return adjustedCurrentPage;
};

var firstRowOnPage = function (currentPage, pageSize, totalCount) {
    if (totalCount === 0) {
        return 0;
    }
    return pageSize ? (currentPage * pageSize) + 1 : 1;
};
var lastRowOnPage = function (currentPage, pageSize, totalRowCount) {
    var result = totalRowCount;
    if (pageSize) {
        var index = (currentPage + 1) * pageSize;
        result = index > totalRowCount ? totalRowCount : index;
    }
    return result;
};
var calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) { return (Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), (totalPageCount - maxButtonCount) + 1), 1)); };

var toggle = function (source, items, state) {
    var itemsSet = new Set(items);
    var sourceState = state;
    if (sourceState === undefined) {
        var availableSelection = source.filter(function (item) { return itemsSet.has(item); });
        sourceState = availableSelection.length !== itemsSet.size;
    }
    if (sourceState) {
        var sourceSet_1 = new Set(source);
        return __spread(source, items.filter(function (item) { return !sourceSet_1.has(item); }));
    }
    return source.filter(function (item) { return !itemsSet.has(item); });
};

var toggleSelection = function (selection, _a) {
    var rowIds = _a.rowIds, state = _a.state;
    return toggle(selection, rowIds, state);
};

var rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {
    var dataRows = rows;
    if (isGroupRow) {
        dataRows = dataRows.filter(function (row) { return !isGroupRow(row); });
    }
    return { rows: rows, availableToSelect: dataRows.map(function (row) { return getRowId(row); }) };
};
var someSelected = function (_a, selection) {
    var availableToSelect = _a.availableToSelect;
    var selectionSet = new Set(selection);
    return availableToSelect.length !== 0 && selectionSet.size !== 0
        && availableToSelect.some(function (elem) { return selectionSet.has(elem); })
        && availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
};
var allSelected = function (_a, selection) {
    var availableToSelect = _a.availableToSelect;
    var selectionSet = new Set(selection);
    return selectionSet.size !== 0 && availableToSelect.length !== 0
        && !availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
};
var unwrapSelectedRows = function (_a) {
    var rows = _a.rows;
    return rows;
};

var startEditRows = function (prevEditingRowIds, _a) {
    var rowIds = _a.rowIds;
    return __spread(prevEditingRowIds, rowIds);
};
var stopEditRows = function (prevEditingRowIds, _a) {
    var rowIds = _a.rowIds;
    var rowIdSet = new Set(rowIds);
    return prevEditingRowIds.filter(function (id) { return !rowIdSet.has(id); });
};
var startEditCells = function (prevEditingCells, _a) {
    var editingCells = _a.editingCells;
    return __spread(prevEditingCells, editingCells);
};
var stopEditCells = function (prevEditingCells, _a) {
    var editingCells = _a.editingCells;
    return prevEditingCells.filter(function (_a) {
        var rowId = _a.rowId, columnName = _a.columnName;
        return (!editingCells.some(function (_a) {
            var currentRowId = _a.rowId, currentColumnName = _a.columnName;
            return (currentRowId === rowId && currentColumnName === columnName);
        }));
    });
};
var addRow = function (addedRows, _a) {
    var row = (_a === void 0 ? { row: {} } : _a).row;
    return __spread(addedRows, [row]);
};
var changeAddedRow = function (addedRows, _a) {
    var rowId = _a.rowId, change = _a.change;
    var result = addedRows.slice();
    result[rowId] = __assign(__assign({}, result[rowId]), change);
    return result;
};
var cancelAddedRows = function (addedRows, _a) {
    var rowIds = _a.rowIds;
    var result = [];
    var indexSet = new Set(rowIds);
    addedRows.forEach(function (row, index) {
        if (!indexSet.has(index)) {
            result.push(row);
        }
    });
    return result;
};
var changeRow = function (prevRowChanges, _a) {
    var _b;
    var rowId = _a.rowId, change = _a.change;
    var prevChange = prevRowChanges[rowId] || {};
    return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));
};
var cancelChanges = function (prevRowChanges, _a) {
    var rowIds = _a.rowIds;
    var result = __assign({}, prevRowChanges);
    rowIds.forEach(function (rowId) {
        delete result[rowId];
    });
    return result;
};
var deleteRows = function (deletedRowIds, _a) {
    var rowIds = _a.rowIds;
    return __spread(deletedRowIds, rowIds);
};
var cancelDeletedRows = function (deletedRowIds, _a) {
    var rowIds = _a.rowIds;
    var rowIdSet = new Set(rowIds);
    return deletedRowIds.filter(function (rowId) { return !rowIdSet.has(rowId); });
};

var changedRowsByIds = function (changes, rowIds) {
    var result = {};
    rowIds.forEach(function (rowId) {
        result[rowId] = changes[rowId];
    });
    return result;
};
var addedRowsByIds = function (addedRows, rowIds) {
    var rowIdSet = new Set(rowIds);
    var result = [];
    addedRows.forEach(function (row, index) {
        if (rowIdSet.has(index)) {
            result.push(row);
        }
    });
    return result;
};
var defaultCreateRowChange = function (row, value, columnName) {
    var _a;
    return (_a = {}, _a[columnName] = value, _a);
};
var createRowChangeGetter = function (createRowChange, columnExtensions) {
    if (createRowChange === void 0) { createRowChange = defaultCreateRowChange; }
    if (columnExtensions === void 0) { columnExtensions = []; }
    var map = columnExtensions.reduce(function (acc, columnExtension) {
        if (columnExtension.createRowChange) {
            acc[columnExtension.columnName] = columnExtension.createRowChange;
        }
        return acc;
    }, {});
    return function (row, value, columnName) {
        if (map[columnName]) {
            return map[columnName](row, value, columnName);
        }
        return createRowChange(row, value, columnName);
    };
};

var getRowChange = function (rowChanges, rowId) { return rowChanges[rowId] || {}; };

var TABLE_REORDERING_TYPE = Symbol('reordering');

var changeColumnOrder = function (order, _a) {
    var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;
    var sourceColumnIndex = order.indexOf(sourceColumnName);
    var targetColumnIndex = order.indexOf(targetColumnName);
    var newOrder = slice(order);
    newOrder.splice(sourceColumnIndex, 1);
    newOrder.splice(targetColumnIndex, 0, sourceColumnName);
    return newOrder;
};

var TABLE_DATA_TYPE = Symbol('data');
var TABLE_NODATA_TYPE = Symbol('nodata');
var TABLE_FLEX_TYPE = Symbol('flex');

var orderedColumns = function (tableColumns, order) {
    if (tableColumns === void 0) { tableColumns = []; }
    return mergeSort(tableColumns, function (a, b) {
        if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)
            return 0;
        var aPos = order.indexOf(a.column.name);
        var bPos = order.indexOf(b.column.name);
        return aPos - bPos;
    });
};
var tableHeaderRowsWithReordering = function (tableHeaderRows) { return __spread(tableHeaderRows, [
    {
        key: TABLE_REORDERING_TYPE.toString(),
        type: TABLE_REORDERING_TYPE,
        height: 0,
    },
]); };
var draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {
    if (sourceColumnIndex === -1
        || targetColumnIndex === -1
        || sourceColumnIndex === targetColumnIndex) {
        return order;
    }
    var result = slice(order);
    var sourceColumn = order[sourceColumnIndex];
    result.splice(sourceColumnIndex, 1);
    result.splice(targetColumnIndex, 0, sourceColumn);
    return result;
};

var getColumnWidth = function (columnWidths, name, _a) {
    var columnName = _a.columnName, cachedWidths = _a.cachedWidths, shift = _a.shift, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, _b = _a.columnExtensions, columnExtensions = _b === void 0 ? [] : _b;
    var change = name === columnName ? shift : -shift;
    var column = columnWidths.find(function (elem) { return elem.columnName === name; });
    var extension = columnExtensions.find(function (elem) { return elem.columnName === name; });
    var width = typeof column.width === 'number'
        ? column.width
        : cachedWidths[name];
    var minWidth = extension && extension.minWidth >= 0
        ? extension.minWidth
        : minColumnWidth;
    var maxWidth = extension && extension.maxWidth >= 0
        ? extension.maxWidth
        : maxColumnWidth;
    var size = Math.max(minWidth, Math.min(width + change, maxWidth));
    return ({ width: width, size: size });
};
var getColumnSizes = function (columnWidths, payload) {
    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode, shift = payload.shift;
    var _a = getColumnWidth(columnWidths, columnName, payload), width = _a.width, size = _a.size;
    if (resizingMode === 'nextColumn') {
        var _b = getColumnWidth(columnWidths, nextColumnName, payload), nextWidth = _b.width, nextSize = _b.size;
        if (size + nextSize !== width + nextWidth) {
            var moreThanLimit = size + nextSize > width + nextWidth;
            var columnExpand = shift > 0;
            if (moreThanLimit !== columnExpand) {
                return { size: size, nextSize: width + nextWidth - size };
            }
            return { size: width + nextWidth - nextSize, nextSize: nextSize };
        }
        return { size: size, nextSize: nextSize };
    }
    return { size: size };
};
var isValidValue = function (value, validUnits) {
    var numb = parseInt(value, 10);
    var unit = numb ? value.substr(numb.toString().length) : value;
    var sizeIsAuto = isNaN(numb) && unit === 'auto';
    var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) { return validUnit === unit; });
    return sizeIsAuto || sizeIsValid;
};
var convertWidth = function (value) {
    if (typeof value === 'string') {
        var numb = parseInt(value, 10);
        if (value.substr(numb.toString().length).length > 0) {
            return value;
        }
        return numb;
    }
    return value;
};

var VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];
var NOT_FOR_WIDGET_UNITS = ['%'];
/* tslint:disable max-line-length */
var COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';
var specifyWidths = function (tableColumns, widths, resizingMode, onError) {
    if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {
        onError();
    }
    if (!widths.length)
        return tableColumns;
    return tableColumns
        .reduce(function (acc, tableColumn) {
        if (tableColumn.type === TABLE_DATA_TYPE) {
            var columnName_1 = tableColumn.column.name;
            var column = widths.find(function (el) { return el.columnName === columnName_1; });
            var width = column && column.width;
            if (typeof width !== 'number') {
                if (width === undefined) {
                    onError();
                }
                else if (!isValidValue(width, VALID_UNITS)) {
                    onError();
                }
                else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {
                    onError();
                }
            }
            else if (width < 0) {
                onError();
            }
            if (width === undefined) {
                acc.push(tableColumn);
            }
            else {
                acc.push(__assign(__assign({}, tableColumn), { width: convertWidth(width) }));
            }
        }
        else {
            acc.push(tableColumn);
        }
        return acc;
    }, []);
};
var tableColumnsWithWidths = function (tableColumns, columnWidths, resizingMode) { return specifyWidths(tableColumns, columnWidths, resizingMode, throwError); };
var tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths, resizingMode) { return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () { }); };
var throwError = function () {
    throw new Error(COLUMN_RESIZING_ERROR);
};

var changeTableColumnWidth = function (state, payload) {
    var columnWidths = state.columnWidths;
    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;
    var nextColumnWidth = slice(columnWidths);
    var index = nextColumnWidth.findIndex(function (elem) { return elem.columnName === columnName; });
    var nextIndex = nextColumnWidth.findIndex(function (elem) { return elem.columnName === nextColumnName; });
    var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
    nextColumnWidth.splice(index, 1, { columnName: columnName, width: size });
    if (resizingMode === 'nextColumn') {
        nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });
    }
    return {
        columnWidths: nextColumnWidth,
    };
};
var draftTableColumnWidth = function (state, payload) {
    var columnWidths = state.columnWidths;
    var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;
    var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
    if (resizingMode === 'nextColumn') {
        return { draftColumnWidths: [
                { columnName: columnName, width: size }, { columnName: nextColumnName, width: nextSize },
            ] };
    }
    return { draftColumnWidths: [{ columnName: columnName, width: size }] };
};
var cancelTableColumnWidthDraft = function () { return ({
    draftColumnWidths: [],
}); };

var TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');

var TABLE_ADDED_TYPE = Symbol('added');
var TABLE_EDIT_TYPE = Symbol('edit');

var TABLE_HEADING_TYPE = Symbol('heading');

var isHeadingEditCommandsTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };
var isEditCommandsTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE
    || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };

var tableColumnsWithEditing = function (tableColumns, width) { return __spread([
    { width: convertWidth(width),
        key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE }
], tableColumns); };

var isEditTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)
    && tableColumn.type === TABLE_DATA_TYPE; };
var isAddedTableRow = function (tableRow) { return tableRow.type === TABLE_ADDED_TYPE; };
var isEditTableRow = function (tableRow) { return tableRow.type === TABLE_EDIT_TYPE; };

var tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {
    var rowIds = new Set(editingRowIds);
    var editedTableRows = tableRows
        .map(function (tableRow) { return (tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId)
        ? __assign(__assign({}, tableRow), { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow); });
    var addedTableRows = addedRows
        .map(function (row, rowIndex) { return ({
        row: row,
        key: TABLE_ADDED_TYPE.toString() + "_" + rowIndex,
        type: TABLE_ADDED_TYPE,
        rowId: rowIndex,
        height: rowHeight,
    }); });
    return __spread(slice(addedTableRows).reverse(), editedTableRows);
};

var rowsWithEditingCells = function (tableBodyRows, editingCells) { return tableBodyRows.map(function (row) {
    var rowId = row.rowId;
    if (rowId !== undefined && editingCells.some(function (elem) { return elem.rowId === rowId; })) {
        return __assign(__assign({}, row), { hasEditCell: true });
    }
    return row;
}); };
var columnsWithEditingCells = function (tableColumns, editingCells) { return tableColumns.map(function (tableColumn) {
    var columnName = tableColumn.column ? tableColumn.column.name : undefined;
    if (columnName !== undefined && editingCells.some(function (elem) { return elem.columnName === columnName; })) {
        return __assign(__assign({}, tableColumn), { hasEditCell: true });
    }
    return tableColumn;
}); };

var TABLE_FILTER_TYPE = Symbol('filter');
var DEFAULT_FILTER_OPERATIONS = [
    'contains',
    'notContains',
    'startsWith',
    'endsWith',
    'equal',
    'notEqual',
];

var isFilterTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isFilterTableRow = function (tableRow) { return tableRow.type === TABLE_FILTER_TYPE; };
var getColumnFilterOperations = function (getAvailableFilterOperations, columnName) { return (getAvailableFilterOperations && getAvailableFilterOperations(columnName))
    || DEFAULT_FILTER_OPERATIONS; };
var isFilterValueEmpty = function (value) { return value === undefined || !String(value).length; };
var getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {
    if (columnFilter && columnFilter.operation) {
        return columnFilter.operation;
    }
    if (filterOperations[columnName]) {
        return filterOperations[columnName];
    }
    return columnFilterOperations[0];
};

var tableHeaderRowsWithFilter = function (headerRows, rowHeight) { return __spread(headerRows, [
    { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }
]); };

var TABLE_GROUP_TYPE = Symbol('group');

var tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) { return tableColumns
    .reduce(function (acc, tableColumn) {
    if (tableColumn.type !== TABLE_DATA_TYPE) {
        acc.push(tableColumn);
        return acc;
    }
    var columnName = tableColumn.column && tableColumn.column.name || '';
    var columnGroupingExists = grouping
        .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
    var columnDraftGroupingExists = draftGrouping
        .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
    if ((!columnGroupingExists && !columnDraftGroupingExists)
        || showColumnWhenGrouped(columnName)) {
        acc.push(tableColumn);
    }
    else if ((!columnGroupingExists && columnDraftGroupingExists)
        || (columnGroupingExists && !columnDraftGroupingExists)) {
        acc.push(__assign(__assign({}, tableColumn), { draft: true }));
    }
    return acc;
    // tslint:disable-next-line: prefer-array-literal
}, []); };
var tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) { return __spread(grouping.map(function (columnGrouping) {
    var groupedColumn = columns.find(function (column) { return column.name === columnGrouping.columnName; });
    return {
        key: TABLE_GROUP_TYPE.toString() + "_" + groupedColumn.name,
        type: TABLE_GROUP_TYPE,
        column: groupedColumn,
        width: indentColumnWidth,
    };
}), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped)); };
var tableRowsWithGrouping = function (tableRows, isGroupRow) { return tableRows.map(function (tableRow) {
    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {
        return tableRow;
    }
    return __assign(__assign({}, tableRow), { key: TABLE_GROUP_TYPE.toString() + "_" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });
}); };
var isRowLevelSummary = function (groupSummaryItems, colName) { return (groupSummaryItems.some(function (item) { return (!item.showInGroupFooter && item.alignByColumn && item.columnName === colName); })); };
var groupSummaryChains = function (tableRow, tableColumns, groupSummaryItems) {
    var captionStarted = false;
    return tableColumns
        .reduce(function (acc, col) {
        var colName = (col.column && col.column.name);
        var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE
            && tableRow.row.groupedBy === colName;
        var isIndentColumn = col.type === TABLE_GROUP_TYPE
            && tableRow.row.groupedBy !== colName && !captionStarted;
        if (isStartOfGroupCaption) {
            captionStarted = true;
        }
        if (isStartOfGroupCaption || isIndentColumn) {
            acc.push([colName]);
        }
        else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {
            acc.push([colName]);
            acc.push([]);
        }
        else {
            acc[acc.length - 1].push(colName);
        }
        return acc;
    }, [[]]);
};
var tableGroupCellColSpanGetter = function (getTableCellColSpan, groupSummaryItems) { return function (params) {
    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
    if (tableRow.type === TABLE_GROUP_TYPE) {
        var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems);
        var chain = chains.find(function (ch) { return ch[0] === (tableColumn.column && tableColumn.column.name); });
        if (chain) {
            return chain.length;
        }
    }
    return getTableCellColSpan(params);
}; };

var isHeadingTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isHeadingTableRow = function (tableRow) { return (tableRow.type === TABLE_HEADING_TYPE); };
var findChainByColumnIndex = function (chains, columnIndex) { return (chains.find(function (chain) { return (chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length); })); };
var splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) { return (tableColumnChains.map(function (row, rowIndex) { return row
    .reduce(function (acc, chain) {
    var currentChain = null;
    chain.columns.forEach(function (col) {
        var column = tableColumns.find(function (c) { return c.key === col.key; });
        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);
        if (isNewGroup) {
            var start = currentChain
                ? (currentChain.start + currentChain.columns.length)
                : chain.start;
            acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), { start: start, columns: [] }));
            currentChain = acc[acc.length - 1];
        }
        currentChain.columns.push(column);
    });
    return acc;
}, []); })); };
var generateSimpleChains = function (rows, columns) { return (rows.map(function () { return ([{
        columns: columns,
        start: 0,
    }]); })); };
var nextColumnName = function (tableColumns, index) {
    var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;
    return isNextColumnHasName
        ? tableColumns[index + 1].column.name
        : undefined;
};
var getNextColumnName = function (tableColumns, columnName) {
    var index = tableColumns.findIndex(function (elem) {
        return elem.column && elem.column.name === columnName;
    });
    return index >= 0
        ? nextColumnName(tableColumns, index)
        : undefined;
};

var tableRowsWithHeading = function (headerRows) { return __spread([
    { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }
], headerRows); };

var TABLE_BAND_TYPE = Symbol('band');
var BAND_GROUP_CELL = 'bandGroupCell';
var BAND_HEADER_CELL = 'bandHeaderCell';
var BAND_EMPTY_CELL = 'bandEmptyCell';
var BAND_DUPLICATE_RENDER = 'bandDuplicateRender';
var BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';

var isBandedTableRow = function (tableRow) { return (tableRow.type === TABLE_BAND_TYPE); };
var isBandedOrHeaderRow = function (tableRow) { return isBandedTableRow(tableRow)
    || tableRow.type === TABLE_HEADING_TYPE; };
var isNoDataColumn = function (columnType) { return columnType !== TABLE_DATA_TYPE; };
var getColumnMeta = function (columnName, bands, tableRowLevel, key, level, title, result) {
    if (key === void 0) { key = ''; }
    if (level === void 0) { level = 0; }
    if (title === void 0) { title = null; }
    if (result === void 0) { result = null; }
    return bands.reduce(function (acc, band) {
        if (band.columnName === columnName) {
            return __assign(__assign({}, acc), { title: title, level: level, key: key });
        }
        if (band.children !== undefined) {
            var rowLevelPassed = level > tableRowLevel;
            var bandTitle = rowLevelPassed ? title : band.title;
            var bandKey = rowLevelPassed ? key : key + "_" + bandTitle;
            return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);
        }
        return acc;
    }, result || { level: level, title: title, key: title });
};
// TODO: refactor
var getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {
    var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;
    if (rowSpan)
        return { type: BAND_DUPLICATE_RENDER, payload: null };
    var maxLevel = tableHeaderRows.filter(function (column) { return column.type === TABLE_BAND_TYPE; }).length + 1;
    var level = tableRow.level;
    var currentRowLevel = level === undefined
        ? maxLevel - 1 : level;
    var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE
        ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel)
        : { level: 0, title: '' };
    var currentColumnIndex = tableColumns
        .findIndex(function (column) { return column.key === currentTableColumn.key; });
    var levelsCount = bandLevelsVisibility.length;
    var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;
    if (currentColumnMeta.level < currentRowLevel) {
        var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount
            && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;
        if (shouldFillLevel) {
            return { type: BAND_FILL_LEVEL_CELL, payload: null };
        }
        return { type: BAND_EMPTY_CELL, payload: null };
    }
    var previousTableColumn = tableColumns[currentColumnIndex - 1];
    var beforeBorder = false;
    if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE
        && isNoDataColumn(previousTableColumn.type)) {
        beforeBorder = true;
    }
    if (currentColumnMeta.level === currentRowLevel) {
        if (currentTableColumn.type === TABLE_STUB_TYPE) {
            var cellRowSpan = visibleLevelsCount < levelsCount
                ? visibleLevelsCount || 1
                : maxLevel;
            return {
                type: BAND_FILL_LEVEL_CELL,
                payload: {
                    rowSpan: cellRowSpan,
                },
            };
        }
        return {
            type: BAND_HEADER_CELL,
            payload: __assign({ tableRow: tableHeaderRows.find(function (row) { return row.type === TABLE_HEADING_TYPE; }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder: beforeBorder }),
        };
    }
    var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);
    var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {
        var _b = __read(_a, 2), start = _b[0], end = _b[1];
        return (start <= currentColumnIndex && currentColumnIndex <= end);
    });
    var bandStart = Math.max(columnVisibleBoundary[0], currentColumnChain.start);
    if (bandStart < currentColumnIndex) {
        return { type: null, payload: null };
    }
    var bandEnd = Math.min(columnVisibleBoundary[1] + 1, currentColumnChain.start + currentColumnChain.columns.length);
    return {
        type: BAND_GROUP_CELL,
        payload: __assign({ colSpan: bandEnd - bandStart, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder: beforeBorder }),
    };
};

var emptyVirtualRows = {
    skip: Number.POSITIVE_INFINITY,
    rows: [],
};
var pluckSubarray = function (source, sourceStart, left, right) { return (source.slice(left - sourceStart, right - sourceStart)); };
var mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {
    var breakpoints = [
        rowsInterval.start, rowsInterval.end,
        cacheInterval.start, cacheInterval.end,
    ]
        .filter(function (i) { return 0 <= i && i < Number.POSITIVE_INFINITY; })
        .sort(function (a, b) { return a - b; });
    var result = [];
    if (breakpoints.length > 1) {
        for (var i = 0; i < breakpoints.length - 1; i += 1) {
            var left = breakpoints[i];
            var right = breakpoints[i + 1];
            var chunk = rowsInterval.start <= left && right <= rowsInterval.end
                ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority
                : pluckSubarray(cacheRows, cacheStart, left, right);
            result = result.concat(chunk);
        }
    }
    return {
        skip: breakpoints[0],
        rows: result,
    };
};
var correctRequestedRange = function (calculatedRange, referenceIndex, pageSize) {
    var start = calculatedRange.start, end = calculatedRange.end;
    if (start - referenceIndex > pageSize / 2) {
        return { start: start - pageSize, end: end - pageSize };
    }
    return { start: start, end: end };
};
var calculateRequestedRange = function (virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {
    var loadedInterval = intervalUtil.getRowsInterval(virtualRows);
    var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;
    if (isAdjacentPage) {
        var calculatedRange = intervalUtil.difference(newRange, loadedInterval);
        if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {
            return correctRequestedRange(calculatedRange, referenceIndex, pageSize);
        }
        return calculatedRange;
    }
    // load 3 pages at once because a missing page will be loaded anyway
    return newRange;
};
var rowToPageIndex = function (rowIndex, pageSize) { return Math.floor(rowIndex / pageSize); };
var recalculateBounds = function (middleIndex, pageSize, totalCount) {
    var currentPageIndex = rowToPageIndex(middleIndex, pageSize);
    var prevPageIndex = currentPageIndex - 1;
    var nextPageIndex = currentPageIndex + 2;
    var start = Math.max(0, prevPageIndex * pageSize);
    var end = Math.min(nextPageIndex * pageSize, totalCount);
    return {
        start: start,
        end: end,
    };
};
var trimRowsToInterval = function (virtualRows, targetInterval) {
    var rowsInterval = intervalUtil.getRowsInterval(virtualRows);
    var intersection = intervalUtil.intersect(rowsInterval, targetInterval);
    if (intervalUtil.empty === intersection) {
        return emptyVirtualRows;
    }
    var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);
    return {
        rows: rows,
        skip: intersection.start,
    };
};
var getAvailableRowCount = function (isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {
    return (isInfiniteScroll
        ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount)
        : totalRowCount);
};
var getForceReloadInterval = function (virtualRows, pageSize, totalRowCount) {
    var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, intervalEnd = _a.end;
    var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));
    return {
        start: start,
        end: end,
    };
};
var getRequestMeta = function (referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {
    var actualBounds = forceReload
        ? getForceReloadInterval(virtualRows, pageSize, totalRowCount)
        : recalculateBounds(referenceIndex, pageSize, totalRowCount);
    var requestedRange = forceReload
        ? actualBounds
        : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);
    return { requestedRange: requestedRange, actualBounds: actualBounds };
};
var needFetchMorePages = function (virtualRows, referenceIndex, pageSize) {
    var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, end = _a.end;
    var loadCount = end - start;
    var topTriggerIndex = start > 0 ? start + pageSize : 0;
    var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);
    if (loadCount <= 0) {
        return false;
    }
    return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);
};
var getReferenceIndex = function (_a) {
    var _b = __read(_a.rows, 2), top = _b[0], bottom = _b[1];
    return ((top + bottom) / 2);
};
var shouldSendRequest = function (_a, requestedPageIndex) {
    var start = _a.start, end = _a.end;
    var newPageIndex = start;
    var loadCount = (end - start);
    return newPageIndex !== requestedPageIndex && loadCount > 0;
};

var empty = {
    start: Number.POSITIVE_INFINITY,
    end: Number.NEGATIVE_INFINITY,
};
var getRowsInterval = function (r) { return (r === emptyVirtualRows
    ? empty
    : {
        start: r.skip,
        end: r.skip + r.rows.length,
    }); };
var getLength = function (a) { return a.end - a.start; };
var intersect = function (a, b) {
    if (a.end < b.start || b.end < a.start) {
        return empty;
    }
    return {
        start: Math.max(a.start, b.start),
        end: Math.min(a.end, b.end),
    };
};
var difference = function (a, b) {
    if (empty === intervalUtil.intersect(a, b)) {
        return a;
    }
    if (b.end < a.end) {
        return {
            start: b.end,
            end: a.end,
        };
    }
    if (a.start < b.start) {
        return {
            start: a.start,
            end: b.start,
        };
    }
    return empty;
};
var intervalUtil = {
    empty: empty,
    getRowsInterval: getRowsInterval,
    getLength: getLength,
    intersect: intersect,
    difference: difference,
};

var tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {
    var tableDataColumns = tableColumns.filter(function (column) { return column.type === TABLE_DATA_TYPE; });
    var getMaxNestedLevel = function (bands, level, result) {
        if (level === void 0) { level = 0; }
        if (result === void 0) { result = null; }
        return (bands.reduce(function (acc, column) {
            if (column.children !== undefined) {
                return getMaxNestedLevel(column.children, level + 1, acc);
            }
            var isDataColumn = tableDataColumns.findIndex(function (dataColumn) { return !!dataColumn.column && dataColumn.column.name === column.columnName; }) > -1;
            if (level > acc.level && isDataColumn) {
                return __assign(__assign({}, acc), { level: level });
            }
            return acc;
        }, result || { level: 0 }));
    };
    var tableBandHeaders = Array.from({
        length: getMaxNestedLevel(columnBands, 0).level,
    })
        .map(function (row, index) { return ({
        key: TABLE_BAND_TYPE.toString() + "_" + index,
        type: TABLE_BAND_TYPE,
        level: index,
    }); });
    return __spread(tableBandHeaders, tableHeaderRows);
};
var tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {
    var chains = generateSimpleChains(tableHeaderRows, tableColumns);
    var maxBandRowIndex = tableHeaderRows
        .filter(function (row) { return row.type === TABLE_BAND_TYPE; })
        .length;
    var rawBandChains = chains.slice(0, maxBandRowIndex);
    var currentBand = null;
    var shouldSplitChain = function (chain, column, rowIndex) {
        if (rowIndex > maxBandRowIndex)
            return false;
        var columnName = column.column && column.column.name || '';
        currentBand = getColumnMeta(columnName, bands, rowIndex);
        return !chain
            || chain.key !== currentBand.key;
    };
    var extendChainProps = function () { return ({
        bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,
        key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key,
    }); };
    var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);
    return __spread(bandChains, chains.slice(maxBandRowIndex));
};
var getBandLevels = function (columnsBands, levels, level) {
    if (levels === void 0) { levels = {}; }
    if (level === void 0) { level = 0; }
    columnsBands.forEach(function (band) {
        if (band.title) {
            levels[band.title] = level;
        }
        if (band.children) {
            getBandLevels(band.children, levels, level + 1);
        }
    });
    return levels;
};
var columnBandLevels = function (columnsBands) { return (getBandLevels(columnsBands)); };
var bandLevelsVisibility = function (columnIntervals, tableHeaderColumnChains, bandLevels) {
    var rowsWithBands = tableHeaderColumnChains
        .filter(function (r) { return r.filter(function (ch) { return !!ch.bandTitle; }).length; });
    var visibleIntervals = columnIntervals.map(function (_a) {
        var _b = __read(_a, 2), start = _b[0], end = _b[1];
        return ({ start: start, end: end });
    });
    var isBandChainVisible = function (chain) { return (visibleIntervals.some(function (interval) { return (intervalUtil.intersect(interval, { start: chain.start, end: chain.start + chain.columns.length - 1 }) !== intervalUtil.empty); })); };
    var getVisibleBandsByLevel = function (level) { return (
    // Note: a visible band level always matches with it's row
    rowsWithBands[level]
        ? rowsWithBands[level].filter(function (chain) { return (bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)); })
        : []); };
    return rowsWithBands.reduce(function (acc, _, index) {
        var rowBands = getVisibleBandsByLevel(index);
        return __spread(acc, [!!rowBands.length]);
    }, []);
};
var columnVisibleIntervals = function (viewport, tableColumns) { return (viewport ? viewport.columns : [[0, tableColumns.length]]); };

var toggleDetailRowExpanded = function (prevExpanded, _a) {
    var rowId = _a.rowId, state = _a.state;
    return toggle(prevExpanded, [rowId], state);
};

var TABLE_DETAIL_TYPE = Symbol('detail');

var isDetailRowExpanded = function (expandedDetailRowIds, rowId) { return expandedDetailRowIds.indexOf(rowId) > -1; };
var isDetailToggleTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE; };
var isDetailTableRow = function (tableRow) { return tableRow.type === TABLE_DETAIL_TYPE; };
var isDetailTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };

var tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {
    var result = tableRows;
    expandedDetailRowIds
        .forEach(function (expandedRowId) {
        var rowIndex = result.findIndex(function (tableRow) { return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId; });
        if (rowIndex === -1)
            return;
        var insertIndex = rowIndex + 1;
        var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;
        result = __spread(result.slice(0, insertIndex), [
            {
                rowId: rowId,
                row: row,
                key: TABLE_DETAIL_TYPE.toString() + "_" + rowId,
                type: TABLE_DETAIL_TYPE,
                height: rowHeight,
            }
        ], result.slice(insertIndex));
    });
    return result;
};
var tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) { return __spread([
    { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }
], tableColumns); };
var tableDetailCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {
        return tableColumns.length;
    }
    return getTableCellColSpan(params);
}; };

var TABLE_SELECT_TYPE = Symbol('select');

var isSelectTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE; };
var isSelectAllTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE; };
var isRowHighlighted = function (highlightRow, selection, tableRow) { return (highlightRow && selection && selection.includes(tableRow.rowId)); };

var tableColumnsWithSelection = function (tableColumns, selectionColumnWidth) { return __spread([
    { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }
], tableColumns); };

var VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];
var TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';
var isDataTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isHeaderStubTableCell = function (tableRow, headerRows) { return headerRows.indexOf(tableRow) > -1; };
var isDataTableRow = function (tableRow) { return tableRow.type === TABLE_DATA_TYPE; };
var isNoDataTableRow = function (tableRow) { return tableRow.type === TABLE_NODATA_TYPE; };
var isNoDataTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };
var isStubTableCell = function (tableRow) { return (tableRow.type === TABLE_STUB_TYPE); };
var checkTableColumnExtensions = function (columnExtensions) {
    if (columnExtensions) {
        columnExtensions.map(function (column) {
            var width = column.width;
            if (typeof width === 'string') {
                if (!isValidValue(width, VALID_UNITS$1)) {
                    throw new Error(TABLE_ERROR);
                }
            }
        });
    }
};

var getColumnExtension = function (columnExtensions, columnName) {
    if (!columnExtensions) {
        // tslint:disable-next-line:no-object-literal-type-assertion
        return {};
    }
    var columnExtension = columnExtensions.find(function (extension) { return extension.columnName === columnName; });
    if (!columnExtension) {
        // tslint:disable-next-line:no-object-literal-type-assertion
        return {};
    }
    return columnExtension;
};
var getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) { return function (columnName) {
    if (columnExtensions) {
        var columnExtension = getColumnExtension(columnExtensions, columnName);
        var extensionValue = columnExtension[extensionName];
        return extensionValue !== undefined ? extensionValue : defaultValue;
    }
    return defaultValue;
}; };

var tableColumnsWithDataRows = function (columns, columnExtensions) { return columns.map(function (column) {
    var name = column.name;
    var columnExtension = getColumnExtension(columnExtensions, name);
    var width = convertWidth(columnExtension.width);
    return {
        column: column,
        key: TABLE_DATA_TYPE.toString() + "_" + name,
        type: TABLE_DATA_TYPE,
        width: width,
        align: columnExtension.align,
        wordWrapEnabled: columnExtension.wordWrapEnabled,
    };
}); };
var tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) { return (!rows.length && !isRemoteRowsLoading
    ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]
    : rows.map(function (row, dataIndex) {
        var rowId = getRowId(row);
        return {
            row: row,
            // dataIndex,
            rowId: rowId,
            type: TABLE_DATA_TYPE,
            key: TABLE_DATA_TYPE.toString() + "_" + rowId,
        };
    })); };
var tableCellColSpanGetter = function (params) {
    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
    if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {
        return tableColumns.length;
    }
    return 1;
};

var visibleTableColumns = function (tableColumns, hiddenColumnNames) {
    if (tableColumns === void 0) { tableColumns = []; }
    return tableColumns.filter(function (tableColumn) { return tableColumn.type !== TABLE_DATA_TYPE
        || hiddenColumnNames.indexOf(tableColumn.column.name) === -1; });
};

var tableDataColumnsExist = function (tableColumns) { return tableColumns.some(function (column) { return column.type === TABLE_DATA_TYPE; }); };

var columnChooserItems = function (columns, hiddenColumnNames) { return columns.map(function (column) { return ({
    column: column,
    hidden: hiddenColumnNames.indexOf(column.name) !== -1,
}); }); };

var toggleColumn = function (hiddenColumnNames, columnName) { return (hiddenColumnNames.indexOf(columnName) === -1
    ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) { return hiddenColumn !== columnName; })); };

var toggleRowExpanded = function (prevExpanded, _a) {
    var rowId = _a.rowId, state = _a.state;
    return toggle(prevExpanded, [rowId], state);
};

var GRID_TREE_NODE_TYPE = Symbol('treeNode');

var customTreeRows = function (currentRow, getChildRows, rootRows, level) {
    if (level === void 0) { level = 0; }
    var childRows = getChildRows(currentRow, rootRows);
    if (!childRows)
        return { rows: [], treeMeta: [], empty: true };
    return childRows
        .reduce(function (acc, row) {
        var _a, _b;
        var nestedResult = customTreeRows(row, getChildRows, rootRows, level + 1);
        (_a = acc.rows).push.apply(_a, __spread([row], nestedResult.rows));
        (_b = acc.treeMeta).push.apply(_b, __spread([[row, { level: level, leaf: !!nestedResult.empty }]], nestedResult.treeMeta));
        return acc;
    }, { rows: [], treeMeta: [] });
};
var customTreeRowsWithMeta = function (rows, getChildRows) {
    var result = customTreeRows(null, getChildRows, rows);
    return {
        rows: result.rows,
        treeMeta: new Map(result.treeMeta),
    };
};
var customTreeRowIdGetter = function (getRowId, _a) {
    var rows = _a.rows, treeMeta = _a.treeMeta;
    var firstNestedRowIndex = rows.findIndex(function (row) { return treeMeta.get(row).level > 0; });
    if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {
        return getRowId;
    }
    var map = new Map(rows
        .map(function (row, rowIndex) { return [row, rowIndex]; }));
    return function (row) { return map.get(row); };
};
var customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {
    var treeMeta = _a.treeMeta;
    return function (row) {
        var rowMeta = treeMeta.get(row);
        if (rowMeta !== undefined) {
            return GRID_TREE_NODE_TYPE.toString() + "_" + rowMeta.level;
        }
        return getRowLevelKey && getRowLevelKey();
    };
};
var expandedTreeRows = function (_a, getRowId, expandedRowIds) {
    var rows = _a.rows, treeMeta = _a.treeMeta;
    var expandedRowIdsSet = new Set(expandedRowIds);
    var currentExpanded = true;
    var currentLevel = 0;
    var collapsedRowsMeta = new Map();
    var resultRows = [];
    rows.forEach(function (row) {
        var rowMeta = treeMeta.get(row);
        var level = rowMeta && rowMeta.level;
        if (level === undefined && currentExpanded) {
            resultRows.push(row);
        }
        else if (!currentExpanded && (level === undefined || level > currentLevel)) {
            var lastRow = resultRows[resultRows.length - 1];
            var collapsedItems = collapsedRowsMeta.get(lastRow);
            if (!collapsedItems) {
                collapsedItems = [];
                collapsedRowsMeta.set(lastRow, collapsedItems);
            }
            collapsedItems.push(row);
        }
        else {
            currentExpanded = expandedRowIdsSet.has(getRowId(row));
            currentLevel = level;
            resultRows.push(row);
        }
    });
    return {
        treeMeta: treeMeta,
        collapsedRowsMeta: collapsedRowsMeta,
        rows: resultRows,
    };
};
var collapsedTreeRowsGetter = function (getCollapsedRows, _a) {
    var collapsedRowsMeta = _a.collapsedRowsMeta;
    return function (row) { return collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row)); };
};
var isTreeRowLeafGetter = function (_a) {
    var treeMeta = _a.treeMeta;
    return function (row) {
        var rowMeta = treeMeta.get(row);
        return rowMeta && rowMeta.leaf;
    };
};
var getTreeRowLevelGetter = function (_a) {
    var treeMeta = _a.treeMeta;
    return function (row) {
        var rowMeta = treeMeta.get(row);
        return (rowMeta && rowMeta.level);
    };
};
var unwrappedCustomTreeRows = function (_a) {
    var rows = _a.rows;
    return rows;
};

var isTreeTableCell = function (tableRow, tableColumn, forColumnName) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE
    && tableColumn.column.name === forColumnName; };

var changeSearchValue = function (prevSearchValue, searchValue) { return searchValue; };

var searchFilterExpression = function (searchValue, columns, filterExpression) {
    var filters = columns.map(function (_a) {
        var name = _a.name;
        return ({ columnName: name, value: searchValue });
    });
    var selfFilterExpression = { filters: filters, operator: 'or' };
    if (!filterExpression) {
        return selfFilterExpression;
    }
    return {
        operator: 'and',
        filters: [filterExpression, selfFilterExpression],
    };
};

var getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) { return function (columnName) { return (columnNames.indexOf(columnName) > -1 && availableFilterOperations)
    // tslint:disable-next-line: max-line-length
    || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))
    || undefined; }; };

var FIXED_COLUMN_LEFT_SIDE = 'left';
var FIXED_COLUMN_RIGHT_SIDE = 'right';
var TABLE_FIXED_TYPE = Symbol('fixed');

var getFixedColumnKeys = function (tableColumns, fixedNames) { return tableColumns
    .filter(function (tableColumn) { return ((tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1)
    || fixedNames.indexOf(tableColumn.type) !== -1); })
    .map(function (_a) {
    var key = _a.key;
    return key;
}); };
var isFixedTableRow = function (tableRow) { return tableRow.type === TABLE_FIXED_TYPE; };
var calculatePosition = function (array, index, tableColumnDimensions) { return (index === 0
    ? 0
    : array
        .slice(0, index)
        .reduce(function (acc, target) { return acc + tableColumnDimensions[target] || 0; }, 0)); };
var calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {
    var tableColumn = _a.tableColumn;
    var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;
    var side = tableColumn.fixed;
    var targetArray = side === FIXED_COLUMN_LEFT_SIDE
        ? getFixedColumnKeys(tableColumns, leftColumns)
        : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();
    var index = tableColumns.findIndex(function (_a) {
        var key = _a.key;
        return key === tableColumn.key;
    });
    var fixedIndex = targetArray.indexOf(tableColumn.key);
    var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);
    var showLeftDivider = columnChain.start === index && index !== 0;
    var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index
        && index < tableColumns.length - 1;
    var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);
    return {
        showRightDivider: showRightDivider,
        showLeftDivider: showLeftDivider,
        position: position,
        side: side,
    };
};

var tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) { return tableColumns
    .map(function (tableColumn) {
    var fixed;
    if ((tableColumn.type === TABLE_DATA_TYPE
        && leftColumns.indexOf(tableColumn.column.name) !== -1)
        || leftColumns.indexOf(tableColumn.type) !== -1) {
        fixed = FIXED_COLUMN_LEFT_SIDE;
    }
    if ((tableColumn.type === TABLE_DATA_TYPE
        && rightColumns.indexOf(tableColumn.column.name) !== -1)
        || rightColumns.indexOf(tableColumn.type) !== -1) {
        fixed = FIXED_COLUMN_RIGHT_SIDE;
    }
    return fixed ? __assign(__assign({}, tableColumn), { fixed: fixed }) : tableColumn;
}); };
var tableHeaderRowsWithFixed = function (tableHeaderRows) { return __spread(tableHeaderRows, [
    { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },
]); };
var tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {
    var chains = tableHeaderColumnChains
        || generateSimpleChains(tableHeaderRows, tableColumns);
    var shouldSplitChain = function (currentGroup, column) { return (!currentGroup || currentGroup.fixed !== column.fixed); };
    var extendChainProps = function (column) { return ({
        fixed: column.fixed,
    }); };
    return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);
};

var defaultSummaryCalculators = {
    count: function (rows) { return rows.length; },
    sum: function (rows, getValue) { return rows.reduce(function (acc, row) { return acc + getValue(row); }, 0); },
    max: function (rows, getValue) { return (rows.length
        ? rows.reduce(function (acc, row) { return Math.max(acc, getValue(row)); }, -Infinity)
        : null); },
    min: function (rows, getValue) { return (rows.length
        ? rows.reduce(function (acc, row) { return Math.min(acc, getValue(row)); }, Infinity)
        : null); },
    avg: function (rows, getValue) { return (rows.length
        ? rows.reduce(function (acc, row) { return acc + getValue(row); }, 0) / rows.length
        : null); },
};
var defaultSummaryCalculator = function (type, rows, getValue) {
    var summaryCalculator = defaultSummaryCalculators[type];
    if (!summaryCalculator) {
        throw new Error("The summary type '" + type + "' is not defined");
    }
    return summaryCalculator(rows, getValue);
};
var rowsSummary = function (rows, summaryItems, getCellValue, calculator) { return summaryItems
    .reduce(function (acc, _a) {
    var type = _a.type, columnName = _a.columnName;
    var getValue = function (row) { return getCellValue(row, columnName); };
    acc.push(calculator(type, rows, getValue));
    return acc;
}, []); };
var expandRows = function (rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {
    if (includeGroupRow === void 0) { includeGroupRow = false; }
    var shouldIncludeRow = includeGroupRow || !isGroupRow
        ? function () { return true; }
        : function (row) { return !isGroupRow(row); };
    return rows
        .reduce(function (acc, row) {
        if (getRowLevelKey && getRowLevelKey(row)) {
            if (shouldIncludeRow(row)) {
                acc.push(row);
            }
            var collapsedRows = getCollapsedRows && getCollapsedRows(row);
            if (collapsedRows) {
                acc.push.apply(acc, __spread(collapsedRows));
            }
            return acc;
        }
        acc.push(row);
        return acc;
    }, []);
};
var totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
    if (calculator === void 0) { calculator = defaultSummaryCalculator; }
    var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);
    return rowsSummary(plainRows, summaryItems, getCellValue, calculator);
};
var groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
    if (calculator === void 0) { calculator = defaultSummaryCalculator; }
    var levels = [];
    var getLevelIndex = function (levelKey) { return (levels.findIndex(function (level) { return level.levelKey === levelKey; })); };
    var summaries = {};
    var anyRowLevelSummaryExist = summaryItems.some(function (item) { return (!item.showInGroupFooter); });
    var expandedRows = anyRowLevelSummaryExist
        ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)
        : rows;
    expandedRows.forEach(function (row) {
        var levelKey = getRowLevelKey(row);
        var collapsedRows = getCollapsedRows && getCollapsedRows(row);
        var levelIndex = getLevelIndex(levelKey);
        if (levelIndex > -1) {
            levels.forEach(function (level) {
                summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
            });
            levels = levels.slice(0, levelIndex);
        }
        if (isGroupRow(row)) {
            levels.push({
                levelKey: levelKey,
                row: row,
                rows: [],
            });
            levelIndex = getLevelIndex(levelKey);
        }
        // when row level summary exists, these rows had already been expanded earlier
        var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;
        var rowsToAppend = !levelKey ? [row] : collapsedRows;
        if (!levelKey || isCollapsedNestedGroupRow) {
            levels.forEach(function (level) {
                var _a;
                (_a = level.rows).push.apply(_a, __spread(rowsToAppend));
            });
        }
    }, {});
    levels.forEach(function (level) {
        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
    });
    return summaries;
};
var treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {
    if (calculator === void 0) { calculator = defaultSummaryCalculator; }
    var levels = [];
    var summaries = {};
    rows.forEach(function (row) {
        var levelKey = getRowLevelKey(row);
        if (!levelKey) {
            levels[levels.length - 1].rows.push(row);
            return;
        }
        var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
        if (levelIndex > -1) {
            levels.slice(levelIndex).forEach(function (level) {
                if (level.rows.length) {
                    summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
                }
            });
            levels = levels.slice(0, levelIndex);
        }
        if (!isGroupRow || !isGroupRow(row)) {
            if (levels.length) {
                levels[levels.length - 1].rows.push(row);
            }
            levels.push({
                levelKey: levelKey,
                row: row,
                rows: [],
            });
        }
    }, {});
    levels.forEach(function (level) {
        if (level.rows.length) {
            summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
        }
    });
    return summaries;
};

var TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');
var TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');
var TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');
var defaultFormatlessSummaries = ['count'];

var isTotalSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isGroupSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isTreeSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
var isTotalSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TOTAL_SUMMARY_TYPE); };
var isGroupSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_GROUP_SUMMARY_TYPE); };
var isTreeSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TREE_SUMMARY_TYPE); };
var getColumnSummaries = function (summaryItems, columnName, summaryValues, predicate) {
    if (predicate === void 0) { predicate = function () { return true; }; }
    return summaryItems
        .map(function (item, index) { return [item, index]; })
        .filter(function (_a) {
        var _b = __read(_a, 1), item = _b[0];
        return item.columnName === columnName && predicate(item);
    })
        .map(function (_a) {
        var _b = __read(_a, 2), item = _b[0], index = _b[1];
        return ({
            type: item.type,
            value: summaryValues[index],
        });
    });
};
var isFooterSummary = function (summaryItem) { return (summaryItem.showInGroupFooter); };
var isInlineGroupCaptionSummary = function (summaryItem) { return (!(summaryItem.showInGroupFooter ||
    summaryItem.alignByColumn)); };
var groupFooterSummaryExists = function (groupSummaryItems) { return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary); };
var getGroupInlineSummaries = function (summaryItems, columns, summaryValues) {
    if (!summaryItems.some(isInlineGroupCaptionSummary)) {
        return [];
    }
    return columns.reduce(function (acc, column) {
        var colName = column.name;
        var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);
        if (summaries.length) {
            acc.push({
                column: column,
                summaries: summaries,
            });
        }
        return acc;
    }, []);
};

var tableRowsWithTotalSummaries = function (footerRows) { return __spread([
    { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }
], footerRows); };
var tableRowsWithSummaries = function (tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {
    if (!getRowLevelKey || !(groupSummaryItems || treeSummaryItems))
        return tableRows;
    var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);
    var result = [];
    var closeLevel = function (level) {
        if (!level.opened)
            return;
        if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {
            var compoundKey = level.row.compoundKey;
            result.push({
                key: TABLE_GROUP_SUMMARY_TYPE.toString() + "_" + compoundKey,
                type: TABLE_GROUP_SUMMARY_TYPE,
                row: level.row,
            });
        }
        else if (treeSummaryItems) {
            var rowId = getRowId(level.row);
            result.push({
                key: TABLE_TREE_SUMMARY_TYPE.toString() + "_" + rowId,
                type: TABLE_TREE_SUMMARY_TYPE,
                row: level.row,
            });
        }
    };
    var levels = [];
    tableRows.forEach(function (tableRow) {
        var row = tableRow.row;
        var levelKey = getRowLevelKey(row);
        if (levelKey) {
            var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
            if (levelIndex > -1) {
                levels.slice(levelIndex).reverse().forEach(closeLevel);
                levels = levels.slice(0, levelIndex);
            }
            if (!isGroupRow || !isGroupRow(row)) {
                levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });
            }
            levels.push({
                levelKey: levelKey,
                row: row,
                opened: false,
            });
        }
        else {
            levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });
        }
        result.push(tableRow);
    });
    levels.slice().reverse().forEach(closeLevel);
    return result;
};

var prepareGroupSummaryItems = function (items) { return (!!items
    ? items.map(function (item) { return (__assign(__assign({}, item), { showInGroupFooter: (item.showInGroupFooter === undefined && !item.alignByColumn)
            ? true
            : item.showInGroupFooter })); })
    : items); };

var getTargetColumnGeometries = function (columnGeometries, sourceIndex) {
    var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;
    var getWidthDifference = function (index) { return columnGeometries[index].right
        - columnGeometries[index].left
        - sourceWidth; };
    return columnGeometries
        .map(function (_a, targetIndex) {
        var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
        var leftBorder = left;
        if (targetIndex > 0 && targetIndex <= sourceIndex) {
            leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));
        }
        if (targetIndex > sourceIndex) {
            leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));
        }
        var rightBorder = right;
        if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {
            rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));
        }
        if (targetIndex < sourceIndex) {
            rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));
        }
        return {
            top: top,
            bottom: bottom,
            right: rightBorder,
            left: leftBorder,
        };
    });
};

var getTableColumnGeometries = function (columns, tableWidth) {
    var columnWidths = columns
        .map(function (column) { return column.width; });
    var freeSpace = tableWidth;
    var restrictedSpace = columnWidths
        .reduce(function (accum, width) { return accum + (typeof width === 'number' ? width : 0); }, 0);
    var freeSpacePortions = columnWidths
        .reduce(function (accum, width) { return accum + (typeof width !== 'number' ? 1 : 0); }, 0);
    var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;
    var lastRightPosition = 0;
    return columnWidths
        .map(function (width) { return (typeof width !== 'number' ? freeSpacePortion : width); })
        .map(function (width) {
        lastRightPosition += width;
        return {
            left: lastRightPosition - width,
            right: lastRightPosition,
        };
    });
};
var getTableTargetColumnIndex = function (columnGeometries, sourceIndex, offset) { return getTargetColumnGeometries(columnGeometries, sourceIndex)
    .findIndex(function (_a) {
    var left = _a.left, right = _a.right;
    return offset > left && offset < right;
}); };
var ANIMATION_DURATION = 200;
var getAnimationProgress = function (animation) { return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION; };
var getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {
    var resizing = prevColumns.map(function (column) { return column.key; }).join()
        === nextColumns.map(function (column) { return column.key; }).join();
    var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth)
        .map(function (geometry, index) { return [prevColumns[index].key, geometry]; })
        .map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], geometry = _b[1];
        var animation = prevAnimations.get(key);
        if (!animation)
            return [key, geometry];
        var progress = easeOutCubic(getAnimationProgress(animation));
        var _c = animation.left, to = _c.to, from = _c.from;
        var left = ((to - from) * progress) + from;
        return [key, {
                left: left,
                right: geometry.right - (geometry.left - left),
            }];
        // tslint:disable-next-line:array-type
    }));
    var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)
        // tslint:disable-next-line:array-type
        .map(function (geometry, index) { return [nextColumns[index].key, geometry]; }));
    return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {
        var prev = prevColumnGeometries.get(key);
        var next = nextColumnGeometries.get(key);
        var result = { startTime: new Date().getTime(), style: {} };
        var takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);
        if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {
            result.left = { from: prev.left, to: next.left };
        }
        return [key, result];
    })
        .filter(function (animation) { return animation[1].left; }));
};
var filterActiveAnimations = function (animations) { return new Map(__spread(animations.entries()).filter(function (_a) {
    var _b = __read(_a, 2), animation = _b[1];
    return getAnimationProgress(animation) < 1;
})); };
var evalAnimations = function (animations) { return new Map(__spread(animations.entries()).map(function (_a) {
    var _b = __read(_a, 2), key = _b[0], animation = _b[1];
    var progress = easeOutCubic(getAnimationProgress(animation));
    var result = __assign({}, animation.style);
    if (animation.left) {
        var offset = (animation.left.to - animation.left.from) * (progress - 1);
        result.transform = "translateX(" + offset + "px)";
    }
    return [key, result];
})); };

var isOnTheSameLine = function (geometry, y) { return (y >= geometry.top && y <= geometry.bottom); };
var rectToObject = function (_a) {
    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
    return ({
        top: top, right: right, bottom: bottom, left: left,
    });
};
var collapseGapsBetweenItems = function (geometries) { return (geometries.map(function (geometry, index) {
    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {
        return __assign(__assign({}, geometry), { right: geometries[index + 1].left });
    }
    return geometry;
})); };
var getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {
    var x = _a.x, y = _a.y;
    if (geometries.length === 0)
        return 0;
    var targetGeometries = sourceIndex !== -1
        ? getTargetColumnGeometries(geometries, sourceIndex)
        : geometries.map(rectToObject);
    var targetIndex = collapseGapsBetweenItems(targetGeometries)
        .findIndex(function (geometry, index) {
        var inVerticalBounds = isOnTheSameLine(geometry, y);
        var inHorizontalBounds = x >= geometry.left && x <= geometry.right;
        var shouldGoFirst = index === 0 && x < geometry.left;
        var shouldGoOnLineBreak = !inVerticalBounds
            && !!geometries[index - 1]
            && isOnTheSameLine(geometries[index - 1], y);
        return (inVerticalBounds && inHorizontalBounds)
            || shouldGoFirst
            || shouldGoOnLineBreak;
    });
    return targetIndex === -1 ? geometries.length : targetIndex;
};

/** @internal */
var arraysEqual = function (arrA, arrB, comparator) {
    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
    if (arrA.length !== arrB.length) {
        return false;
    }
    for (var i = 0; i < arrA.length; i += 1) {
        if (!comparator(arrA[i], arrB[i])) {
            return false;
        }
    }
    return true;
};

/** @internal */
var emptyViewport = {
    columns: [[0, 0]],
    rows: [0, 0],
    headerRows: [0, 0],
    footerRows: [0, 0],
    top: 0,
    left: 0,
    width: 800,
    height: 600,
};
var TOP_POSITION = Symbol('top');
var BOTTOM_POSITION = Symbol('bottom');

var VALID_UNITS$2 = ['px', ''];
/* tslint:disable max-line-length */
var VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';
var getViewport = function (state, getters, estimatedRowHeight, getRowHeight, getColumnWidth) {
    var viewportTop = state.viewportTop, viewportLeft = state.viewportLeft, containerWidth = state.containerWidth, containerHeight = state.containerHeight, headerHeight = state.headerHeight, footerHeight = state.footerHeight;
    var loadedRowsStart = getters.loadedRowsStart, tableBodyRows = getters.bodyRows, tableColumns = getters.columns, _a = getters.headerRows, tableHeaderRows = _a === void 0 ? [] : _a, _b = getters.footerRows, tableFooterRows = _b === void 0 ? [] : _b, isDataRemote = getters.isDataRemote, viewport = getters.viewport;
    var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight - headerHeight - footerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight, isDataRemote);
    var headerRows = getRowsVisibleBoundary(tableHeaderRows, 0, headerHeight, getRowHeight, 0, estimatedRowHeight, false);
    var footerRows = getRowsVisibleBoundary(tableFooterRows, 0, footerHeight, getRowHeight, 0, estimatedRowHeight, false);
    var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth);
    // NOTE: prevent unnecessary updates
    // e.g. when rows changed but bounds remain the same.
    var result = viewport;
    if (viewportTop !== viewport.top) {
        result = __assign(__assign({}, result), { top: viewportTop });
    }
    if (viewportLeft !== viewport.left) {
        result = __assign(__assign({}, result), { left: viewportLeft });
    }
    if (containerWidth !== viewport.width) {
        result = __assign(__assign({}, result), { width: containerWidth });
    }
    if (containerHeight !== viewport.height) {
        result = __assign(__assign({}, result), { height: containerHeight });
    }
    if (!arraysEqual(rows, viewport.rows)) {
        result = __assign(__assign({}, result), { rows: rows });
    }
    if (!arraysEqual(headerRows, viewport.headerRows)) {
        result = __assign(__assign({}, result), { headerRows: headerRows });
    }
    if (!arraysEqual(footerRows, viewport.footerRows)) {
        result = __assign(__assign({}, result), { footerRows: footerRows });
    }
    if (!arraysEqual(columns, viewport.columns, arraysEqual)) {
        result = __assign(__assign({}, result), { columns: columns });
    }
    return result;
};
var checkColumnWidths = function (tableColumns) {
    return tableColumns.reduce(function (acc, tableColumn) {
        var width = tableColumn.width;
        if (typeof width === 'string') {
            var numb = parseInt(width, 10);
            var unit_1 = numb ? width.substr(numb.toString().length) : width;
            var isValidUnit = VALID_UNITS$2.some(function (validUnit) { return validUnit === unit_1; });
            if (!isValidUnit) {
                throw new Error(VIRTUAL_TABLE_ERROR);
            }
            acc.push(__assign(__assign({}, tableColumn), { width: numb }));
        }
        else {
            acc.push(tableColumn);
        }
        return acc;
    }, []);
};
var calculateScrollHeight = function (rowHeight, index) {
    return index > -1 ? rowHeight * index : undefined;
};
var getScrollTop = function (rows, rowsCount, rowId, rowHeight, isDataRemote) {
    if (rowId === TOP_POSITION) {
        return 0;
    }
    if (rowId === BOTTOM_POSITION) {
        return rowsCount * rowHeight;
    }
    var searchIndexRequired = !isDataRemote && rowId !== undefined;
    var indexById = searchIndexRequired
        ? rows.findIndex(function (row) { return row.rowId === rowId; })
        : undefined;
    return calculateScrollHeight(rowHeight, indexById);
};
var getTopRowId = function (viewport, tableBodyRows, isDataRemote) {
    var hasViewportRows = viewport && viewport.rows;
    var hasBodyRows = tableBodyRows && tableBodyRows.length;
    if (hasViewportRows && hasBodyRows && !isDataRemote) {
        var index = viewport.rows[0];
        return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;
    }
    return undefined;
};

var virtualRowsWithCache = function (skip, rows, cache) {
    var rowsInterval = intervalUtil.getRowsInterval({ skip: skip, rows: rows });
    var cacheInterval = intervalUtil.getRowsInterval(cache);
    return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);
};
var plainRows = function (virtualRows, availableRowCount) {
    return virtualRows.rows.length > availableRowCount
        ? virtualRows.rows.slice(0, availableRowCount)
        : virtualRows.rows;
};
var loadedRowsStart = function (virtualRows) { return virtualRows.skip; };

var ROOT_GROUP = '__root__';
var DEFAULT_COLUMN_WIDTH = 150;

var exportHeader = function (worksheet, columns) {
    var cols = columns
        .map(function (_a) {
        var column = _a.column, width = _a.width;
        return ({
            width: (width || DEFAULT_COLUMN_WIDTH) / 8,
            key: column === null || column === void 0 ? void 0 : column.name,
        });
    });
    worksheet.columns = cols;
    var lastRow = worksheet.lastRow;
    if (lastRow) {
        worksheet.addRow({});
    }
    var headerRow = columns.reduce(function (acc, _a) {
        var _b;
        var _c = _a.column, _d = _c === void 0 ? {} : _c, name = _d.name, title = _d.title;
        return (__assign(__assign({}, acc), (_b = {}, _b[name] = title, _b)));
    }, {});
    worksheet.addRow(headerRow);
    worksheet.views.push({
        state: 'frozen', ySplit: worksheet.lastRow.number,
    });
};
var findRanges = function (groupTree, compoundKey, level, maxLevel, result) {
    if (result === void 0) { result = []; }
    if (level !== maxLevel) {
        var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) { return (__spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result))); }, []);
        return __spread(result, ranges);
    }
    return __spread(result, [groupTree[compoundKey]]);
};
var exportRows = function (worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {
    var currentLevel = 0;
    var openGroups = [];
    var closeGroup = getCloseGroup(rowsOffset);
    allRows.forEach(function (row) {
        var _a;
        var _b;
        var excelRow;
        if (isGroupRow && isGroupRow(row)) {
            currentLevel = outlineLevels[row.groupedBy];
            // close nested groups first
            openGroups.slice(currentLevel).reverse().forEach(closeGroup);
            openGroups = openGroups.slice(0, currentLevel);
            openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };
            // add group row
            var title = (_b = dataColumns.find(function (_a) {
                var name = _a.name;
                return name === row.groupedBy;
            })) === null || _b === void 0 ? void 0 : _b.title;
            excelRow = (_a = {}, _a[columns[0].column.name] = title + ": " + row.value, _a);
            worksheet.addRow(excelRow);
            var lastIndex = worksheet.lastRow.number;
            // merge into single cell
            worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);
            worksheet.lastRow.getCell(1).font = { bold: true };
            if (currentLevel > 0) {
                worksheet.lastRow.outlineLevel = currentLevel;
            }
            currentLevel += 1;
        }
        else {
            excelRow = columns.reduce(function (acc, _a) {
                var _b;
                var column = _a.column;
                return (__assign(__assign({}, acc), (column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null)));
            }, {});
            worksheet.addRow(excelRow);
            worksheet.lastRow.outlineLevel = currentLevel;
        }
        worksheet.lastRow.eachCell(function (cell, colNumber) {
            customizeCell(cell, row, columns[colNumber - 1].column);
        });
    });
    openGroups.reverse().forEach(closeGroup);
};
var closeSheet = function (worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {
    exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);
};
var normalizeRanges = function (ranges, offset) { return (ranges.map(function (range) { return range.map(function (index) { return +index + offset; }); })); };
var exportSummaryItems = function (worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {
    if (!summaryItems)
        return;
    worksheet.addRow({});
    var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);
    summaryItems.forEach(function (s) {
        exportSummary(s, ranges);
    });
};
var removeEmptyGroups = function (rows, grouping, isGroupRow) {
    if (!grouping)
        return rows;
    var groupingColumns = grouping.map(function (_a) {
        var columnName = _a.columnName;
        return columnName;
    });
    var result = [];
    var groupChain = [];
    rows.forEach(function (row) {
        if (isGroupRow(row)) {
            var level = groupingColumns.indexOf(row.groupedBy);
            if (level === groupChain.length) {
                groupChain.push(row);
            }
            else {
                groupChain = __spread(groupChain.slice(0, level), [row]);
            }
        }
        else {
            if (groupChain.length > 0) {
                result.push.apply(result, __spread(groupChain));
                groupChain = Array.from({ length: groupChain.length });
            }
            result.push(row);
        }
    });
    return result.filter(function (row) { return !!row; });
};

var groupOutlineLevels = function (grouping) { return ((grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {
    var _b;
    var columnName = _a.columnName;
    return (__assign(__assign({}, acc), (_b = {}, _b[columnName] = index, _b)));
}, {})) || {}); };
var filterSelectedRows = function (rows, selection, getRowId, isGroupRow) {
    var selectionSet = new Set(selection);
    return rows.filter(function (row) { return (isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)); });
};
var rowsToExport = function (rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {
    var expandRows = function (collapsedRows) { return (collapsedRows.reduce(function (acc, row) { return (__spread(acc, [row], (expandRows(getCollapsedRows(row) || [])))); }, [])); };
    var expandedRows = getCollapsedRows ? expandRows(rows) : rows;
    if (!selection) {
        return expandedRows;
    }
    var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);
    return removeEmptyGroups(filteredRows, grouping, isGroupRow);
};
var buildGroupTree = function (rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {
    var _a;
    var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);
    if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {
        groupTree[ROOT_GROUP] = [0, rows.length - 1];
        return groupTree;
    }
    var maxLevel = Object.keys(outlineLevels).length - 1;
    var groupSummaryExists = !!groupSummaryItems;
    var parentChain = { '-1': ROOT_GROUP };
    var lastDataIndex = 0;
    var openGroup = '';
    var index = 0;
    var level = 0;
    var prevLevel = 0;
    rows.forEach(function (row) {
        var groupedBy = row.groupedBy, compoundKey = row.compoundKey;
        if (isGroupRow(row)) {
            level = outlineLevels[groupedBy];
            groupTree[compoundKey] = [];
            parentChain[level] = compoundKey;
            if (level <= maxLevel) {
                groupTree[parentChain[level - 1]].push(compoundKey);
            }
            if (level === maxLevel) {
                if (openGroup) {
                    // close previous group
                    groupTree[openGroup].push(lastDataIndex);
                }
                openGroup = compoundKey;
                if (groupSummaryExists && lastDataIndex > 0) {
                    index += 1;
                }
                groupTree[compoundKey].push(index + 1); // first row index
            }
            else if (groupSummaryExists && level < prevLevel) {
                // jump over summary rows
                index += maxLevel - level;
            }
            prevLevel = level;
        }
        else {
            lastDataIndex = index;
        }
        index += 1;
    });
    if (openGroup) {
        groupTree[openGroup].push(lastDataIndex);
    }
    return groupTree;
};
var operations = {
    count: 'COUNTA',
};
var exportSummaryGetter = function (worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) { return function (_a, ranges) {
    var columnName = _a.columnName, type = _a.type;
    var column = (tableColumns.find(function (_a) {
        var dataColumn = _a.column, columnType = _a.type;
        return (columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName);
    }) || {}).column;
    // NOTE: column is hidden or the grid grouped by this column
    if (!column) {
        return;
    }
    var row = worksheet.lastRow;
    var letter = worksheet.getColumn(columnName).letter;
    var operation = operations[type] || type.toUpperCase();
    var rangesStr = ranges.map(function (range) { return (range
        .map(function (r) { return "" + letter + r; })
        .filter(function (val, index, arr) { return arr.indexOf(val) === index; })
        .join(':')); }).join(',');
    var cell = row.getCell(columnName);
    cell.value = {
        formula: operation + "(" + rangesStr + ")",
        date1904: false,
    };
    cell.numFmt = "\"" + defaultSummaryMessages[type] + ":\" 0";
    var summary = {
        type: type,
        ranges: ranges,
    };
    customizeSummaryCell(cell, column, summary);
}; };
var closeGroupGetter = function (worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) { return function (rowsOffset) { return function (group) {
    var groupedBy = group.groupedBy, compoundKey = group.compoundKey;
    exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);
}; }; };
var maximumGroupLevel = function (grouping) { return ((grouping || []).length - 1); };

var TABLE_STUB_TYPE = Symbol('stub');
var getVisibleBoundaryWithFixed = function (visibleBoundary, items) { return items.reduce(function (acc, item, index) {
    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {
        acc.push([index, index]);
    }
    return acc;
}, [visibleBoundary]); };
var getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {
    if (offset === void 0) { offset = 0; }
    if (itemSize === void 0) { itemSize = 0; }
    var start = null;
    var end = null;
    var index = 0;
    var beforePosition = offset * itemSize;
    var viewportEnd = viewportStart + viewportSize;
    while (end === null && index < items.length) {
        var item = items[index];
        var afterPosition = beforePosition + getItemSize(item);
        var isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)
            || (afterPosition > viewportStart && afterPosition <= viewportEnd)
            || (beforePosition < viewportStart && afterPosition > viewportEnd);
        if (isVisible && start === null) {
            start = index;
        }
        if (!isVisible && start !== null) {
            end = index - 1;
            break;
        }
        index += 1;
        beforePosition = afterPosition;
    }
    if (start !== null && end === null) {
        end = index - 1;
    }
    start = start === null ? 0 : start;
    end = end === null ? 0 : end;
    return [start + offset, end + offset];
};
var getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {
    var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];
    start = Math.max(0, start - overscan);
    end = Math.min(itemsCount - 1, end + overscan);
    return [start, end];
};
var getColumnBoundaries = function (columns, left, width, getColumnWidth) { return (getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns)); };
var getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight, isDataRemote) {
    var beforePosition = offset * rowHeight;
    var noVisibleRowsLoaded = rowHeight > 0 &&
        beforePosition + rows.length * rowHeight < top ||
        top < beforePosition;
    var boundaries;
    if (isDataRemote && noVisibleRowsLoaded) {
        var topIndex = Math.round(top / rowHeight);
        boundaries = [topIndex, topIndex];
    }
    else {
        boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);
    }
    return boundaries;
};
var getColumnsRenderBoundary = function (columnCount, visibleBoundary) { return getRenderBoundary(columnCount, visibleBoundary, 1); };
var getRowsRenderBoundary = function (rowsCount, visibleBoundary) { return getRenderBoundary(rowsCount, visibleBoundary, 3); };
var getSpanBoundary = function (items, visibleBoundaries, getItemSpan) { return visibleBoundaries
    .map(function (visibleBoundary) {
    var endIndex = Math.min(visibleBoundary[1], items.length - 1);
    var end = endIndex;
    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;
    for (var index = 0; index <= endIndex; index += 1) {
        var span = getItemSpan(items[index]);
        if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {
            start = index;
        }
        if (index + (span - 1) > visibleBoundary[1]) {
            end = index + (span - 1);
        }
    }
    return [start, end];
}); };
var collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {
    var breakpoints = new Set([0, itemsCount]);
    spanBoundaries.forEach(function (rowBoundaries) { return rowBoundaries
        .forEach(function (boundary) {
        breakpoints.add(boundary[0]);
        // next interval starts after span end point
        breakpoints.add(Math.min(boundary[1] + 1, itemsCount));
    }); });
    visibleBoundaries
        .filter(function (boundary) { return boundary.every(function (bound) { return 0 <= bound && bound < itemsCount; }); })
        .forEach(function (boundary) {
        for (var point = boundary[0]; point <= boundary[1]; point += 1) {
            breakpoints.add(point);
        }
        if (boundary[1] + 1 < itemsCount) {
            // close last visible point
            breakpoints.add(boundary[1] + 1);
        }
    });
    var bp = __spread(breakpoints).sort(function (a, b) { return a - b; });
    var bounds = [];
    for (var i = 0; i < bp.length - 1; i += 1) {
        bounds.push([
            bp[i],
            bp[i + 1] - 1,
        ]);
    }
    return bounds;
};
var getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {
    var size = 0;
    for (var i = startIndex; i <= endIndex; i += 1) {
        size += getColumnSize(columns[i], 0) || 0;
    }
    return size;
};
var getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {
    var collapsedColumns = [];
    boundaries.forEach(function (boundary) {
        var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) { return (acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])); }, false);
        if (isVisible) {
            var column = columns[boundary[0]];
            collapsedColumns.push(__assign(__assign({}, column), { width: getColumnWidth(column) }));
        }
        else {
            collapsedColumns.push({
                key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                type: TABLE_STUB_TYPE,
                width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),
            });
        }
    });
    return collapsedColumns;
};
var getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {
    var collapsedRows = [];
    boundaries.forEach(function (boundary) {
        var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
        if (isVisible) {
            var row = rows[boundary[0] - offset];
            collapsedRows.push({
                row: row,
                cells: getCells(row),
            });
        }
        else {
            var row = {};
            collapsedRows.push({
                row: {
                    key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                    type: TABLE_STUB_TYPE,
                    height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),
                },
                cells: getCells(row),
            });
        }
    });
    return collapsedRows;
};
var getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {
    var collapsedCells = [];
    var index = 0;
    var _loop_1 = function () {
        var boundary = boundaries[index];
        var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) { return (acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])); }, false);
        if (isSpan) {
            var column = columns[boundary[0]];
            var realColSpan = getColSpan(column);
            var realColSpanEnd_1 = (realColSpan + boundary[0]) - 1;
            var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) { return colSpanBoundary[0]
                <= realColSpanEnd_1 && realColSpanEnd_1
                <= colSpanBoundary[1]; });
            collapsedCells.push({
                column: column,
                colSpan: (colSpanEnd - index) + 1,
            });
            index += 1;
        }
        else {
            collapsedCells.push({
                column: {
                    key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                    type: TABLE_STUB_TYPE,
                },
                colSpan: 1,
            });
            index += 1;
        }
    };
    while (index < boundaries.length) {
        _loop_1();
    }
    return collapsedCells;
};
var getCollapsedGrid = function (_a) {
    var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, _b = _a.getColumnWidth, getColumnWidth = _b === void 0 ? function (column) { return column.width; } : _b, _c = _a.getRowHeight, getRowHeight = _c === void 0 ? function (row) { return row.height; } : _c, _d = _a.getColSpan, getColSpan = _d === void 0 ? function () { return 1; } : _d, totalRowCount = _a.totalRowCount, offset = _a.offset;
    if (!columns.length) {
        return {
            columns: [],
            rows: [],
        };
    }
    var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];
    var rowSpanBoundaries = rows
        .slice(boundaries[0], boundaries[1])
        .map(function (row) { return getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }); });
    var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);
    var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);
    return {
        columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),
        rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) { return getCollapsedCells(columns, getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }), columnBoundaries, function (column) { return getColSpan(row, column); }); }, offset),
    };
};
var getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {
    var colsHavingWidth = tableColumns.filter(function (col) { return typeof col.width === 'number'; });
    var columnsWidth = colsHavingWidth.reduce(function (acc, col) { return (acc + col.width); }, 0);
    var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);
    var autoColWidth = Math.max(autoWidth, minColumnWidth);
    return function (column) { return (column.type === TABLE_FLEX_TYPE
        ? null
        : typeof column.width === 'number' ? column.width : autoColWidth); };
};
var getCollapsedGrids = function (_a) {
    var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewport = _a.viewport, getRowHeight = _a.getRowHeight, getColumnWidth = _a.getColumnWidth;
    var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
    var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {
        if (rowCount === void 0) { rowCount = rows.length; }
        if (offset === void 0) { offset = 0; }
        return getCollapsedGrid({
            rows: rows,
            columns: columns,
            rowsVisibleBoundary: rowsVisibleBoundary,
            columnsVisibleBoundary: viewport.columns,
            getColumnWidth: getColumnWidth,
            getRowHeight: getRowHeight,
            getColSpan: getColSpan,
            totalRowCount: rowCount,
            offset: offset,
        });
    };
    var headerGrid = getCollapsedGridBlock(headerRows, getRenderRowBounds(viewport.headerRows, headerRows.length));
    var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);
    var footerGrid = getCollapsedGridBlock(footerRows, getRenderRowBounds(viewport.footerRows, footerRows.length));
    return {
        headerGrid: headerGrid,
        bodyGrid: bodyGrid,
        footerGrid: footerGrid,
    };
};
var getRenderRowBounds = function (visibleBounds, rowCount) { return getRowsRenderBoundary(rowCount, visibleBounds); };
var adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {
    var renderRowBoundaries = getRenderRowBounds(visibleBounds, loadedRowsStart + rowCount);
    var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart, end: loadedRowsStart + rowCount });
    return [adjustedInterval.start, adjustedInterval.end];
};

var getGroupIndexByColumn = function (grouping, tableColumn) { return grouping.findIndex(function (columnGrouping) { return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name; }); };
var isIndentCell = function (tableRow, tableColumn, grouping) {
    if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)
        return false;
    var rowGroupIndex = grouping.findIndex(function (columnGrouping) { return columnGrouping.columnName === tableRow.row.groupedBy; });
    var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);
    return columnGroupIndex < rowGroupIndex;
};
var isGroupTableCell = function (tableRow, tableColumn) { return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
    && tableColumn.column
    && tableColumn.column.name === tableRow.row.groupedBy); };
var isGroupIndentTableCell = function (tableRow, tableColumn, grouping) { return (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&
    isIndentCell(tableRow, tableColumn, grouping)); };
var isGroupIndentStubTableCell = function (tableRow, tableColumn, grouping) { return ((tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&
    isIndentCell(tableRow, tableColumn, grouping))); };
var isGroupTableRow = function (tableRow) { return tableRow.type === TABLE_GROUP_TYPE; };
var isGroupRowOrdinaryCell = function (tableRow, tableColumn) { return (isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)); };
var columnHasGroupRowSummary = function (tableColumn, groupSummaryItems) { return (!!(groupSummaryItems && groupSummaryItems
    .some(function (item) { return ((!item.showInGroupFooter && item.alignByColumn)
    && item.columnName === (tableColumn.column && tableColumn.column.name)); }))); };
var isRowSummaryCell = function (tableRow, tableColumn, grouping, groupSummaryItems) { return (columnHasGroupRowSummary(tableColumn, groupSummaryItems)
    && !isGroupIndentTableCell(tableRow, tableColumn, grouping)); };
var isPreviousCellContainSummary = function (tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {
    var columnIndex = tableColumns.indexOf(tableColumn);
    return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);
};
var calculateGroupCellIndent = function (tableColumn, grouping, indentWidth) { return (indentWidth * getGroupIndexByColumn(grouping, tableColumn)); };

export { BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_FILL_LEVEL_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, BOTTOM_POSITION, DEFAULT_COLUMN_WIDTH, DEFAULT_FILTER_OPERATIONS, FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, GROUP_KEY_SEPARATOR, ROOT_GROUP, TABLE_ADDED_TYPE, TABLE_BAND_TYPE, TABLE_DATA_TYPE, TABLE_DETAIL_TYPE, TABLE_EDIT_COMMAND_TYPE, TABLE_EDIT_TYPE, TABLE_FILTER_TYPE, TABLE_FIXED_TYPE, TABLE_FLEX_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_GROUP_TYPE, TABLE_HEADING_TYPE, TABLE_NODATA_TYPE, TABLE_REORDERING_TYPE, TABLE_SELECT_TYPE, TABLE_STUB_TYPE, TABLE_TOTAL_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE, TOP_POSITION, addRow, addedRowsByIds, adjustSortIndex, allSelected, bandLevelsVisibility, buildGroupTree, calculateFixedColumnProps, calculateGroupCellIndent, calculateKeepOther, calculateRequestedRange, calculateScrollHeight, calculateStartPage, cancelAddedRows, cancelChanges, cancelColumnGroupingDraft, cancelDeletedRows, cancelTableColumnWidthDraft, cellValueGetter, changeAddedRow, changeColumnFilter, changeColumnGrouping, changeColumnOrder, changeColumnSorting, changeRow, changeSearchValue, changeTableColumnWidth, changedRowsByIds, checkColumnWidths, checkTableColumnExtensions, clamp, closeGroupGetter, closeSheet, collapsedTreeRowsGetter, columnBandLevels, columnChooserItems, columnVisibleIntervals, columnsWithEditingCells, convertWidth, createRowChangeGetter, currentPage, customGroupedRows, customGroupingRowIdGetter, customTreeRowIdGetter, customTreeRowLevelKeyGetter, customTreeRowsWithMeta, defaultFilterPredicate, defaultFormatlessSummaries, defaultSummaryCalculator, deleteRows, draftColumnGrouping, draftOrder, draftTableColumnWidth, emptyViewport, emptyVirtualRows, evalAnimations, expandedGroupRows, expandedTreeRows, exportHeader, exportRows, exportSummaryGetter, exportSummaryItems, filterActiveAnimations, filterExpression, filteredCollapsedRowsGetter, filteredRows, findChainByColumnIndex, findRanges, firstRowOnPage, generateSimpleChains, getAnimations, getAvailableFilterOperationsGetter, getAvailableRowCount, getBandComponent, getCollapsedGrid, getCollapsedGrids, getColumnBoundaries, getColumnExtension, getColumnExtensionValueGetter, getColumnFilterConfig, getColumnFilterOperations, getColumnMeta, getColumnSizes, getColumnSortingDirection, getColumnSummaries, getColumnWidthGetter, getColumnsRenderBoundary, getFixedColumnKeys, getForceReloadInterval, getGroupCellTargetIndex, getGroupInlineSummaries, getNextColumnName, getPersistentSortedColumns, getReferenceIndex, getRequestMeta, getRowChange, getRowsRenderBoundary, getRowsVisibleBoundary, getScrollTop, getSelectedFilterOperation, getTableColumnGeometries, getTableTargetColumnIndex, getTopRowId, getTreeRowLevelGetter, getViewport, groupCollapsedRowsGetter, groupFooterSummaryExists, groupOutlineLevels, groupRowChecker, groupRowLevelKeyGetter, groupSummaryValues, groupedRows, groupingPanelItems, intervalUtil, isAddedTableRow, isBandedOrHeaderRow, isBandedTableRow, isDataTableCell, isDataTableRow, isDetailRowExpanded, isDetailTableCell, isDetailTableRow, isDetailToggleTableCell, isEditCommandsTableCell, isEditTableCell, isEditTableRow, isFilterTableCell, isFilterTableRow, isFilterValueEmpty, isFixedTableRow, isFooterSummary, isGroupIndentStubTableCell, isGroupIndentTableCell, isGroupRowOrdinaryCell, isGroupSummaryTableCell, isGroupSummaryTableRow, isGroupTableCell, isGroupTableRow, isHeaderStubTableCell, isHeadingEditCommandsTableCell, isHeadingTableCell, isHeadingTableRow, isInlineGroupCaptionSummary, isNoDataColumn, isNoDataTableCell, isNoDataTableRow, isPreviousCellContainSummary, isRowHighlighted, isRowSummaryCell, isSelectAllTableCell, isSelectTableCell, isStubTableCell, isTotalSummaryTableCell, isTotalSummaryTableRow, isTreeRowLeafGetter, isTreeSummaryTableCell, isTreeSummaryTableRow, isTreeTableCell, isValidValue, lastRowOnPage, loadedRowsStart, maximumGroupLevel, mergeRows, needFetchMorePages, normalizeRanges, orderedColumns, pageCount, paginatedRows, plainRows, prepareGroupSummaryItems, recalculateBounds, removeEmptyGroups, rowCount, rowIdGetter, rowToPageIndex, rowsToExport, rowsWithAvailableToSelect, rowsWithEditingCells, rowsWithPageHeaders, searchFilterExpression, setCurrentPage, setPageSize, shouldSendRequest, someSelected, sortedRows, splitHeaderColumnChains, startEditCells, startEditRows, stopEditCells, stopEditRows, tableCellColSpanGetter, tableColumnsWithDataRows, tableColumnsWithDetail, tableColumnsWithDraftWidths, tableColumnsWithEditing, tableColumnsWithFixed, tableColumnsWithGrouping, tableColumnsWithSelection, tableColumnsWithWidths, tableDataColumnsExist, tableDetailCellColSpanGetter, tableGroupCellColSpanGetter, tableHeaderColumnChainsWithBands, tableHeaderColumnChainsWithFixed, tableHeaderRowsWithFilter, tableHeaderRowsWithFixed, tableHeaderRowsWithReordering, tableRowsWithBands, tableRowsWithDataRows, tableRowsWithEditing, tableRowsWithExpandedDetail, tableRowsWithGrouping, tableRowsWithHeading, tableRowsWithSummaries, tableRowsWithTotalSummaries, toggleColumn, toggleDetailRowExpanded, toggleExpandedGroups, toggleRowExpanded, toggleSelection, totalSummaryValues, treeSummaryValues, trimRowsToInterval, unwrapSelectedRows, unwrappedCustomTreeRows, unwrappedFilteredRows, virtualRowsWithCache, visibleTableColumns };
//# sourceMappingURL=dx-grid-core.es.js.map
