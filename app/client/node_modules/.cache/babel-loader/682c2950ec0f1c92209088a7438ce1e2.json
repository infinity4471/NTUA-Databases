{"ast":null,"code":"import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\n\nvar compare = function (a, b) {\n  if (isBlank(a)) {\n    return a === b ? 0 : -1;\n  }\n\n  if (isBlank(b)) {\n    return 1;\n  }\n\n  if (a.localeCompare) {\n    return a.localeCompare(b);\n  }\n\n  return a > b ? 1 : a < b ? -1 : 0;\n};\n\nvar compareDesc = function (a, b) {\n  return compare(b, a);\n};\n\nvar descriptorAsFunc = function (descriptor) {\n  var prop = getter(descriptor.field, true);\n  return function (a, b) {\n    return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n  };\n};\n\nvar initial = function (_a, _b) {\n  return 0;\n}; // tslint:disable:max-line-length\n\n/**\n * Converts the `SortDescriptors` into a [`Comparer`]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts-no-run\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\n\n\nexport var composeSortDescriptors = function (descriptors) {\n  return descriptors.filter(function (x) {\n    return isPresent(x.dir);\n  }).map(function (descriptor) {\n    return descriptorAsFunc(descriptor);\n  }).reduce(function (acc, curr) {\n    return function (a, b) {\n      return acc(a, b) || curr(a, b);\n    };\n  }, initial);\n};","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js"],"names":["isPresent","isBlank","getter","compare","a","b","localeCompare","compareDesc","descriptorAsFunc","descriptor","prop","field","dir","initial","_a","_b","composeSortDescriptors","descriptors","filter","x","map","reduce","acc","curr"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,UAAnC;AACA,SAASC,MAAT,QAAuB,aAAvB;;AACA,IAAIC,OAAO,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC1B,MAAIJ,OAAO,CAACG,CAAD,CAAX,EAAgB;AACZ,WAAOA,CAAC,KAAKC,CAAN,GAAU,CAAV,GAAc,CAAC,CAAtB;AACH;;AACD,MAAIJ,OAAO,CAACI,CAAD,CAAX,EAAgB;AACZ,WAAO,CAAP;AACH;;AACD,MAAID,CAAC,CAACE,aAAN,EAAqB;AACjB,WAAOF,CAAC,CAACE,aAAF,CAAgBD,CAAhB,CAAP;AACH;;AACD,SAAOD,CAAC,GAAGC,CAAJ,GAAQ,CAAR,GAAaD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAAjC;AACH,CAXD;;AAYA,IAAIE,WAAW,GAAG,UAAUH,CAAV,EAAaC,CAAb,EAAgB;AAAE,SAAOF,OAAO,CAACE,CAAD,EAAID,CAAJ,CAAd;AAAuB,CAA3D;;AACA,IAAII,gBAAgB,GAAG,UAAUC,UAAV,EAAsB;AACzC,MAAIC,IAAI,GAAGR,MAAM,CAACO,UAAU,CAACE,KAAZ,EAAmB,IAAnB,CAAjB;AACA,SAAO,UAAUP,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAO,CAACI,UAAU,CAACG,GAAX,KAAmB,KAAnB,GAA2BT,OAA3B,GAAqCI,WAAtC,EAAmDG,IAAI,CAACN,CAAD,CAAvD,EAA4DM,IAAI,CAACL,CAAD,CAAhE,CAAP;AAA8E,GAAvG;AACH,CAHD;;AAIA,IAAIQ,OAAO,GAAG,UAAUC,EAAV,EAAcC,EAAd,EAAkB;AAAE,SAAO,CAAP;AAAW,CAA7C,C,CACA;;AACA;;;;;;;;;;;;;;;AAeA;;;AACA,OAAO,IAAIC,sBAAsB,GAAG,UAAUC,WAAV,EAAuB;AAAE,SAAQA,WAAW,CAC3EC,MADgE,CACzD,UAAUC,CAAV,EAAa;AAAE,WAAOnB,SAAS,CAACmB,CAAC,CAACP,GAAH,CAAhB;AAA0B,GADgB,EAEhEQ,GAFgE,CAE5D,UAAUX,UAAV,EAAsB;AAAE,WAAOD,gBAAgB,CAACC,UAAD,CAAvB;AAAsC,GAFF,EAGhEY,MAHgE,CAGzD,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AAAE,WAAO,UAAUnB,CAAV,EAAaC,CAAb,EAAgB;AAAE,aAAOiB,GAAG,CAAClB,CAAD,EAAIC,CAAJ,CAAH,IAAakB,IAAI,CAACnB,CAAD,EAAIC,CAAJ,CAAxB;AAAiC,KAA1D;AAA6D,GAH3B,EAG6BQ,OAH7B,CAAR;AAGiD,CAHvG","sourcesContent":["import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nvar compare = function (a, b) {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nvar compareDesc = function (a, b) { return compare(b, a); };\nvar descriptorAsFunc = function (descriptor) {\n    var prop = getter(descriptor.field, true);\n    return function (a, b) { return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b)); };\n};\nvar initial = function (_a, _b) { return 0; };\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [`Comparer`]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts-no-run\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport var composeSortDescriptors = function (descriptors) { return (descriptors\n    .filter(function (x) { return isPresent(x.dir); })\n    .map(function (descriptor) { return descriptorAsFunc(descriptor); })\n    .reduce(function (acc, curr) { return function (a, b) { return acc(a, b) || curr(a, b); }; }, initial)); };\n"]},"metadata":{},"sourceType":"module"}