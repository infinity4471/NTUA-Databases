{"ast":null,"code":"import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\n\nexport var normalizeGroups = function (descriptors) {\n  descriptors = isArray(descriptors) ? descriptors : [descriptors];\n  return descriptors.map(function (x) {\n    return Object.assign({\n      dir: \"asc\"\n    }, x);\n  });\n};\nvar identity = map(function (x) {\n  return x;\n});\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts-no-run\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\n\nexport var groupBy = function (data, descriptors, transformers, originalData) {\n  if (descriptors === void 0) {\n    descriptors = [];\n  }\n\n  if (transformers === void 0) {\n    transformers = identity;\n  }\n\n  if (originalData === void 0) {\n    originalData = data;\n  }\n\n  descriptors = normalizeGroups(descriptors);\n\n  if (!descriptors.length) {\n    return data;\n  }\n\n  var descriptor = descriptors[0];\n  var initialValue = {};\n  var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n  var result = [];\n  Object.keys(view).forEach(function (field) {\n    Object.keys(view[field]).forEach(function (value) {\n      var group = view[field][value];\n      var aggregateResult = {};\n      var filteredData = originalData;\n\n      if (isPresent(descriptor.aggregates)) {\n        filteredData = filterBy(originalData, {\n          field: descriptor.field,\n          ignoreCase: false,\n          operator: 'eq',\n          value: group.value\n        });\n        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n      }\n\n      result[group.__position] = {\n        aggregates: aggregateResult,\n        field: field,\n        items: descriptors.length > 1 ? groupBy(group.items, descriptors.slice(1), identity, filteredData) : group.items,\n        value: group.value\n      };\n    });\n  });\n  return result;\n};","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js"],"names":["exec","map","groupCombinator","isArray","isPresent","aggregateBy","filterBy","normalizeGroups","descriptors","x","Object","assign","dir","identity","groupBy","data","transformers","originalData","length","descriptor","initialValue","view","field","result","keys","forEach","value","group","aggregateResult","filteredData","aggregates","ignoreCase","operator","__position","items","slice"],"mappings":"AAAA,SAASA,IAAT,EAAeC,GAAf,EAAoBC,eAApB,QAA2C,gBAA3C;AACA,SAASC,OAAT,EAAkBC,SAAlB,QAAmC,UAAnC;AACA,SAASC,WAAT,QAA4B,uBAA5B;AACA,SAASC,QAAT,QAAyB,wCAAzB;AACA;;;;AAGA,OAAO,IAAIC,eAAe,GAAG,UAAUC,WAAV,EAAuB;AAChDA,EAAAA,WAAW,GAAGL,OAAO,CAACK,WAAD,CAAP,GAAuBA,WAAvB,GAAqC,CAACA,WAAD,CAAnD;AACA,SAAOA,WAAW,CAACP,GAAZ,CAAgB,UAAUQ,CAAV,EAAa;AAAE,WAAOC,MAAM,CAACC,MAAP,CAAc;AAAEC,MAAAA,GAAG,EAAE;AAAP,KAAd,EAA8BH,CAA9B,CAAP;AAA0C,GAAzE,CAAP;AACH,CAHM;AAIP,IAAII,QAAQ,GAAGZ,GAAG,CAAC,UAAUQ,CAAV,EAAa;AAAE,SAAOA,CAAP;AAAW,CAA3B,CAAlB;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAO,IAAIK,OAAO,GAAG,UAAUC,IAAV,EAAgBP,WAAhB,EAA6BQ,YAA7B,EAA2CC,YAA3C,EAAyD;AAC1E,MAAIT,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,IAAAA,WAAW,GAAG,EAAd;AAAmB;;AACjD,MAAIQ,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,IAAAA,YAAY,GAAGH,QAAf;AAA0B;;AACzD,MAAII,YAAY,KAAK,KAAK,CAA1B,EAA6B;AAAEA,IAAAA,YAAY,GAAGF,IAAf;AAAsB;;AACrDP,EAAAA,WAAW,GAAGD,eAAe,CAACC,WAAD,CAA7B;;AACA,MAAI,CAACA,WAAW,CAACU,MAAjB,EAAyB;AACrB,WAAOH,IAAP;AACH;;AACD,MAAII,UAAU,GAAGX,WAAW,CAAC,CAAD,CAA5B;AACA,MAAIY,YAAY,GAAG,EAAnB;AACA,MAAIC,IAAI,GAAGrB,IAAI,CAACgB,YAAY,CAACd,eAAe,CAACiB,UAAU,CAACG,KAAZ,CAAhB,CAAb,EAAkDF,YAAlD,EAAgEL,IAAhE,CAAf;AACA,MAAIQ,MAAM,GAAG,EAAb;AACAb,EAAAA,MAAM,CAACc,IAAP,CAAYH,IAAZ,EAAkBI,OAAlB,CAA0B,UAAUH,KAAV,EAAiB;AACvCZ,IAAAA,MAAM,CAACc,IAAP,CAAYH,IAAI,CAACC,KAAD,CAAhB,EAAyBG,OAAzB,CAAiC,UAAUC,KAAV,EAAiB;AAC9C,UAAIC,KAAK,GAAGN,IAAI,CAACC,KAAD,CAAJ,CAAYI,KAAZ,CAAZ;AACA,UAAIE,eAAe,GAAG,EAAtB;AACA,UAAIC,YAAY,GAAGZ,YAAnB;;AACA,UAAIb,SAAS,CAACe,UAAU,CAACW,UAAZ,CAAb,EAAsC;AAClCD,QAAAA,YAAY,GAAGvB,QAAQ,CAACW,YAAD,EAAe;AAClCK,UAAAA,KAAK,EAAEH,UAAU,CAACG,KADgB;AAElCS,UAAAA,UAAU,EAAE,KAFsB;AAGlCC,UAAAA,QAAQ,EAAE,IAHwB;AAIlCN,UAAAA,KAAK,EAAEC,KAAK,CAACD;AAJqB,SAAf,CAAvB;AAMAE,QAAAA,eAAe,GAAGvB,WAAW,CAACwB,YAAD,EAAeV,UAAU,CAACW,UAA1B,CAA7B;AACH;;AACDP,MAAAA,MAAM,CAACI,KAAK,CAACM,UAAP,CAAN,GAA2B;AACvBH,QAAAA,UAAU,EAAEF,eADW;AAEvBN,QAAAA,KAAK,EAAEA,KAFgB;AAGvBY,QAAAA,KAAK,EAAE1B,WAAW,CAACU,MAAZ,GAAqB,CAArB,GACHJ,OAAO,CAACa,KAAK,CAACO,KAAP,EAAc1B,WAAW,CAAC2B,KAAZ,CAAkB,CAAlB,CAAd,EAAoCtB,QAApC,EAA8CgB,YAA9C,CADJ,GAEDF,KAAK,CAACO,KALW;AAMvBR,QAAAA,KAAK,EAAEC,KAAK,CAACD;AANU,OAA3B;AAQH,KArBD;AAsBH,GAvBD;AAwBA,SAAOH,MAAP;AACH,CArCM","sourcesContent":["import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport var normalizeGroups = function (descriptors) {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(function (x) { return Object.assign({ dir: \"asc\" }, x); });\n};\nvar identity = map(function (x) { return x; });\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts-no-run\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport var groupBy = function (data, descriptors, transformers, originalData) {\n    if (descriptors === void 0) { descriptors = []; }\n    if (transformers === void 0) { transformers = identity; }\n    if (originalData === void 0) { originalData = data; }\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    var descriptor = descriptors[0];\n    var initialValue = {};\n    var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    var result = [];\n    Object.keys(view).forEach(function (field) {\n        Object.keys(view[field]).forEach(function (value) {\n            var group = view[field][value];\n            var aggregateResult = {};\n            var filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}