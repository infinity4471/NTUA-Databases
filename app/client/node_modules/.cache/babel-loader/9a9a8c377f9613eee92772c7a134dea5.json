{"ast":null,"code":"import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\n\nvar valueToString = function (value) {\n  value = isPresent(value) && value.getTime ? value.getTime() : value;\n  return value + \"\";\n};\n/**\n * @hidden\n */\n\n\nexport var groupCombinator = function (field) {\n  var prop = getter(field, true);\n  var position = 0;\n  return function (agg, value) {\n    agg[field] = agg[field] || {};\n    var groupValue = prop(value);\n    var key = valueToString(groupValue);\n    var values = agg[field][key] || {\n      __position: position++,\n      aggregates: {},\n      items: [],\n      value: groupValue\n    };\n    values.items.push(value);\n    agg[field][key] = values;\n    return agg;\n  };\n};\n/**\n * @hidden\n */\n\nexport var expandAggregates = function (result) {\n  if (result === void 0) {\n    result = {};\n  }\n\n  Object.keys(result).forEach(function (field) {\n    var aggregates = result[field];\n    Object.keys(aggregates).forEach(function (aggregate) {\n      aggregates[aggregate] = aggregates[aggregate].result();\n    });\n  });\n  return result;\n};\n\nvar aggregatesFuncs = function (name) {\n  return {\n    average: function () {\n      var value = 0;\n      var count = 0;\n      return {\n        calc: function (curr) {\n          if (isNumeric(curr)) {\n            value += curr;\n            count++;\n          } else {\n            value = curr;\n          }\n        },\n        result: function () {\n          return isNumeric(value) ? value / count : value;\n        }\n      };\n    },\n    count: function () {\n      var state = 0;\n      return {\n        calc: function () {\n          return state++;\n        },\n        result: function () {\n          return state;\n        }\n      };\n    },\n    max: function () {\n      var state = Number.NEGATIVE_INFINITY;\n      return {\n        calc: function (value) {\n          state = isNumeric(state) || isDate(state) ? state : value;\n\n          if (state < value && (isNumeric(value) || isDate(value))) {\n            state = value;\n          }\n        },\n        result: function () {\n          return state;\n        }\n      };\n    },\n    min: function () {\n      var state = Number.POSITIVE_INFINITY;\n      return {\n        calc: function (value) {\n          state = isNumeric(state) || isDate(state) ? state : value;\n\n          if (state > value && (isNumeric(value) || isDate(value))) {\n            state = value;\n          }\n        },\n        result: function () {\n          return state;\n        }\n      };\n    },\n    sum: function () {\n      var state = 0;\n      return {\n        calc: function (value) {\n          return state += value;\n        },\n        result: function () {\n          return state;\n        }\n      };\n    }\n  }[name]();\n};\n/**\n * @hidden\n */\n\n\nexport var aggregatesCombinator = function (descriptors) {\n  var functions = descriptors.map(function (descriptor) {\n    var fieldAccessor = getter(descriptor.field, true);\n    var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n    var aggregateAccessor = getter(aggregateName, true);\n    return function (state, value) {\n      var fieldAggregates = state[descriptor.field] || {};\n      var aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);\n      aggregateFunction.calc(fieldAccessor(value));\n      fieldAggregates[descriptor.aggregate] = aggregateFunction;\n      state[descriptor.field] = fieldAggregates;\n      return state;\n    };\n  });\n  return function (state, value) {\n    return functions.reduce(function (agg, calc) {\n      return calc(agg, value);\n    }, state);\n  };\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\n\nexport var concat = function (arr, value) {\n  arr.push(value);\n  return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\n\nexport var map = function (transform) {\n  return function (reduce) {\n    return function (acc, curr, index) {\n      return reduce(acc, transform(curr, index));\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\n\nexport var filter = function (predicate) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return predicate(curr) ? reduce(acc, curr) : acc;\n    };\n  };\n};\n/**\n * @hidden\n */\n\nexport var isTransformerResult = function (source) {\n  return isPresent(source.__value);\n};\n\nvar reduced = function (x) {\n  if (isTransformerResult(x)) {\n    return x;\n  }\n\n  return {\n    __value: x,\n    reduced: true\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\n\nexport var take = function (count) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return count-- > 0 ? reduce(acc, curr) : reduced(acc);\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\n\nexport var takeWhile = function (predicate) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return predicate(curr) ? reduce(acc, curr) : reduced(acc);\n    };\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\n\nexport var skip = function (count) {\n  return function (reduce) {\n    return function (acc, curr) {\n      return count-- <= 0 ? reduce(acc, curr) : acc;\n    };\n  };\n};\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\n\nexport var exec = function (transform, initialValue, data) {\n  var result = initialValue;\n\n  for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n    result = transform(result, data[idx], idx);\n\n    if (isTransformerResult(result)) {\n      result = result.__value;\n      break;\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-data-query/dist/es/transducers.js"],"names":["isPresent","isNumeric","isDate","getter","valueToString","value","getTime","groupCombinator","field","prop","position","agg","groupValue","key","values","__position","aggregates","items","push","expandAggregates","result","Object","keys","forEach","aggregate","aggregatesFuncs","name","average","count","calc","curr","state","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","sum","aggregatesCombinator","descriptors","functions","map","descriptor","fieldAccessor","aggregateName","toLowerCase","aggregateAccessor","fieldAggregates","aggregateFunction","reduce","concat","arr","transform","acc","index","filter","predicate","isTransformerResult","source","__value","reduced","x","take","takeWhile","skip","exec","initialValue","data","idx","length_1","length"],"mappings":"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","sourcesContent":["import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nvar valueToString = function (value) {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport var groupCombinator = function (field) {\n    var prop = getter(field, true);\n    var position = 0;\n    return function (agg, value) {\n        agg[field] = agg[field] || {};\n        var groupValue = prop(value);\n        var key = valueToString(groupValue);\n        var values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport var expandAggregates = function (result) {\n    if (result === void 0) { result = {}; }\n    Object.keys(result).forEach(function (field) {\n        var aggregates = result[field];\n        Object.keys(aggregates).forEach(function (aggregate) {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nvar aggregatesFuncs = function (name) { return ({\n    average: function () {\n        var value = 0;\n        var count = 0;\n        return {\n            calc: function (curr) {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                }\n                else {\n                    value = curr;\n                }\n            },\n            result: function () { return isNumeric(value) ? value / count : value; }\n        };\n    },\n    count: function () {\n        var state = 0;\n        return {\n            calc: function () { return state++; },\n            result: function () { return state; }\n        };\n    },\n    max: function () {\n        var state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    min: function () {\n        var state = Number.POSITIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    sum: function () {\n        var state = 0;\n        return {\n            calc: function (value) { return state += value; },\n            result: function () { return state; }\n        };\n    }\n}[name]()); };\n/**\n * @hidden\n */\nexport var aggregatesCombinator = function (descriptors) {\n    var functions = descriptors.map(function (descriptor) {\n        var fieldAccessor = getter(descriptor.field, true);\n        var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        var aggregateAccessor = getter(aggregateName, true);\n        return function (state, value) {\n            var fieldAggregates = state[descriptor.field] || {};\n            var aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return function (state, value) { return functions.reduce(function (agg, calc) { return calc(agg, value); }, state); };\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport var concat = function (arr, value) {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport var map = function (transform) { return (function (reduce) { return (function (acc, curr, index) { return reduce(acc, transform(curr, index)); }); }); };\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport var filter = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n */\nexport var isTransformerResult = function (source) {\n    return isPresent(source.__value);\n};\nvar reduced = function (x) {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var take = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- > 0 ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var takeWhile = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport var skip = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- <= 0 ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport var exec = function (transform, initialValue, data) {\n    var result = initialValue;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}