{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-grid-core\n * Generated: 2020-05-14\n * Version: 2.6.3\n * License: https://js.devexpress.com/Licensing\n */\nimport { slice, easeOutCubic } from '@devexpress/dx-core';\nvar GRID_GROUP_TYPE = Symbol('group');\nvar GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + \"_check\");\nvar GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + \"_levelKey\");\nvar GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + \"_collapsedRows\");\n\nvar warnIfRowIdUndefined = function (getRowId) {\n  return function (row) {\n    var result = getRowId(row);\n\n    if (!row[GRID_GROUP_CHECK] && result === undefined) {\n      // tslint:disable-next-line: no-console\n      console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n    }\n\n    return result;\n  };\n};\n\nvar rowIdGetter = function (getRowId, rows) {\n  if (!getRowId) {\n    var map_1 = new Map(rows.map(function (row, rowIndex) {\n      return [row, rowIndex];\n    }));\n    return function (row) {\n      return map_1.get(row);\n    };\n  }\n\n  return warnIfRowIdUndefined(getRowId);\n};\n\nvar defaultGetCellValue = function (row, columnName) {\n  return row[columnName];\n};\n\nvar cellValueGetter = function (getCellValue, columns) {\n  if (getCellValue === void 0) {\n    getCellValue = defaultGetCellValue;\n  }\n\n  var useFastAccessor = true;\n  var map = columns.reduce(function (acc, column) {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n\n    return acc;\n  }, {});\n\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n\n  return function (row, columnName) {\n    return map[columnName] ? map[columnName](row, columnName) : getCellValue(row, columnName);\n  };\n};\n\nvar changeColumnSorting = function (state, _a) {\n  var columnName = _a.columnName,\n      direction = _a.direction,\n      keepOther = _a.keepOther,\n      sortIndex = _a.sortIndex;\n  var sorting = state.sorting;\n  var nextSorting = [];\n\n  if (keepOther === true) {\n    nextSorting = sorting;\n  }\n\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting).filter(function (s) {\n      return keepOther.indexOf(s.columnName) > -1;\n    });\n  }\n\n  var columnSortingIndex = sorting.findIndex(function (s) {\n    return s.columnName === columnName;\n  });\n  var columnSorting = sorting[columnSortingIndex];\n  var newColumnSorting = {\n    columnName: columnName,\n    direction: direction || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc')\n  };\n\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n\n  if (direction !== null) {\n    var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n\n  return {\n    sorting: nextSorting\n  };\n};\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar unique = function (arr) {\n  return __spread(Array.from(new Set(arr)));\n};\n\nvar getColumnSortingDirection = function (sorting, columnName) {\n  var columnSorting = sorting.filter(function (s) {\n    return s.columnName === columnName;\n  })[0];\n  return columnSorting ? columnSorting.direction : null;\n};\n\nvar getPersistentSortedColumns = function (sorting, columnExtensions) {\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n\n  return columnExtensions.reduce(function (acc, _a) {\n    var columnName = _a.columnName,\n        sortingEnabled = _a.sortingEnabled;\n\n    if (sortingEnabled === false) {\n      if (sorting.findIndex(function (sortItem) {\n        return sortItem.columnName === columnName;\n      }) > -1) {\n        acc.push(columnName);\n      }\n    }\n\n    return acc;\n  }, []);\n};\n\nvar calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {\n  if (persistentSortedColumns === void 0) {\n    persistentSortedColumns = [];\n  }\n\n  if (!persistentSortedColumns.length) return keepOther;\n  if (!keepOther) return persistentSortedColumns;\n  return Array.isArray(keepOther) ? unique(__spread(keepOther, persistentSortedColumns)) : unique(__spread(sorting.map(function (item) {\n    return item.columnName;\n  }), persistentSortedColumns));\n};\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n\n/* tslint:disable no-increment-decrement */\n\n\nvar merge = function (array, auxiliary, lo, mid, hi, compare) {\n  var i = lo;\n  var j = mid + 1;\n  var k = lo;\n\n  while (true) {\n    var cmp = compare(array[i], array[j]);\n\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n\n        break;\n      }\n    }\n  }\n};\n\nvar sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {\n  if (hi < lo) return;\n\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\n\nvar sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {\n  if (hi <= lo) return;\n  var mid = Math.floor(lo + (hi - lo) / 2);\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\n\nvar mergeSort = function (array, compare) {\n  if (compare === void 0) {\n    compare = function (a, b) {\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    };\n  }\n\n  var result = slice(array);\n  var auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\n\nvar NODE_CHECK = Symbol('node');\n\nvar rowsToTree = function (rows, getRowLevelKey) {\n  if (!rows.length) return rows;\n  var levels = [{\n    children: []\n  }];\n  rows.forEach(function (row) {\n    var _a;\n\n    var levelKey = getRowLevelKey(row);\n\n    if (levelKey) {\n      var levelIndex = levels.slice(1).findIndex(function (level) {\n        return getRowLevelKey(level.root) === levelKey;\n      }) + 1;\n\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n\n      var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n  return levels[0].children;\n};\n\nvar treeToRows = function (tree, rows) {\n  if (rows === void 0) {\n    rows = [];\n  }\n\n  if (!tree.length) return tree;\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      acc.push(node.root);\n      treeToRows(node.children, rows);\n    } else {\n      acc.push(node);\n    }\n\n    return acc;\n  }, rows);\n};\n\nvar defaultCompare = function (a, b) {\n  if (a === b) return 0;\n\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n\n  if (a === undefined) {\n    return 1;\n  }\n\n  if (b === null || b === undefined) {\n    return -1;\n  }\n\n  return a < b ? -1 : 1;\n};\n\nvar createCompare = function (sorting, getColumnCompare, getComparableValue) {\n  return sorting.reduceRight(function (prevCompare, columnSorting) {\n    var columnName = columnSorting.columnName;\n    var inverse = columnSorting.direction === 'desc';\n    var columnCompare = getColumnCompare && getColumnCompare(columnName) || defaultCompare;\n    return function (aRow, bRow) {\n      var a = getComparableValue(aRow, columnName);\n      var b = getComparableValue(bRow, columnName);\n      var result = columnCompare(a, b);\n\n      if (result !== 0) {\n        return inverse ? -result : result;\n      }\n\n      return prevCompare(aRow, bRow);\n    };\n  }, function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return 0;\n  });\n};\n\nvar sortTree = function (tree, compare) {\n  var sortedTree = tree.map(function (node) {\n    if (node[NODE_CHECK]) {\n      return __assign(__assign({}, node), {\n        children: sortTree(node.children, compare)\n      });\n    }\n\n    return node;\n  });\n  return mergeSort(sortedTree, function (a, b) {\n    return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b);\n  });\n};\n\nvar sortHierarchicalRows = function (rows, compare, getRowLevelKey) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var sortedTree = sortTree(tree, compare);\n  return treeToRows(sortedTree);\n};\n\nvar sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {\n  if (!sorting.length || !rows.length) return rows;\n  var compare;\n\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n\n  compare = createCompare(sorting, getColumnCompare, function (row, columnName) {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n\n      return undefined;\n    }\n\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(rows, compare, getRowLevelKey);\n};\n\nvar changeColumnFilter = function (filters, _a) {\n  var columnName = _a.columnName,\n      config = _a.config;\n  var filterIndex = filters.findIndex(function (f) {\n    return f.columnName === columnName;\n  });\n  var nextState = slice(filters);\n\n  if (config) {\n    var filter = __assign({\n      columnName: columnName\n    }, config);\n\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n\n  return nextState;\n};\n\nvar getColumnFilterConfig = function (filters, columnName) {\n  return filters.length && filters.filter(function (s) {\n    return s.columnName === columnName;\n  })[0] || null;\n};\n\nvar filterExpression = function (filters, expression) {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  var selfFilterExpr = {\n    filters: filters,\n    operator: 'and'\n  };\n\n  if (!expression) {\n    return selfFilterExpr;\n  }\n\n  return {\n    operator: 'and',\n    filters: [expression, selfFilterExpr]\n  };\n};\n\nvar operators = {\n  or: function (predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc || predicate(row);\n      }, false);\n    };\n  },\n  and: function (predicates) {\n    return function (row) {\n      return predicates.reduce(function (acc, predicate) {\n        return acc && predicate(row);\n      }, true);\n    };\n  }\n};\n\nvar toLowerCase = function (value) {\n  return String(value).toLowerCase();\n};\n\nvar operationPredicates = {\n  contains: function (value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) > -1;\n  },\n  notContains: function (value, filter) {\n    return toLowerCase(value).indexOf(toLowerCase(filter.value)) === -1;\n  },\n  startsWith: function (value, filter) {\n    return toLowerCase(value).startsWith(toLowerCase(filter.value));\n  },\n  endsWith: function (value, filter) {\n    return toLowerCase(value).endsWith(toLowerCase(filter.value));\n  },\n  equal: function (value, filter) {\n    return String(value) === String(filter.value);\n  },\n  notEqual: function (value, filter) {\n    return String(value) !== String(filter.value);\n  },\n  greaterThan: function (value, filter) {\n    return value > filter.value;\n  },\n  greaterThanOrEqual: function (value, filter) {\n    return value >= filter.value;\n  },\n  lessThan: function (value, filter) {\n    return value < filter.value;\n  },\n  lessThanOrEqual: function (value, filter) {\n    return value <= filter.value;\n  }\n};\n\nvar defaultFilterPredicate = function (value, filter) {\n  var operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\n\nvar filterTree = function (tree, predicate) {\n  return tree.reduce(function (acc, node) {\n    if (node[NODE_CHECK]) {\n      var filteredChildren = filterTree(node.children, predicate);\n\n      if (filteredChildren.length > 0) {\n        acc.push(__assign(__assign({}, node), {\n          children: filteredChildren\n        }));\n        return acc;\n      }\n\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n\n      return acc;\n    }\n\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n\n    return acc;\n  }, []);\n};\n\nvar filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {\n  var tree = rowsToTree(rows, getRowLevelKey);\n  var collapsedRowsMeta = [];\n  var filteredTree = filterTree(tree, function (row, isNode) {\n    if (isNode) {\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n\n      if (collapsedRows && collapsedRows.length) {\n        var filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n\n      return false;\n    }\n\n    return predicate(row);\n  });\n  return {\n    rows: treeToRows(filteredTree),\n    collapsedRowsMeta: new Map(collapsedRowsMeta)\n  };\n};\n\nvar buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {\n  var getSimplePredicate = function (filter) {\n    var columnName = filter.columnName;\n    var customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    var predicate = customPredicate || defaultFilterPredicate;\n    return function (row) {\n      return predicate(getCellValue(row, columnName), filter, row);\n    };\n  };\n\n  var getOperatorPredicate = function (filterExpression) {\n    var build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n\n  var getPredicate = function (filterExpression) {\n    return getOperatorPredicate(filterExpression) || getSimplePredicate(filterExpression);\n  };\n\n  return getPredicate(initialFilterExpression);\n};\n\nvar filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {\n      rows: rows\n    };\n  }\n\n  var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);\n  return getRowLevelKey ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows) : {\n    rows: rows.filter(predicate)\n  };\n};\n\nvar filteredCollapsedRowsGetter = function (_a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta && collapsedRowsMeta.get(row);\n  };\n};\n\nvar unwrappedFilteredRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\n\nvar GROUP_KEY_SEPARATOR = '|';\n\nvar applyColumnGrouping = function (grouping, _a) {\n  var columnName = _a.columnName,\n      groupIndex = _a.groupIndex;\n  var nextGrouping = grouping;\n  var groupingIndex = nextGrouping.findIndex(function (g) {\n    return g.columnName === columnName;\n  });\n  var targetIndex = groupIndex;\n\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    nextGrouping.splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    nextGrouping.splice(targetIndex, 0, {\n      columnName: columnName\n    });\n  }\n\n  return nextGrouping;\n};\n\nvar changeColumnGrouping = function (_a, _b) {\n  var grouping = _a.grouping,\n      expandedGroups = _a.expandedGroups;\n  var columnName = _b.columnName,\n      groupIndex = _b.groupIndex;\n  var nextGrouping = applyColumnGrouping(grouping, {\n    columnName: columnName,\n    groupIndex: groupIndex\n  });\n  var ungroupedColumnIndex = grouping.findIndex(function (group, index) {\n    return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName;\n  });\n\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n\n  var filteredExpandedGroups = expandedGroups.filter(function (group) {\n    return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex;\n  });\n\n  if (filteredExpandedGroups.length === expandedGroups.length) {\n    return {\n      grouping: nextGrouping\n    };\n  }\n\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups\n  };\n};\n\nvar toggleExpandedGroups = function (state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups: expandedGroups\n  };\n};\n\nvar draftColumnGrouping = function (_a, _b) {\n  var grouping = _a.grouping,\n      draftGrouping = _a.draftGrouping;\n  var columnName = _b.columnName,\n      groupIndex = _b.groupIndex;\n  return {\n    draftGrouping: applyColumnGrouping(draftGrouping || grouping, {\n      columnName: columnName,\n      groupIndex: groupIndex\n    })\n  };\n};\n\nvar cancelColumnGroupingDraft = function () {\n  return {\n    draftGrouping: null\n  };\n};\n\nvar adjustSortIndex = function (groupingIndex, grouping, sorting) {\n  return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {\n    var columnSortingIndex = sorting.findIndex(function (columnSorting) {\n      return columnSorting.columnName === columnGrouping.columnName;\n    });\n    return columnSortingIndex === -1 ? acc - 1 : acc;\n  }, groupingIndex), 0);\n};\n\nvar groupRowChecker = function (row) {\n  return row[GRID_GROUP_CHECK];\n};\n\nvar groupRowLevelKeyGetter = function (row) {\n  return row ? row[GRID_GROUP_LEVEL_KEY] : undefined;\n};\n\nvar defaultColumnCriteria = function (value) {\n  return {\n    value: value,\n    key: String(value)\n  };\n};\n\nvar groupedRows = function (rows, grouping, getCellValue, getColumnCriteria, keyPrefix) {\n  if (keyPrefix === void 0) {\n    keyPrefix = '';\n  }\n\n  if (!grouping.length) return rows;\n  var columnName = grouping[0].columnName;\n  var groupCriteria = getColumnCriteria && getColumnCriteria(columnName) || defaultColumnCriteria;\n  var groups = new Map();\n  rows.forEach(function (row) {\n    var rawValue = getCellValue(row, columnName);\n\n    var _a = groupCriteria(rawValue, row),\n        key = _a.key,\n        value = _a.value;\n\n    var sameKeyItems = groups.get(key);\n\n    if (!sameKeyItems) {\n      var groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n  var groupedBy = grouping[0].columnName;\n  var nestedGrouping = grouping.slice(1);\n  return __spread(groups.values()).reduce(function (acc, _a) {\n    var _b;\n\n    var _c = __read(_a, 3),\n        value = _c[0],\n        key = _c[1],\n        items = _c[2];\n\n    var compoundKey = \"\" + keyPrefix + key;\n    acc.push((_b = {\n      groupedBy: groupedBy,\n      compoundKey: compoundKey,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b));\n    acc.push.apply(acc, __spread(groupedRows(items, nestedGrouping, getCellValue, getColumnCriteria, \"\" + compoundKey + GROUP_KEY_SEPARATOR)));\n    return acc;\n  }, []);\n};\n\nvar expandedGroupRows = function (rows, grouping, expandedGroups, isExporting) {\n  if (!grouping.length) return rows;\n  var groupingColumnNames = grouping.map(function (columnGrouping) {\n    return columnGrouping.columnName;\n  });\n  var expandedGroupsSet = new Set(expandedGroups);\n  var currentGroupExpanded = true;\n  var currentGroupLevel = 0;\n  return rows.reduce(function (acc, row) {\n    var _a;\n\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n\n      return acc;\n    }\n\n    var groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));\n    }\n\n    return acc;\n  }, []);\n};\n\nvar groupCollapsedRowsGetter = function (getCollapsedRows) {\n  return function (row) {\n    return row[GRID_GROUP_COLLAPSED_ROWS] || getCollapsedRows && getCollapsedRows(row);\n  };\n};\n\nvar customGroupedRows = function (currentRows, grouping, getChildGroups, rootRows, keyPrefix) {\n  if (rootRows === void 0) {\n    rootRows = currentRows;\n  }\n\n  if (keyPrefix === void 0) {\n    keyPrefix = '';\n  }\n\n  if (!currentRows || !currentRows.length) return [];\n  if (!grouping.length) return currentRows;\n  var groupedBy = grouping[0].columnName;\n  var nestedGrouping = grouping.slice(1);\n  return getChildGroups(currentRows, grouping[0], rootRows).reduce(function (acc, _a) {\n    var _b;\n\n    var key = _a.key,\n        _c = _a.value,\n        value = _c === void 0 ? key : _c,\n        childRows = _a.childRows;\n    var compoundKey = \"\" + keyPrefix + key;\n    acc.push((_b = {\n      groupedBy: groupedBy,\n      compoundKey: compoundKey,\n      key: key,\n      value: value\n    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + \"_\" + groupedBy, _b));\n    acc.push.apply(acc, __spread(customGroupedRows(childRows, nestedGrouping, getChildGroups, rootRows, \"\" + compoundKey + GROUP_KEY_SEPARATOR)));\n    return acc;\n  }, []);\n};\n\nvar customGroupingRowIdGetter = function (getRowId, rows) {\n  var firstRow = rows.find(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  });\n\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n\n  var map = new Map(rows.filter(function (row) {\n    return !row[GRID_GROUP_CHECK];\n  }).map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\n\nvar groupingPanelItems = function (columns, grouping, draftGrouping) {\n  var items = draftGrouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: !grouping.some(function (columnGrouping) {\n        return columnGrouping.columnName === columnName;\n      })\n    };\n  });\n  grouping.forEach(function (_a, index) {\n    var columnName = _a.columnName;\n    if (draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    })) return;\n    items.splice(index, 0, {\n      column: columns.find(function (c) {\n        return c.name === columnName;\n      }),\n      draft: true\n    });\n  });\n  return items;\n};\n\nvar setCurrentPage = function (prevPage, page) {\n  return page;\n};\n\nvar setPageSize = function (prevPageSize, size) {\n  return size;\n};\n\nvar clamp = function (value, max) {\n  return Math.max(Math.min(value, max), 0);\n}; // tslint:disable-next-line:max-line-length\n\n\nvar PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\n\nvar paginatedRows = function (rows, pageSize, page) {\n  return pageSize ? rows.slice(pageSize * page, pageSize * (page + 1)) : rows;\n};\n\nvar rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {\n  if (!pageSize || !getRowLevelKey) return rows;\n  var result = rows.slice();\n  var headerRows = [];\n  var currentIndex = 0;\n\n  var _loop_1 = function () {\n    var row = result[currentIndex];\n    var levelKey = getRowLevelKey(row);\n\n    if (levelKey) {\n      var headerIndex = headerRows.findIndex(function (headerRow) {\n        return getRowLevelKey(headerRow) === levelKey;\n      }); // tslint:disable-next-line:prefer-conditional-expression\n\n      if (headerIndex === -1) {\n        headerRows = __spread(headerRows, [row]);\n      } else {\n        headerRows = __spread(headerRows.slice(0, headerIndex), [row]);\n      }\n\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n\n    var indexInPage = currentIndex % pageSize;\n\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = __spread(result.slice(0, currentIndex), [headerRows[indexInPage]], result.slice(currentIndex));\n    }\n\n    currentIndex += 1;\n  };\n\n  while (result.length > currentIndex) {\n    _loop_1();\n  }\n\n  return result;\n};\n\nvar rowCount = function (rows) {\n  return rows.length;\n};\n\nvar pageCount = function (count, pageSize) {\n  return pageSize ? Math.ceil(count / pageSize) : 1;\n};\n\nvar currentPage = function (page, totalCount, pageSize, setCurrentPage) {\n  var totalPages = pageCount(totalCount, pageSize);\n  var adjustedCurrentPage = clamp(page, totalPages - 1);\n\n  if (page !== adjustedCurrentPage) {\n    setTimeout(function () {\n      return setCurrentPage(adjustedCurrentPage);\n    });\n  }\n\n  return adjustedCurrentPage;\n};\n\nvar firstRowOnPage = function (currentPage, pageSize, totalCount) {\n  if (totalCount === 0) {\n    return 0;\n  }\n\n  return pageSize ? currentPage * pageSize + 1 : 1;\n};\n\nvar lastRowOnPage = function (currentPage, pageSize, totalRowCount) {\n  var result = totalRowCount;\n\n  if (pageSize) {\n    var index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n\n  return result;\n};\n\nvar calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) {\n  return Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), totalPageCount - maxButtonCount + 1), 1);\n};\n\nvar toggle = function (source, items, state) {\n  var itemsSet = new Set(items);\n  var sourceState = state;\n\n  if (sourceState === undefined) {\n    var availableSelection = source.filter(function (item) {\n      return itemsSet.has(item);\n    });\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n\n  if (sourceState) {\n    var sourceSet_1 = new Set(source);\n    return __spread(source, items.filter(function (item) {\n      return !sourceSet_1.has(item);\n    }));\n  }\n\n  return source.filter(function (item) {\n    return !itemsSet.has(item);\n  });\n};\n\nvar toggleSelection = function (selection, _a) {\n  var rowIds = _a.rowIds,\n      state = _a.state;\n  return toggle(selection, rowIds, state);\n};\n\nvar rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {\n  var dataRows = rows;\n\n  if (isGroupRow) {\n    dataRows = dataRows.filter(function (row) {\n      return !isGroupRow(row);\n    });\n  }\n\n  return {\n    rows: rows,\n    availableToSelect: dataRows.map(function (row) {\n      return getRowId(row);\n    })\n  };\n};\n\nvar someSelected = function (_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return availableToSelect.length !== 0 && selectionSet.size !== 0 && availableToSelect.some(function (elem) {\n    return selectionSet.has(elem);\n  }) && availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\n\nvar allSelected = function (_a, selection) {\n  var availableToSelect = _a.availableToSelect;\n  var selectionSet = new Set(selection);\n  return selectionSet.size !== 0 && availableToSelect.length !== 0 && !availableToSelect.some(function (elem) {\n    return !selectionSet.has(elem);\n  });\n};\n\nvar unwrapSelectedRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\n\nvar startEditRows = function (prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(prevEditingRowIds, rowIds);\n};\n\nvar stopEditRows = function (prevEditingRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(function (id) {\n    return !rowIdSet.has(id);\n  });\n};\n\nvar startEditCells = function (prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return __spread(prevEditingCells, editingCells);\n};\n\nvar stopEditCells = function (prevEditingCells, _a) {\n  var editingCells = _a.editingCells;\n  return prevEditingCells.filter(function (_a) {\n    var rowId = _a.rowId,\n        columnName = _a.columnName;\n    return !editingCells.some(function (_a) {\n      var currentRowId = _a.rowId,\n          currentColumnName = _a.columnName;\n      return currentRowId === rowId && currentColumnName === columnName;\n    });\n  });\n};\n\nvar addRow = function (addedRows, _a) {\n  var row = (_a === void 0 ? {\n    row: {}\n  } : _a).row;\n  return __spread(addedRows, [row]);\n};\n\nvar changeAddedRow = function (addedRows, _a) {\n  var rowId = _a.rowId,\n      change = _a.change;\n  var result = addedRows.slice();\n  result[rowId] = __assign(__assign({}, result[rowId]), change);\n  return result;\n};\n\nvar cancelAddedRows = function (addedRows, _a) {\n  var rowIds = _a.rowIds;\n  var result = [];\n  var indexSet = new Set(rowIds);\n  addedRows.forEach(function (row, index) {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nvar changeRow = function (prevRowChanges, _a) {\n  var _b;\n\n  var rowId = _a.rowId,\n      change = _a.change;\n  var prevChange = prevRowChanges[rowId] || {};\n  return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));\n};\n\nvar cancelChanges = function (prevRowChanges, _a) {\n  var rowIds = _a.rowIds;\n\n  var result = __assign({}, prevRowChanges);\n\n  rowIds.forEach(function (rowId) {\n    delete result[rowId];\n  });\n  return result;\n};\n\nvar deleteRows = function (deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  return __spread(deletedRowIds, rowIds);\n};\n\nvar cancelDeletedRows = function (deletedRowIds, _a) {\n  var rowIds = _a.rowIds;\n  var rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(function (rowId) {\n    return !rowIdSet.has(rowId);\n  });\n};\n\nvar changedRowsByIds = function (changes, rowIds) {\n  var result = {};\n  rowIds.forEach(function (rowId) {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\n\nvar addedRowsByIds = function (addedRows, rowIds) {\n  var rowIdSet = new Set(rowIds);\n  var result = [];\n  addedRows.forEach(function (row, index) {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nvar defaultCreateRowChange = function (row, value, columnName) {\n  var _a;\n\n  return _a = {}, _a[columnName] = value, _a;\n};\n\nvar createRowChangeGetter = function (createRowChange, columnExtensions) {\n  if (createRowChange === void 0) {\n    createRowChange = defaultCreateRowChange;\n  }\n\n  if (columnExtensions === void 0) {\n    columnExtensions = [];\n  }\n\n  var map = columnExtensions.reduce(function (acc, columnExtension) {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n\n    return acc;\n  }, {});\n  return function (row, value, columnName) {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n\n    return createRowChange(row, value, columnName);\n  };\n};\n\nvar getRowChange = function (rowChanges, rowId) {\n  return rowChanges[rowId] || {};\n};\n\nvar TABLE_REORDERING_TYPE = Symbol('reordering');\n\nvar changeColumnOrder = function (order, _a) {\n  var sourceColumnName = _a.sourceColumnName,\n      targetColumnName = _a.targetColumnName;\n  var sourceColumnIndex = order.indexOf(sourceColumnName);\n  var targetColumnIndex = order.indexOf(targetColumnName);\n  var newOrder = slice(order);\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\n\nvar TABLE_DATA_TYPE = Symbol('data');\nvar TABLE_NODATA_TYPE = Symbol('nodata');\nvar TABLE_FLEX_TYPE = Symbol('flex');\n\nvar orderedColumns = function (tableColumns, order) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n\n  return mergeSort(tableColumns, function (a, b) {\n    if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n    var aPos = order.indexOf(a.column.name);\n    var bPos = order.indexOf(b.column.name);\n    return aPos - bPos;\n  });\n};\n\nvar tableHeaderRowsWithReordering = function (tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0\n  }]);\n};\n\nvar draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {\n  if (sourceColumnIndex === -1 || targetColumnIndex === -1 || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n\n  var result = slice(order);\n  var sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n  return result;\n};\n\nvar getColumnWidth = function (columnWidths, name, _a) {\n  var columnName = _a.columnName,\n      cachedWidths = _a.cachedWidths,\n      shift = _a.shift,\n      minColumnWidth = _a.minColumnWidth,\n      maxColumnWidth = _a.maxColumnWidth,\n      _b = _a.columnExtensions,\n      columnExtensions = _b === void 0 ? [] : _b;\n  var change = name === columnName ? shift : -shift;\n  var column = columnWidths.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var extension = columnExtensions.find(function (elem) {\n    return elem.columnName === name;\n  });\n  var width = typeof column.width === 'number' ? column.width : cachedWidths[name];\n  var minWidth = extension && extension.minWidth >= 0 ? extension.minWidth : minColumnWidth;\n  var maxWidth = extension && extension.maxWidth >= 0 ? extension.maxWidth : maxColumnWidth;\n  var size = Math.max(minWidth, Math.min(width + change, maxWidth));\n  return {\n    width: width,\n    size: size\n  };\n};\n\nvar getColumnSizes = function (columnWidths, payload) {\n  var columnName = payload.columnName,\n      nextColumnName = payload.nextColumnName,\n      resizingMode = payload.resizingMode,\n      shift = payload.shift;\n\n  var _a = getColumnWidth(columnWidths, columnName, payload),\n      width = _a.width,\n      size = _a.size;\n\n  if (resizingMode === 'nextColumn') {\n    var _b = getColumnWidth(columnWidths, nextColumnName, payload),\n        nextWidth = _b.width,\n        nextSize = _b.size;\n\n    if (size + nextSize !== width + nextWidth) {\n      var moreThanLimit = size + nextSize > width + nextWidth;\n      var columnExpand = shift > 0;\n\n      if (moreThanLimit !== columnExpand) {\n        return {\n          size: size,\n          nextSize: width + nextWidth - size\n        };\n      }\n\n      return {\n        size: width + nextWidth - nextSize,\n        nextSize: nextSize\n      };\n    }\n\n    return {\n      size: size,\n      nextSize: nextSize\n    };\n  }\n\n  return {\n    size: size\n  };\n};\n\nvar isValidValue = function (value, validUnits) {\n  var numb = parseInt(value, 10);\n  var unit = numb ? value.substr(numb.toString().length) : value;\n  var sizeIsAuto = isNaN(numb) && unit === 'auto';\n  var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) {\n    return validUnit === unit;\n  });\n  return sizeIsAuto || sizeIsValid;\n};\n\nvar convertWidth = function (value) {\n  if (typeof value === 'string') {\n    var numb = parseInt(value, 10);\n\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n\n    return numb;\n  }\n\n  return value;\n};\n\nvar VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\n\nvar COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\n\nvar specifyWidths = function (tableColumns, widths, resizingMode, onError) {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n\n  if (!widths.length) return tableColumns;\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type === TABLE_DATA_TYPE) {\n      var columnName_1 = tableColumn.column.name;\n      var column = widths.find(function (el) {\n        return el.columnName === columnName_1;\n      });\n      var width = column && column.width;\n\n      if (typeof width !== 'number') {\n        if (width === undefined) {\n          onError();\n        } else if (!isValidValue(width, VALID_UNITS)) {\n          onError();\n        } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n          onError();\n        }\n      } else if (width < 0) {\n        onError();\n      }\n\n      if (width === undefined) {\n        acc.push(tableColumn);\n      } else {\n        acc.push(__assign(__assign({}, tableColumn), {\n          width: convertWidth(width)\n        }));\n      }\n    } else {\n      acc.push(tableColumn);\n    }\n\n    return acc;\n  }, []);\n};\n\nvar tableColumnsWithWidths = function (tableColumns, columnWidths, resizingMode) {\n  return specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n};\n\nvar tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths, resizingMode) {\n  return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () {});\n};\n\nvar throwError = function () {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\n\nvar changeTableColumnWidth = function (state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n      nextColumnName = payload.nextColumnName,\n      resizingMode = payload.resizingMode;\n  var nextColumnWidth = slice(columnWidths);\n  var index = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === columnName;\n  });\n  var nextIndex = nextColumnWidth.findIndex(function (elem) {\n    return elem.columnName === nextColumnName;\n  });\n\n  var _a = getColumnSizes(columnWidths, payload),\n      size = _a.size,\n      nextSize = _a.nextSize;\n\n  nextColumnWidth.splice(index, 1, {\n    columnName: columnName,\n    width: size\n  });\n\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, {\n      columnName: nextColumnName,\n      width: nextSize\n    });\n  }\n\n  return {\n    columnWidths: nextColumnWidth\n  };\n};\n\nvar draftTableColumnWidth = function (state, payload) {\n  var columnWidths = state.columnWidths;\n  var columnName = payload.columnName,\n      nextColumnName = payload.nextColumnName,\n      resizingMode = payload.resizingMode;\n\n  var _a = getColumnSizes(columnWidths, payload),\n      size = _a.size,\n      nextSize = _a.nextSize;\n\n  if (resizingMode === 'nextColumn') {\n    return {\n      draftColumnWidths: [{\n        columnName: columnName,\n        width: size\n      }, {\n        columnName: nextColumnName,\n        width: nextSize\n      }]\n    };\n  }\n\n  return {\n    draftColumnWidths: [{\n      columnName: columnName,\n      width: size\n    }]\n  };\n};\n\nvar cancelTableColumnWidthDraft = function () {\n  return {\n    draftColumnWidths: []\n  };\n};\n\nvar TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\nvar TABLE_ADDED_TYPE = Symbol('added');\nvar TABLE_EDIT_TYPE = Symbol('edit');\nvar TABLE_HEADING_TYPE = Symbol('heading');\n\nvar isHeadingEditCommandsTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\n\nvar isEditCommandsTableCell = function (tableRow, tableColumn) {\n  return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n};\n\nvar tableColumnsWithEditing = function (tableColumns, width) {\n  return __spread([{\n    width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(),\n    type: TABLE_EDIT_COMMAND_TYPE\n  }], tableColumns);\n};\n\nvar isEditTableCell = function (tableRow, tableColumn) {\n  return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isAddedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_ADDED_TYPE;\n};\n\nvar isEditTableRow = function (tableRow) {\n  return tableRow.type === TABLE_EDIT_TYPE;\n};\n\nvar tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {\n  var rowIds = new Set(editingRowIds);\n  var editedTableRows = tableRows.map(function (tableRow) {\n    return tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId) ? __assign(__assign({}, tableRow), {\n      type: TABLE_EDIT_TYPE,\n      height: rowHeight\n    }) : tableRow;\n  });\n  var addedTableRows = addedRows.map(function (row, rowIndex) {\n    return {\n      row: row,\n      key: TABLE_ADDED_TYPE.toString() + \"_\" + rowIndex,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight\n    };\n  });\n  return __spread(slice(addedTableRows).reverse(), editedTableRows);\n};\n\nvar rowsWithEditingCells = function (tableBodyRows, editingCells) {\n  return tableBodyRows.map(function (row) {\n    var rowId = row.rowId;\n\n    if (rowId !== undefined && editingCells.some(function (elem) {\n      return elem.rowId === rowId;\n    })) {\n      return __assign(__assign({}, row), {\n        hasEditCell: true\n      });\n    }\n\n    return row;\n  });\n};\n\nvar columnsWithEditingCells = function (tableColumns, editingCells) {\n  return tableColumns.map(function (tableColumn) {\n    var columnName = tableColumn.column ? tableColumn.column.name : undefined;\n\n    if (columnName !== undefined && editingCells.some(function (elem) {\n      return elem.columnName === columnName;\n    })) {\n      return __assign(__assign({}, tableColumn), {\n        hasEditCell: true\n      });\n    }\n\n    return tableColumn;\n  });\n};\n\nvar TABLE_FILTER_TYPE = Symbol('filter');\nvar DEFAULT_FILTER_OPERATIONS = ['contains', 'notContains', 'startsWith', 'endsWith', 'equal', 'notEqual'];\n\nvar isFilterTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isFilterTableRow = function (tableRow) {\n  return tableRow.type === TABLE_FILTER_TYPE;\n};\n\nvar getColumnFilterOperations = function (getAvailableFilterOperations, columnName) {\n  return getAvailableFilterOperations && getAvailableFilterOperations(columnName) || DEFAULT_FILTER_OPERATIONS;\n};\n\nvar isFilterValueEmpty = function (value) {\n  return value === undefined || !String(value).length;\n};\n\nvar getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n\n  return columnFilterOperations[0];\n};\n\nvar tableHeaderRowsWithFilter = function (headerRows, rowHeight) {\n  return __spread(headerRows, [{\n    key: TABLE_FILTER_TYPE.toString(),\n    type: TABLE_FILTER_TYPE,\n    height: rowHeight\n  }]);\n};\n\nvar TABLE_GROUP_TYPE = Symbol('group');\n\nvar tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n\n    var columnName = tableColumn.column && tableColumn.column.name || '';\n    var columnGroupingExists = grouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n    var columnDraftGroupingExists = draftGrouping.some(function (columnGrouping) {\n      return columnGrouping.columnName === columnName;\n    });\n\n    if (!columnGroupingExists && !columnDraftGroupingExists || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if (!columnGroupingExists && columnDraftGroupingExists || columnGroupingExists && !columnDraftGroupingExists) {\n      acc.push(__assign(__assign({}, tableColumn), {\n        draft: true\n      }));\n    }\n\n    return acc; // tslint:disable-next-line: prefer-array-literal\n  }, []);\n};\n\nvar tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) {\n  return __spread(grouping.map(function (columnGrouping) {\n    var groupedColumn = columns.find(function (column) {\n      return column.name === columnGrouping.columnName;\n    });\n    return {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + groupedColumn.name,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth\n    };\n  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped));\n};\n\nvar tableRowsWithGrouping = function (tableRows, isGroupRow) {\n  return tableRows.map(function (tableRow) {\n    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n      return tableRow;\n    }\n\n    return __assign(__assign({}, tableRow), {\n      key: TABLE_GROUP_TYPE.toString() + \"_\" + tableRow.row.compoundKey,\n      type: TABLE_GROUP_TYPE\n    });\n  });\n};\n\nvar isRowLevelSummary = function (groupSummaryItems, colName) {\n  return groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === colName;\n  });\n};\n\nvar groupSummaryChains = function (tableRow, tableColumns, groupSummaryItems) {\n  var captionStarted = false;\n  return tableColumns.reduce(function (acc, col) {\n    var colName = col.column && col.column.name;\n    var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy === colName;\n    var isIndentColumn = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy !== colName && !captionStarted;\n\n    if (isStartOfGroupCaption) {\n      captionStarted = true;\n    }\n\n    if (isStartOfGroupCaption || isIndentColumn) {\n      acc.push([colName]);\n    } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n      acc.push([colName]);\n      acc.push([]);\n    } else {\n      acc[acc.length - 1].push(colName);\n    }\n\n    return acc;\n  }, [[]]);\n};\n\nvar tableGroupCellColSpanGetter = function (getTableCellColSpan, groupSummaryItems) {\n  return function (params) {\n    var tableRow = params.tableRow,\n        tableColumns = params.tableColumns,\n        tableColumn = params.tableColumn;\n\n    if (tableRow.type === TABLE_GROUP_TYPE) {\n      var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems);\n      var chain = chains.find(function (ch) {\n        return ch[0] === (tableColumn.column && tableColumn.column.name);\n      });\n\n      if (chain) {\n        return chain.length;\n      }\n    }\n\n    return getTableCellColSpan(params);\n  };\n};\n\nvar isHeadingTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isHeadingTableRow = function (tableRow) {\n  return tableRow.type === TABLE_HEADING_TYPE;\n};\n\nvar findChainByColumnIndex = function (chains, columnIndex) {\n  return chains.find(function (chain) {\n    return chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length;\n  });\n};\n\nvar splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) {\n  return tableColumnChains.map(function (row, rowIndex) {\n    return row.reduce(function (acc, chain) {\n      var currentChain = null;\n      chain.columns.forEach(function (col) {\n        var column = tableColumns.find(function (c) {\n          return c.key === col.key;\n        });\n        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);\n\n        if (isNewGroup) {\n          var start = currentChain ? currentChain.start + currentChain.columns.length : chain.start;\n          acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), {\n            start: start,\n            columns: []\n          }));\n          currentChain = acc[acc.length - 1];\n        }\n\n        currentChain.columns.push(column);\n      });\n      return acc;\n    }, []);\n  });\n};\n\nvar generateSimpleChains = function (rows, columns) {\n  return rows.map(function () {\n    return [{\n      columns: columns,\n      start: 0\n    }];\n  });\n};\n\nvar nextColumnName = function (tableColumns, index) {\n  var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName ? tableColumns[index + 1].column.name : undefined;\n};\n\nvar getNextColumnName = function (tableColumns, columnName) {\n  var index = tableColumns.findIndex(function (elem) {\n    return elem.column && elem.column.name === columnName;\n  });\n  return index >= 0 ? nextColumnName(tableColumns, index) : undefined;\n};\n\nvar tableRowsWithHeading = function (headerRows) {\n  return __spread([{\n    key: TABLE_HEADING_TYPE.toString(),\n    type: TABLE_HEADING_TYPE\n  }], headerRows);\n};\n\nvar TABLE_BAND_TYPE = Symbol('band');\nvar BAND_GROUP_CELL = 'bandGroupCell';\nvar BAND_HEADER_CELL = 'bandHeaderCell';\nvar BAND_EMPTY_CELL = 'bandEmptyCell';\nvar BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nvar BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\n\nvar isBandedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_BAND_TYPE;\n};\n\nvar isBandedOrHeaderRow = function (tableRow) {\n  return isBandedTableRow(tableRow) || tableRow.type === TABLE_HEADING_TYPE;\n};\n\nvar isNoDataColumn = function (columnType) {\n  return columnType !== TABLE_DATA_TYPE;\n};\n\nvar getColumnMeta = function (columnName, bands, tableRowLevel, key, level, title, result) {\n  if (key === void 0) {\n    key = '';\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  if (title === void 0) {\n    title = null;\n  }\n\n  if (result === void 0) {\n    result = null;\n  }\n\n  return bands.reduce(function (acc, band) {\n    if (band.columnName === columnName) {\n      return __assign(__assign({}, acc), {\n        title: title,\n        level: level,\n        key: key\n      });\n    }\n\n    if (band.children !== undefined) {\n      var rowLevelPassed = level > tableRowLevel;\n      var bandTitle = rowLevelPassed ? title : band.title;\n      var bandKey = rowLevelPassed ? key : key + \"_\" + bandTitle;\n      return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);\n    }\n\n    return acc;\n  }, result || {\n    level: level,\n    title: title,\n    key: title\n  });\n}; // TODO: refactor\n\n\nvar getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {\n  var currentTableColumn = _a.tableColumn,\n      tableRow = _a.tableRow,\n      rowSpan = _a.rowSpan;\n  if (rowSpan) return {\n    type: BAND_DUPLICATE_RENDER,\n    payload: null\n  };\n  var maxLevel = tableHeaderRows.filter(function (column) {\n    return column.type === TABLE_BAND_TYPE;\n  }).length + 1;\n  var level = tableRow.level;\n  var currentRowLevel = level === undefined ? maxLevel - 1 : level;\n  var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel) : {\n    level: 0,\n    title: ''\n  };\n  var currentColumnIndex = tableColumns.findIndex(function (column) {\n    return column.key === currentTableColumn.key;\n  });\n  var levelsCount = bandLevelsVisibility.length;\n  var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n\n  if (currentColumnMeta.level < currentRowLevel) {\n    var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n\n    if (shouldFillLevel) {\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: null\n      };\n    }\n\n    return {\n      type: BAND_EMPTY_CELL,\n      payload: null\n    };\n  }\n\n  var previousTableColumn = tableColumns[currentColumnIndex - 1];\n  var beforeBorder = false;\n\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (currentTableColumn.type === TABLE_STUB_TYPE) {\n      var cellRowSpan = visibleLevelsCount < levelsCount ? visibleLevelsCount || 1 : maxLevel;\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan\n        }\n      };\n    }\n\n    return {\n      type: BAND_HEADER_CELL,\n      payload: __assign({\n        tableRow: tableHeaderRows.find(function (row) {\n          return row.type === TABLE_HEADING_TYPE;\n        }),\n        rowSpan: maxLevel - currentRowLevel\n      }, beforeBorder && {\n        beforeBorder: beforeBorder\n      })\n    };\n  }\n\n  var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);\n  var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {\n    var _b = __read(_a, 2),\n        start = _b[0],\n        end = _b[1];\n\n    return start <= currentColumnIndex && currentColumnIndex <= end;\n  });\n  var bandStart = Math.max(columnVisibleBoundary[0], currentColumnChain.start);\n\n  if (bandStart < currentColumnIndex) {\n    return {\n      type: null,\n      payload: null\n    };\n  }\n\n  var bandEnd = Math.min(columnVisibleBoundary[1] + 1, currentColumnChain.start + currentColumnChain.columns.length);\n  return {\n    type: BAND_GROUP_CELL,\n    payload: __assign({\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title,\n      column: currentColumnMeta\n    }, beforeBorder && {\n      beforeBorder: beforeBorder\n    })\n  };\n};\n\nvar emptyVirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: []\n};\n\nvar pluckSubarray = function (source, sourceStart, left, right) {\n  return source.slice(left - sourceStart, right - sourceStart);\n};\n\nvar mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {\n  var breakpoints = [rowsInterval.start, rowsInterval.end, cacheInterval.start, cacheInterval.end].filter(function (i) {\n    return 0 <= i && i < Number.POSITIVE_INFINITY;\n  }).sort(function (a, b) {\n    return a - b;\n  });\n  var result = [];\n\n  if (breakpoints.length > 1) {\n    for (var i = 0; i < breakpoints.length - 1; i += 1) {\n      var left = breakpoints[i];\n      var right = breakpoints[i + 1];\n      var chunk = rowsInterval.start <= left && right <= rowsInterval.end ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n      : pluckSubarray(cacheRows, cacheStart, left, right);\n      result = result.concat(chunk);\n    }\n  }\n\n  return {\n    skip: breakpoints[0],\n    rows: result\n  };\n};\n\nvar correctRequestedRange = function (calculatedRange, referenceIndex, pageSize) {\n  var start = calculatedRange.start,\n      end = calculatedRange.end;\n\n  if (start - referenceIndex > pageSize / 2) {\n    return {\n      start: start - pageSize,\n      end: end - pageSize\n    };\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n};\n\nvar calculateRequestedRange = function (virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {\n  var loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n\n  if (isAdjacentPage) {\n    var calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n\n    return calculatedRange;\n  } // load 3 pages at once because a missing page will be loaded anyway\n\n\n  return newRange;\n};\n\nvar rowToPageIndex = function (rowIndex, pageSize) {\n  return Math.floor(rowIndex / pageSize);\n};\n\nvar recalculateBounds = function (middleIndex, pageSize, totalCount) {\n  var currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n  var prevPageIndex = currentPageIndex - 1;\n  var nextPageIndex = currentPageIndex + 2;\n  var start = Math.max(0, prevPageIndex * pageSize);\n  var end = Math.min(nextPageIndex * pageSize, totalCount);\n  return {\n    start: start,\n    end: end\n  };\n};\n\nvar trimRowsToInterval = function (virtualRows, targetInterval) {\n  var rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  var intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n\n  var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);\n  return {\n    rows: rows,\n    skip: intersection.start\n  };\n};\n\nvar getAvailableRowCount = function (isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {\n  return isInfiniteScroll ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount) : totalRowCount;\n};\n\nvar getForceReloadInterval = function (virtualRows, pageSize, totalRowCount) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n      start = _a.start,\n      intervalEnd = _a.end;\n\n  var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));\n  return {\n    start: start,\n    end: end\n  };\n};\n\nvar getRequestMeta = function (referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {\n  var actualBounds = forceReload ? getForceReloadInterval(virtualRows, pageSize, totalRowCount) : recalculateBounds(referenceIndex, pageSize, totalRowCount);\n  var requestedRange = forceReload ? actualBounds : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);\n  return {\n    requestedRange: requestedRange,\n    actualBounds: actualBounds\n  };\n};\n\nvar needFetchMorePages = function (virtualRows, referenceIndex, pageSize) {\n  var _a = intervalUtil.getRowsInterval(virtualRows),\n      start = _a.start,\n      end = _a.end;\n\n  var loadCount = end - start;\n  var topTriggerIndex = start > 0 ? start + pageSize : 0;\n  var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);\n\n  if (loadCount <= 0) {\n    return false;\n  }\n\n  return referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex;\n};\n\nvar getReferenceIndex = function (_a) {\n  var _b = __read(_a.rows, 2),\n      top = _b[0],\n      bottom = _b[1];\n\n  return (top + bottom) / 2;\n};\n\nvar shouldSendRequest = function (_a, requestedPageIndex) {\n  var start = _a.start,\n      end = _a.end;\n  var newPageIndex = start;\n  var loadCount = end - start;\n  return newPageIndex !== requestedPageIndex && loadCount > 0;\n};\n\nvar empty = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY\n};\n\nvar getRowsInterval = function (r) {\n  return r === emptyVirtualRows ? empty : {\n    start: r.skip,\n    end: r.skip + r.rows.length\n  };\n};\n\nvar getLength = function (a) {\n  return a.end - a.start;\n};\n\nvar intersect = function (a, b) {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end)\n  };\n};\n\nvar difference = function (a, b) {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end\n    };\n  }\n\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start\n    };\n  }\n\n  return empty;\n};\n\nvar intervalUtil = {\n  empty: empty,\n  getRowsInterval: getRowsInterval,\n  getLength: getLength,\n  intersect: intersect,\n  difference: difference\n};\n\nvar tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {\n  var tableDataColumns = tableColumns.filter(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n\n  var getMaxNestedLevel = function (bands, level, result) {\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (result === void 0) {\n      result = null;\n    }\n\n    return bands.reduce(function (acc, column) {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n\n      var isDataColumn = tableDataColumns.findIndex(function (dataColumn) {\n        return !!dataColumn.column && dataColumn.column.name === column.columnName;\n      }) > -1;\n\n      if (level > acc.level && isDataColumn) {\n        return __assign(__assign({}, acc), {\n          level: level\n        });\n      }\n\n      return acc;\n    }, result || {\n      level: 0\n    });\n  };\n\n  var tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands, 0).level\n  }).map(function (row, index) {\n    return {\n      key: TABLE_BAND_TYPE.toString() + \"_\" + index,\n      type: TABLE_BAND_TYPE,\n      level: index\n    };\n  });\n  return __spread(tableBandHeaders, tableHeaderRows);\n};\n\nvar tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {\n  var chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  var maxBandRowIndex = tableHeaderRows.filter(function (row) {\n    return row.type === TABLE_BAND_TYPE;\n  }).length;\n  var rawBandChains = chains.slice(0, maxBandRowIndex);\n  var currentBand = null;\n\n  var shouldSplitChain = function (chain, column, rowIndex) {\n    if (rowIndex > maxBandRowIndex) return false;\n    var columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain || chain.key !== currentBand.key;\n  };\n\n  var extendChainProps = function () {\n    return {\n      bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,\n      key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key\n    };\n  };\n\n  var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);\n  return __spread(bandChains, chains.slice(maxBandRowIndex));\n};\n\nvar getBandLevels = function (columnsBands, levels, level) {\n  if (levels === void 0) {\n    levels = {};\n  }\n\n  if (level === void 0) {\n    level = 0;\n  }\n\n  columnsBands.forEach(function (band) {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\n\nvar columnBandLevels = function (columnsBands) {\n  return getBandLevels(columnsBands);\n};\n\nvar bandLevelsVisibility = function (columnIntervals, tableHeaderColumnChains, bandLevels) {\n  var rowsWithBands = tableHeaderColumnChains.filter(function (r) {\n    return r.filter(function (ch) {\n      return !!ch.bandTitle;\n    }).length;\n  });\n  var visibleIntervals = columnIntervals.map(function (_a) {\n    var _b = __read(_a, 2),\n        start = _b[0],\n        end = _b[1];\n\n    return {\n      start: start,\n      end: end\n    };\n  });\n\n  var isBandChainVisible = function (chain) {\n    return visibleIntervals.some(function (interval) {\n      return intervalUtil.intersect(interval, {\n        start: chain.start,\n        end: chain.start + chain.columns.length - 1\n      }) !== intervalUtil.empty;\n    });\n  };\n\n  var getVisibleBandsByLevel = function (level) {\n    return (// Note: a visible band level always matches with it's row\n      rowsWithBands[level] ? rowsWithBands[level].filter(function (chain) {\n        return bandLevels[chain.bandTitle] === level && isBandChainVisible(chain);\n      }) : []\n    );\n  };\n\n  return rowsWithBands.reduce(function (acc, _, index) {\n    var rowBands = getVisibleBandsByLevel(index);\n    return __spread(acc, [!!rowBands.length]);\n  }, []);\n};\n\nvar columnVisibleIntervals = function (viewport, tableColumns) {\n  return viewport ? viewport.columns : [[0, tableColumns.length]];\n};\n\nvar toggleDetailRowExpanded = function (prevExpanded, _a) {\n  var rowId = _a.rowId,\n      state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\n\nvar TABLE_DETAIL_TYPE = Symbol('detail');\n\nvar isDetailRowExpanded = function (expandedDetailRowIds, rowId) {\n  return expandedDetailRowIds.indexOf(rowId) > -1;\n};\n\nvar isDetailToggleTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\n\nvar isDetailTableRow = function (tableRow) {\n  return tableRow.type === TABLE_DETAIL_TYPE;\n};\n\nvar isDetailTableCell = function (tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\n\nvar tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {\n  var result = tableRows;\n  expandedDetailRowIds.forEach(function (expandedRowId) {\n    var rowIndex = result.findIndex(function (tableRow) {\n      return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId;\n    });\n    if (rowIndex === -1) return;\n    var insertIndex = rowIndex + 1;\n    var _a = result[rowIndex],\n        row = _a.row,\n        rowId = _a.rowId;\n    result = __spread(result.slice(0, insertIndex), [{\n      rowId: rowId,\n      row: row,\n      key: TABLE_DETAIL_TYPE.toString() + \"_\" + rowId,\n      type: TABLE_DETAIL_TYPE,\n      height: rowHeight\n    }], result.slice(insertIndex));\n  });\n  return result;\n};\n\nvar tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) {\n  return __spread([{\n    key: TABLE_DETAIL_TYPE.toString(),\n    type: TABLE_DETAIL_TYPE,\n    width: toggleColumnWidth\n  }], tableColumns);\n};\n\nvar tableDetailCellColSpanGetter = function (getTableCellColSpan) {\n  return function (params) {\n    var tableRow = params.tableRow,\n        tableColumns = params.tableColumns,\n        tableColumn = params.tableColumn;\n\n    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n      return tableColumns.length;\n    }\n\n    return getTableCellColSpan(params);\n  };\n};\n\nvar TABLE_SELECT_TYPE = Symbol('select');\n\nvar isSelectTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\n};\n\nvar isSelectAllTableCell = function (tableRow, tableColumn) {\n  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n};\n\nvar isRowHighlighted = function (highlightRow, selection, tableRow) {\n  return highlightRow && selection && selection.includes(tableRow.rowId);\n};\n\nvar tableColumnsWithSelection = function (tableColumns, selectionColumnWidth) {\n  return __spread([{\n    key: TABLE_SELECT_TYPE.toString(),\n    type: TABLE_SELECT_TYPE,\n    width: selectionColumnWidth\n  }], tableColumns);\n};\n\nvar VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nvar TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\n\nvar isDataTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isHeaderStubTableCell = function (tableRow, headerRows) {\n  return headerRows.indexOf(tableRow) > -1;\n};\n\nvar isDataTableRow = function (tableRow) {\n  return tableRow.type === TABLE_DATA_TYPE;\n};\n\nvar isNoDataTableRow = function (tableRow) {\n  return tableRow.type === TABLE_NODATA_TYPE;\n};\n\nvar isNoDataTableCell = function (tableColumn, tableColumns) {\n  return tableColumns.indexOf(tableColumn) === 0;\n};\n\nvar isStubTableCell = function (tableRow) {\n  return tableRow.type === TABLE_STUB_TYPE;\n};\n\nvar checkTableColumnExtensions = function (columnExtensions) {\n  if (columnExtensions) {\n    columnExtensions.map(function (column) {\n      var width = column.width;\n\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS$1)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\n\nvar getColumnExtension = function (columnExtensions, columnName) {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n\n  var columnExtension = columnExtensions.find(function (extension) {\n    return extension.columnName === columnName;\n  });\n\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {};\n  }\n\n  return columnExtension;\n};\n\nvar getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) {\n  return function (columnName) {\n    if (columnExtensions) {\n      var columnExtension = getColumnExtension(columnExtensions, columnName);\n      var extensionValue = columnExtension[extensionName];\n      return extensionValue !== undefined ? extensionValue : defaultValue;\n    }\n\n    return defaultValue;\n  };\n};\n\nvar tableColumnsWithDataRows = function (columns, columnExtensions) {\n  return columns.map(function (column) {\n    var name = column.name;\n    var columnExtension = getColumnExtension(columnExtensions, name);\n    var width = convertWidth(columnExtension.width);\n    return {\n      column: column,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + name,\n      type: TABLE_DATA_TYPE,\n      width: width,\n      align: columnExtension.align,\n      wordWrapEnabled: columnExtension.wordWrapEnabled\n    };\n  });\n};\n\nvar tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) {\n  return !rows.length && !isRemoteRowsLoading ? [{\n    key: TABLE_NODATA_TYPE.toString(),\n    type: TABLE_NODATA_TYPE\n  }] : rows.map(function (row, dataIndex) {\n    var rowId = getRowId(row);\n    return {\n      row: row,\n      // dataIndex,\n      rowId: rowId,\n      type: TABLE_DATA_TYPE,\n      key: TABLE_DATA_TYPE.toString() + \"_\" + rowId\n    };\n  });\n};\n\nvar tableCellColSpanGetter = function (params) {\n  var tableRow = params.tableRow,\n      tableColumns = params.tableColumns,\n      tableColumn = params.tableColumn;\n\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n\n  return 1;\n};\n\nvar visibleTableColumns = function (tableColumns, hiddenColumnNames) {\n  if (tableColumns === void 0) {\n    tableColumns = [];\n  }\n\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type !== TABLE_DATA_TYPE || hiddenColumnNames.indexOf(tableColumn.column.name) === -1;\n  });\n};\n\nvar tableDataColumnsExist = function (tableColumns) {\n  return tableColumns.some(function (column) {\n    return column.type === TABLE_DATA_TYPE;\n  });\n};\n\nvar columnChooserItems = function (columns, hiddenColumnNames) {\n  return columns.map(function (column) {\n    return {\n      column: column,\n      hidden: hiddenColumnNames.indexOf(column.name) !== -1\n    };\n  });\n};\n\nvar toggleColumn = function (hiddenColumnNames, columnName) {\n  return hiddenColumnNames.indexOf(columnName) === -1 ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) {\n    return hiddenColumn !== columnName;\n  });\n};\n\nvar toggleRowExpanded = function (prevExpanded, _a) {\n  var rowId = _a.rowId,\n      state = _a.state;\n  return toggle(prevExpanded, [rowId], state);\n};\n\nvar GRID_TREE_NODE_TYPE = Symbol('treeNode');\n\nvar customTreeRows = function (currentRow, getChildRows, rootRows, level) {\n  if (level === void 0) {\n    level = 0;\n  }\n\n  var childRows = getChildRows(currentRow, rootRows);\n  if (!childRows) return {\n    rows: [],\n    treeMeta: [],\n    empty: true\n  };\n  return childRows.reduce(function (acc, row) {\n    var _a, _b;\n\n    var nestedResult = customTreeRows(row, getChildRows, rootRows, level + 1);\n\n    (_a = acc.rows).push.apply(_a, __spread([row], nestedResult.rows));\n\n    (_b = acc.treeMeta).push.apply(_b, __spread([[row, {\n      level: level,\n      leaf: !!nestedResult.empty\n    }]], nestedResult.treeMeta));\n\n    return acc;\n  }, {\n    rows: [],\n    treeMeta: []\n  });\n};\n\nvar customTreeRowsWithMeta = function (rows, getChildRows) {\n  var result = customTreeRows(null, getChildRows, rows);\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta)\n  };\n};\n\nvar customTreeRowIdGetter = function (getRowId, _a) {\n  var rows = _a.rows,\n      treeMeta = _a.treeMeta;\n  var firstNestedRowIndex = rows.findIndex(function (row) {\n    return treeMeta.get(row).level > 0;\n  });\n\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n\n  var map = new Map(rows.map(function (row, rowIndex) {\n    return [row, rowIndex];\n  }));\n  return function (row) {\n    return map.get(row);\n  };\n};\n\nvar customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n\n    if (rowMeta !== undefined) {\n      return GRID_TREE_NODE_TYPE.toString() + \"_\" + rowMeta.level;\n    }\n\n    return getRowLevelKey && getRowLevelKey();\n  };\n};\n\nvar expandedTreeRows = function (_a, getRowId, expandedRowIds) {\n  var rows = _a.rows,\n      treeMeta = _a.treeMeta;\n  var expandedRowIdsSet = new Set(expandedRowIds);\n  var currentExpanded = true;\n  var currentLevel = 0;\n  var collapsedRowsMeta = new Map();\n  var resultRows = [];\n  rows.forEach(function (row) {\n    var rowMeta = treeMeta.get(row);\n    var level = rowMeta && rowMeta.level;\n\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      var lastRow = resultRows[resultRows.length - 1];\n      var collapsedItems = collapsedRowsMeta.get(lastRow);\n\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level;\n      resultRows.push(row);\n    }\n  });\n  return {\n    treeMeta: treeMeta,\n    collapsedRowsMeta: collapsedRowsMeta,\n    rows: resultRows\n  };\n};\n\nvar collapsedTreeRowsGetter = function (getCollapsedRows, _a) {\n  var collapsedRowsMeta = _a.collapsedRowsMeta;\n  return function (row) {\n    return collapsedRowsMeta.get(row) || getCollapsedRows && getCollapsedRows(row);\n  };\n};\n\nvar isTreeRowLeafGetter = function (_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.leaf;\n  };\n};\n\nvar getTreeRowLevelGetter = function (_a) {\n  var treeMeta = _a.treeMeta;\n  return function (row) {\n    var rowMeta = treeMeta.get(row);\n    return rowMeta && rowMeta.level;\n  };\n};\n\nvar unwrappedCustomTreeRows = function (_a) {\n  var rows = _a.rows;\n  return rows;\n};\n\nvar isTreeTableCell = function (tableRow, tableColumn, forColumnName) {\n  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE && tableColumn.column.name === forColumnName;\n};\n\nvar changeSearchValue = function (prevSearchValue, searchValue) {\n  return searchValue;\n};\n\nvar searchFilterExpression = function (searchValue, columns, filterExpression) {\n  var filters = columns.map(function (_a) {\n    var name = _a.name;\n    return {\n      columnName: name,\n      value: searchValue\n    };\n  });\n  var selfFilterExpression = {\n    filters: filters,\n    operator: 'or'\n  };\n\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n\n  return {\n    operator: 'and',\n    filters: [filterExpression, selfFilterExpression]\n  };\n};\n\nvar getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) {\n  return function (columnName) {\n    return columnNames.indexOf(columnName) > -1 && availableFilterOperations || // tslint:disable-next-line: max-line-length\n    typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName) || undefined;\n  };\n};\n\nvar FIXED_COLUMN_LEFT_SIDE = 'left';\nvar FIXED_COLUMN_RIGHT_SIDE = 'right';\nvar TABLE_FIXED_TYPE = Symbol('fixed');\n\nvar getFixedColumnKeys = function (tableColumns, fixedNames) {\n  return tableColumns.filter(function (tableColumn) {\n    return tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1 || fixedNames.indexOf(tableColumn.type) !== -1;\n  }).map(function (_a) {\n    var key = _a.key;\n    return key;\n  });\n};\n\nvar isFixedTableRow = function (tableRow) {\n  return tableRow.type === TABLE_FIXED_TYPE;\n};\n\nvar calculatePosition = function (array, index, tableColumnDimensions) {\n  return index === 0 ? 0 : array.slice(0, index).reduce(function (acc, target) {\n    return acc + tableColumnDimensions[target] || 0;\n  }, 0);\n};\n\nvar calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {\n  var tableColumn = _a.tableColumn;\n  var leftColumns = _b.leftColumns,\n      rightColumns = _b.rightColumns;\n  var side = tableColumn.fixed;\n  var targetArray = side === FIXED_COLUMN_LEFT_SIDE ? getFixedColumnKeys(tableColumns, leftColumns) : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n  var index = tableColumns.findIndex(function (_a) {\n    var key = _a.key;\n    return key === tableColumn.key;\n  });\n  var fixedIndex = targetArray.indexOf(tableColumn.key);\n  var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);\n  var showLeftDivider = columnChain.start === index && index !== 0;\n  var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index && index < tableColumns.length - 1;\n  var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n  return {\n    showRightDivider: showRightDivider,\n    showLeftDivider: showLeftDivider,\n    position: position,\n    side: side\n  };\n};\n\nvar tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) {\n  return tableColumns.map(function (tableColumn) {\n    var fixed;\n\n    if (tableColumn.type === TABLE_DATA_TYPE && leftColumns.indexOf(tableColumn.column.name) !== -1 || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n\n    if (tableColumn.type === TABLE_DATA_TYPE && rightColumns.indexOf(tableColumn.column.name) !== -1 || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n\n    return fixed ? __assign(__assign({}, tableColumn), {\n      fixed: fixed\n    }) : tableColumn;\n  });\n};\n\nvar tableHeaderRowsWithFixed = function (tableHeaderRows) {\n  return __spread(tableHeaderRows, [{\n    key: TABLE_FIXED_TYPE.toString(),\n    type: TABLE_FIXED_TYPE,\n    height: 0\n  }]);\n};\n\nvar tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {\n  var chains = tableHeaderColumnChains || generateSimpleChains(tableHeaderRows, tableColumns);\n\n  var shouldSplitChain = function (currentGroup, column) {\n    return !currentGroup || currentGroup.fixed !== column.fixed;\n  };\n\n  var extendChainProps = function (column) {\n    return {\n      fixed: column.fixed\n    };\n  };\n\n  return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);\n};\n\nvar defaultSummaryCalculators = {\n  count: function (rows) {\n    return rows.length;\n  },\n  sum: function (rows, getValue) {\n    return rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0);\n  },\n  max: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.max(acc, getValue(row));\n    }, -Infinity) : null;\n  },\n  min: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return Math.min(acc, getValue(row));\n    }, Infinity) : null;\n  },\n  avg: function (rows, getValue) {\n    return rows.length ? rows.reduce(function (acc, row) {\n      return acc + getValue(row);\n    }, 0) / rows.length : null;\n  }\n};\n\nvar defaultSummaryCalculator = function (type, rows, getValue) {\n  var summaryCalculator = defaultSummaryCalculators[type];\n\n  if (!summaryCalculator) {\n    throw new Error(\"The summary type '\" + type + \"' is not defined\");\n  }\n\n  return summaryCalculator(rows, getValue);\n};\n\nvar rowsSummary = function (rows, summaryItems, getCellValue, calculator) {\n  return summaryItems.reduce(function (acc, _a) {\n    var type = _a.type,\n        columnName = _a.columnName;\n\n    var getValue = function (row) {\n      return getCellValue(row, columnName);\n    };\n\n    acc.push(calculator(type, rows, getValue));\n    return acc;\n  }, []);\n};\n\nvar expandRows = function (rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {\n  if (includeGroupRow === void 0) {\n    includeGroupRow = false;\n  }\n\n  var shouldIncludeRow = includeGroupRow || !isGroupRow ? function () {\n    return true;\n  } : function (row) {\n    return !isGroupRow(row);\n  };\n  return rows.reduce(function (acc, row) {\n    if (getRowLevelKey && getRowLevelKey(row)) {\n      if (shouldIncludeRow(row)) {\n        acc.push(row);\n      }\n\n      var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n\n      if (collapsedRows) {\n        acc.push.apply(acc, __spread(collapsedRows));\n      }\n\n      return acc;\n    }\n\n    acc.push(row);\n    return acc;\n  }, []);\n};\n\nvar totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n\n  var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\n\nvar groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n\n  var levels = [];\n\n  var getLevelIndex = function (levelKey) {\n    return levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n  };\n\n  var summaries = {};\n  var anyRowLevelSummaryExist = summaryItems.some(function (item) {\n    return !item.showInGroupFooter;\n  });\n  var expandedRows = anyRowLevelSummaryExist ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true) : rows;\n  expandedRows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n    var collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    var levelIndex = getLevelIndex(levelKey);\n\n    if (levelIndex > -1) {\n      levels.forEach(function (level) {\n        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n\n    if (isGroupRow(row)) {\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n      levelIndex = getLevelIndex(levelKey);\n    } // when row level summary exists, these rows had already been expanded earlier\n\n\n    var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    var rowsToAppend = !levelKey ? [row] : collapsedRows;\n\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach(function (level) {\n        var _a;\n\n        (_a = level.rows).push.apply(_a, __spread(rowsToAppend));\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n  });\n  return summaries;\n};\n\nvar treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {\n  if (calculator === void 0) {\n    calculator = defaultSummaryCalculator;\n  }\n\n  var levels = [];\n  var summaries = {};\n  rows.forEach(function (row) {\n    var levelKey = getRowLevelKey(row);\n\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n\n    var levelIndex = levels.findIndex(function (level) {\n      return level.levelKey === levelKey;\n    });\n\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach(function (level) {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        rows: []\n      });\n    }\n  }, {});\n  levels.forEach(function (level) {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);\n    }\n  });\n  return summaries;\n};\n\nvar TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nvar TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nvar TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\nvar defaultFormatlessSummaries = ['count'];\n\nvar isTotalSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isGroupSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isTreeSummaryTableCell = function (tableRow, tableColumn) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n};\n\nvar isTotalSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE;\n};\n\nvar isGroupSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE;\n};\n\nvar isTreeSummaryTableRow = function (tableRow) {\n  return tableRow.type === TABLE_TREE_SUMMARY_TYPE;\n};\n\nvar getColumnSummaries = function (summaryItems, columnName, summaryValues, predicate) {\n  if (predicate === void 0) {\n    predicate = function () {\n      return true;\n    };\n  }\n\n  return summaryItems.map(function (item, index) {\n    return [item, index];\n  }).filter(function (_a) {\n    var _b = __read(_a, 1),\n        item = _b[0];\n\n    return item.columnName === columnName && predicate(item);\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n        item = _b[0],\n        index = _b[1];\n\n    return {\n      type: item.type,\n      value: summaryValues[index]\n    };\n  });\n};\n\nvar isFooterSummary = function (summaryItem) {\n  return summaryItem.showInGroupFooter;\n};\n\nvar isInlineGroupCaptionSummary = function (summaryItem) {\n  return !(summaryItem.showInGroupFooter || summaryItem.alignByColumn);\n};\n\nvar groupFooterSummaryExists = function (groupSummaryItems) {\n  return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary);\n};\n\nvar getGroupInlineSummaries = function (summaryItems, columns, summaryValues) {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n\n  return columns.reduce(function (acc, column) {\n    var colName = column.name;\n    var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);\n\n    if (summaries.length) {\n      acc.push({\n        column: column,\n        summaries: summaries\n      });\n    }\n\n    return acc;\n  }, []);\n};\n\nvar tableRowsWithTotalSummaries = function (footerRows) {\n  return __spread([{\n    key: TABLE_TOTAL_SUMMARY_TYPE.toString(),\n    type: TABLE_TOTAL_SUMMARY_TYPE\n  }], footerRows);\n};\n\nvar tableRowsWithSummaries = function (tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {\n  if (!getRowLevelKey || !(groupSummaryItems || treeSummaryItems)) return tableRows;\n  var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  var result = [];\n\n  var closeLevel = function (level) {\n    if (!level.opened) return;\n\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      var compoundKey = level.row.compoundKey;\n      result.push({\n        key: TABLE_GROUP_SUMMARY_TYPE.toString() + \"_\" + compoundKey,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row\n      });\n    } else if (treeSummaryItems) {\n      var rowId = getRowId(level.row);\n      result.push({\n        key: TABLE_TREE_SUMMARY_TYPE.toString() + \"_\" + rowId,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row\n      });\n    }\n  };\n\n  var levels = [];\n  tableRows.forEach(function (tableRow) {\n    var row = tableRow.row;\n    var levelKey = getRowLevelKey(row);\n\n    if (levelKey) {\n      var levelIndex = levels.findIndex(function (level) {\n        return level.levelKey === levelKey;\n      });\n\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(function (level) {\n          return __assign(__assign({}, level), {\n            opened: true\n          });\n        });\n      }\n\n      levels.push({\n        levelKey: levelKey,\n        row: row,\n        opened: false\n      });\n    } else {\n      levels = levels.map(function (level) {\n        return __assign(__assign({}, level), {\n          opened: true\n        });\n      });\n    }\n\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n  return result;\n};\n\nvar prepareGroupSummaryItems = function (items) {\n  return !!items ? items.map(function (item) {\n    return __assign(__assign({}, item), {\n      showInGroupFooter: item.showInGroupFooter === undefined && !item.alignByColumn ? true : item.showInGroupFooter\n    });\n  }) : items;\n};\n\nvar getTargetColumnGeometries = function (columnGeometries, sourceIndex) {\n  var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n\n  var getWidthDifference = function (index) {\n    return columnGeometries[index].right - columnGeometries[index].left - sourceWidth;\n  };\n\n  return columnGeometries.map(function (_a, targetIndex) {\n    var top = _a.top,\n        right = _a.right,\n        bottom = _a.bottom,\n        left = _a.left;\n    var leftBorder = left;\n\n    if (targetIndex > 0 && targetIndex <= sourceIndex) {\n      leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n    }\n\n    if (targetIndex > sourceIndex) {\n      leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n    }\n\n    var rightBorder = right;\n\n    if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n      rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n    }\n\n    if (targetIndex < sourceIndex) {\n      rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n    }\n\n    return {\n      top: top,\n      bottom: bottom,\n      right: rightBorder,\n      left: leftBorder\n    };\n  });\n};\n\nvar getTableColumnGeometries = function (columns, tableWidth) {\n  var columnWidths = columns.map(function (column) {\n    return column.width;\n  });\n  var freeSpace = tableWidth;\n  var restrictedSpace = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width === 'number' ? width : 0);\n  }, 0);\n  var freeSpacePortions = columnWidths.reduce(function (accum, width) {\n    return accum + (typeof width !== 'number' ? 1 : 0);\n  }, 0);\n  var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;\n  var lastRightPosition = 0;\n  return columnWidths.map(function (width) {\n    return typeof width !== 'number' ? freeSpacePortion : width;\n  }).map(function (width) {\n    lastRightPosition += width;\n    return {\n      left: lastRightPosition - width,\n      right: lastRightPosition\n    };\n  });\n};\n\nvar getTableTargetColumnIndex = function (columnGeometries, sourceIndex, offset) {\n  return getTargetColumnGeometries(columnGeometries, sourceIndex).findIndex(function (_a) {\n    var left = _a.left,\n        right = _a.right;\n    return offset > left && offset < right;\n  });\n};\n\nvar ANIMATION_DURATION = 200;\n\nvar getAnimationProgress = function (animation) {\n  return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n};\n\nvar getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {\n  var resizing = prevColumns.map(function (column) {\n    return column.key;\n  }).join() === nextColumns.map(function (column) {\n    return column.key;\n  }).join();\n  var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth).map(function (geometry, index) {\n    return [prevColumns[index].key, geometry];\n  }).map(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        geometry = _b[1];\n\n    var animation = prevAnimations.get(key);\n    if (!animation) return [key, geometry];\n    var progress = easeOutCubic(getAnimationProgress(animation));\n    var _c = animation.left,\n        to = _c.to,\n        from = _c.from;\n    var left = (to - from) * progress + from;\n    return [key, {\n      left: left,\n      right: geometry.right - (geometry.left - left)\n    }]; // tslint:disable-next-line:array-type\n  }));\n  var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth) // tslint:disable-next-line:array-type\n  .map(function (geometry, index) {\n    return [nextColumns[index].key, geometry];\n  }));\n  return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {\n    var prev = prevColumnGeometries.get(key);\n    var next = nextColumnGeometries.get(key);\n    var result = {\n      startTime: new Date().getTime(),\n      style: {}\n    };\n    var takePrevColumnIntoAccount = !!prevAnimations.get(key) || prev && !resizing;\n\n    if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {\n      result.left = {\n        from: prev.left,\n        to: next.left\n      };\n    }\n\n    return [key, result];\n  }).filter(function (animation) {\n    return animation[1].left;\n  }));\n};\n\nvar filterActiveAnimations = function (animations) {\n  return new Map(__spread(animations.entries()).filter(function (_a) {\n    var _b = __read(_a, 2),\n        animation = _b[1];\n\n    return getAnimationProgress(animation) < 1;\n  }));\n};\n\nvar evalAnimations = function (animations) {\n  return new Map(__spread(animations.entries()).map(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        animation = _b[1];\n\n    var progress = easeOutCubic(getAnimationProgress(animation));\n\n    var result = __assign({}, animation.style);\n\n    if (animation.left) {\n      var offset = (animation.left.to - animation.left.from) * (progress - 1);\n      result.transform = \"translateX(\" + offset + \"px)\";\n    }\n\n    return [key, result];\n  }));\n};\n\nvar isOnTheSameLine = function (geometry, y) {\n  return y >= geometry.top && y <= geometry.bottom;\n};\n\nvar rectToObject = function (_a) {\n  var top = _a.top,\n      right = _a.right,\n      bottom = _a.bottom,\n      left = _a.left;\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n};\n\nvar collapseGapsBetweenItems = function (geometries) {\n  return geometries.map(function (geometry, index) {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return __assign(__assign({}, geometry), {\n        right: geometries[index + 1].left\n      });\n    }\n\n    return geometry;\n  });\n};\n\nvar getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {\n  var x = _a.x,\n      y = _a.y;\n  if (geometries.length === 0) return 0;\n  var targetGeometries = sourceIndex !== -1 ? getTargetColumnGeometries(geometries, sourceIndex) : geometries.map(rectToObject);\n  var targetIndex = collapseGapsBetweenItems(targetGeometries).findIndex(function (geometry, index) {\n    var inVerticalBounds = isOnTheSameLine(geometry, y);\n    var inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n    var shouldGoFirst = index === 0 && x < geometry.left;\n    var shouldGoOnLineBreak = !inVerticalBounds && !!geometries[index - 1] && isOnTheSameLine(geometries[index - 1], y);\n    return inVerticalBounds && inHorizontalBounds || shouldGoFirst || shouldGoOnLineBreak;\n  });\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n/** @internal */\n\n\nvar arraysEqual = function (arrA, arrB, comparator) {\n  if (comparator === void 0) {\n    comparator = function (a, b) {\n      return a === b;\n    };\n  }\n\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/** @internal */\n\n\nvar emptyViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600\n};\nvar TOP_POSITION = Symbol('top');\nvar BOTTOM_POSITION = Symbol('bottom');\nvar VALID_UNITS$2 = ['px', ''];\n/* tslint:disable max-line-length */\n\nvar VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\n\nvar getViewport = function (state, getters, estimatedRowHeight, getRowHeight, getColumnWidth) {\n  var viewportTop = state.viewportTop,\n      viewportLeft = state.viewportLeft,\n      containerWidth = state.containerWidth,\n      containerHeight = state.containerHeight,\n      headerHeight = state.headerHeight,\n      footerHeight = state.footerHeight;\n  var loadedRowsStart = getters.loadedRowsStart,\n      tableBodyRows = getters.bodyRows,\n      tableColumns = getters.columns,\n      _a = getters.headerRows,\n      tableHeaderRows = _a === void 0 ? [] : _a,\n      _b = getters.footerRows,\n      tableFooterRows = _b === void 0 ? [] : _b,\n      isDataRemote = getters.isDataRemote,\n      viewport = getters.viewport;\n  var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight - headerHeight - footerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight, isDataRemote);\n  var headerRows = getRowsVisibleBoundary(tableHeaderRows, 0, headerHeight, getRowHeight, 0, estimatedRowHeight, false);\n  var footerRows = getRowsVisibleBoundary(tableFooterRows, 0, footerHeight, getRowHeight, 0, estimatedRowHeight, false);\n  var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth); // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n\n  var result = viewport;\n\n  if (viewportTop !== viewport.top) {\n    result = __assign(__assign({}, result), {\n      top: viewportTop\n    });\n  }\n\n  if (viewportLeft !== viewport.left) {\n    result = __assign(__assign({}, result), {\n      left: viewportLeft\n    });\n  }\n\n  if (containerWidth !== viewport.width) {\n    result = __assign(__assign({}, result), {\n      width: containerWidth\n    });\n  }\n\n  if (containerHeight !== viewport.height) {\n    result = __assign(__assign({}, result), {\n      height: containerHeight\n    });\n  }\n\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = __assign(__assign({}, result), {\n      rows: rows\n    });\n  }\n\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = __assign(__assign({}, result), {\n      headerRows: headerRows\n    });\n  }\n\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = __assign(__assign({}, result), {\n      footerRows: footerRows\n    });\n  }\n\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = __assign(__assign({}, result), {\n      columns: columns\n    });\n  }\n\n  return result;\n};\n\nvar checkColumnWidths = function (tableColumns) {\n  return tableColumns.reduce(function (acc, tableColumn) {\n    var width = tableColumn.width;\n\n    if (typeof width === 'string') {\n      var numb = parseInt(width, 10);\n      var unit_1 = numb ? width.substr(numb.toString().length) : width;\n      var isValidUnit = VALID_UNITS$2.some(function (validUnit) {\n        return validUnit === unit_1;\n      });\n\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n\n      acc.push(__assign(__assign({}, tableColumn), {\n        width: numb\n      }));\n    } else {\n      acc.push(tableColumn);\n    }\n\n    return acc;\n  }, []);\n};\n\nvar calculateScrollHeight = function (rowHeight, index) {\n  return index > -1 ? rowHeight * index : undefined;\n};\n\nvar getScrollTop = function (rows, rowsCount, rowId, rowHeight, isDataRemote) {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n\n  var searchIndexRequired = !isDataRemote && rowId !== undefined;\n  var indexById = searchIndexRequired ? rows.findIndex(function (row) {\n    return row.rowId === rowId;\n  }) : undefined;\n  return calculateScrollHeight(rowHeight, indexById);\n};\n\nvar getTopRowId = function (viewport, tableBodyRows, isDataRemote) {\n  var hasViewportRows = viewport && viewport.rows;\n  var hasBodyRows = tableBodyRows && tableBodyRows.length;\n\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    var index = viewport.rows[0];\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n\n  return undefined;\n};\n\nvar virtualRowsWithCache = function (skip, rows, cache) {\n  var rowsInterval = intervalUtil.getRowsInterval({\n    skip: skip,\n    rows: rows\n  });\n  var cacheInterval = intervalUtil.getRowsInterval(cache);\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\n\nvar plainRows = function (virtualRows, availableRowCount) {\n  return virtualRows.rows.length > availableRowCount ? virtualRows.rows.slice(0, availableRowCount) : virtualRows.rows;\n};\n\nvar loadedRowsStart = function (virtualRows) {\n  return virtualRows.skip;\n};\n\nvar ROOT_GROUP = '__root__';\nvar DEFAULT_COLUMN_WIDTH = 150;\n\nvar exportHeader = function (worksheet, columns) {\n  var cols = columns.map(function (_a) {\n    var column = _a.column,\n        width = _a.width;\n    return {\n      width: (width || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column === null || column === void 0 ? void 0 : column.name\n    };\n  });\n  worksheet.columns = cols;\n  var lastRow = worksheet.lastRow;\n\n  if (lastRow) {\n    worksheet.addRow({});\n  }\n\n  var headerRow = columns.reduce(function (acc, _a) {\n    var _b;\n\n    var _c = _a.column,\n        _d = _c === void 0 ? {} : _c,\n        name = _d.name,\n        title = _d.title;\n\n    return __assign(__assign({}, acc), (_b = {}, _b[name] = title, _b));\n  }, {});\n  worksheet.addRow(headerRow);\n  worksheet.views.push({\n    state: 'frozen',\n    ySplit: worksheet.lastRow.number\n  });\n};\n\nvar findRanges = function (groupTree, compoundKey, level, maxLevel, result) {\n  if (result === void 0) {\n    result = [];\n  }\n\n  if (level !== maxLevel) {\n    var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) {\n      return __spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result));\n    }, []);\n    return __spread(result, ranges);\n  }\n\n  return __spread(result, [groupTree[compoundKey]]);\n};\n\nvar exportRows = function (worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {\n  var currentLevel = 0;\n  var openGroups = [];\n  var closeGroup = getCloseGroup(rowsOffset);\n  allRows.forEach(function (row) {\n    var _a;\n\n    var _b;\n\n    var excelRow;\n\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy]; // close nested groups first\n\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = {\n        groupedBy: row.groupedBy,\n        compoundKey: row.compoundKey\n      }; // add group row\n\n      var title = (_b = dataColumns.find(function (_a) {\n        var name = _a.name;\n        return name === row.groupedBy;\n      })) === null || _b === void 0 ? void 0 : _b.title;\n      excelRow = (_a = {}, _a[columns[0].column.name] = title + \": \" + row.value, _a);\n      worksheet.addRow(excelRow);\n      var lastIndex = worksheet.lastRow.number; // merge into single cell\n\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow.getCell(1).font = {\n        bold: true\n      };\n\n      if (currentLevel > 0) {\n        worksheet.lastRow.outlineLevel = currentLevel;\n      }\n\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce(function (acc, _a) {\n        var _b;\n\n        var column = _a.column;\n        return __assign(__assign({}, acc), column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null);\n      }, {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow.outlineLevel = currentLevel;\n    }\n\n    worksheet.lastRow.eachCell(function (cell, colNumber) {\n      customizeCell(cell, row, columns[colNumber - 1].column);\n    });\n  });\n  openGroups.reverse().forEach(closeGroup);\n};\n\nvar closeSheet = function (worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {\n  exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);\n};\n\nvar normalizeRanges = function (ranges, offset) {\n  return ranges.map(function (range) {\n    return range.map(function (index) {\n      return +index + offset;\n    });\n  });\n};\n\nvar exportSummaryItems = function (worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {\n  if (!summaryItems) return;\n  worksheet.addRow({});\n  var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);\n  summaryItems.forEach(function (s) {\n    exportSummary(s, ranges);\n  });\n};\n\nvar removeEmptyGroups = function (rows, grouping, isGroupRow) {\n  if (!grouping) return rows;\n  var groupingColumns = grouping.map(function (_a) {\n    var columnName = _a.columnName;\n    return columnName;\n  });\n  var result = [];\n  var groupChain = [];\n  rows.forEach(function (row) {\n    if (isGroupRow(row)) {\n      var level = groupingColumns.indexOf(row.groupedBy);\n\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = __spread(groupChain.slice(0, level), [row]);\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push.apply(result, __spread(groupChain));\n        groupChain = Array.from({\n          length: groupChain.length\n        });\n      }\n\n      result.push(row);\n    }\n  });\n  return result.filter(function (row) {\n    return !!row;\n  });\n};\n\nvar groupOutlineLevels = function (grouping) {\n  return (grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {\n    var _b;\n\n    var columnName = _a.columnName;\n    return __assign(__assign({}, acc), (_b = {}, _b[columnName] = index, _b));\n  }, {})) || {};\n};\n\nvar filterSelectedRows = function (rows, selection, getRowId, isGroupRow) {\n  var selectionSet = new Set(selection);\n  return rows.filter(function (row) {\n    return isGroupRow && isGroupRow(row) || selectionSet.has(getRowId(row));\n  });\n};\n\nvar rowsToExport = function (rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {\n  var expandRows = function (collapsedRows) {\n    return collapsedRows.reduce(function (acc, row) {\n      return __spread(acc, [row], expandRows(getCollapsedRows(row) || []));\n    }, []);\n  };\n\n  var expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n\n  if (!selection) {\n    return expandedRows;\n  }\n\n  var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\n\nvar buildGroupTree = function (rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {\n  var _a;\n\n  var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);\n\n  if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n\n  var maxLevel = Object.keys(outlineLevels).length - 1;\n  var groupSummaryExists = !!groupSummaryItems;\n  var parentChain = {\n    '-1': ROOT_GROUP\n  };\n  var lastDataIndex = 0;\n  var openGroup = '';\n  var index = 0;\n  var level = 0;\n  var prevLevel = 0;\n  rows.forEach(function (row) {\n    var groupedBy = row.groupedBy,\n        compoundKey = row.compoundKey;\n\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n\n        openGroup = compoundKey;\n\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n\n    index += 1;\n  });\n\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n\n  return groupTree;\n};\n\nvar operations = {\n  count: 'COUNTA'\n};\n\nvar exportSummaryGetter = function (worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) {\n  return function (_a, ranges) {\n    var columnName = _a.columnName,\n        type = _a.type;\n    var column = (tableColumns.find(function (_a) {\n      var dataColumn = _a.column,\n          columnType = _a.type;\n      return columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName;\n    }) || {}).column; // NOTE: column is hidden or the grid grouped by this column\n\n    if (!column) {\n      return;\n    }\n\n    var row = worksheet.lastRow;\n    var letter = worksheet.getColumn(columnName).letter;\n    var operation = operations[type] || type.toUpperCase();\n    var rangesStr = ranges.map(function (range) {\n      return range.map(function (r) {\n        return \"\" + letter + r;\n      }).filter(function (val, index, arr) {\n        return arr.indexOf(val) === index;\n      }).join(':');\n    }).join(',');\n    var cell = row.getCell(columnName);\n    cell.value = {\n      formula: operation + \"(\" + rangesStr + \")\",\n      date1904: false\n    };\n    cell.numFmt = \"\\\"\" + defaultSummaryMessages[type] + \":\\\" 0\";\n    var summary = {\n      type: type,\n      ranges: ranges\n    };\n    customizeSummaryCell(cell, column, summary);\n  };\n};\n\nvar closeGroupGetter = function (worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) {\n  return function (rowsOffset) {\n    return function (group) {\n      var groupedBy = group.groupedBy,\n          compoundKey = group.compoundKey;\n      exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);\n    };\n  };\n};\n\nvar maximumGroupLevel = function (grouping) {\n  return (grouping || []).length - 1;\n};\n\nvar TABLE_STUB_TYPE = Symbol('stub');\n\nvar getVisibleBoundaryWithFixed = function (visibleBoundary, items) {\n  return items.reduce(function (acc, item, index) {\n    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n      acc.push([index, index]);\n    }\n\n    return acc;\n  }, [visibleBoundary]);\n};\n\nvar getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  if (itemSize === void 0) {\n    itemSize = 0;\n  }\n\n  var start = null;\n  var end = null;\n  var index = 0;\n  var beforePosition = offset * itemSize;\n  var viewportEnd = viewportStart + viewportSize;\n\n  while (end === null && index < items.length) {\n    var item = items[index];\n    var afterPosition = beforePosition + getItemSize(item);\n    var isVisible = beforePosition >= viewportStart && beforePosition < viewportEnd || afterPosition > viewportStart && afterPosition <= viewportEnd || beforePosition < viewportStart && afterPosition > viewportEnd;\n\n    if (isVisible && start === null) {\n      start = index;\n    }\n\n    if (!isVisible && start !== null) {\n      end = index - 1;\n      break;\n    }\n\n    index += 1;\n    beforePosition = afterPosition;\n  }\n\n  if (start !== null && end === null) {\n    end = index - 1;\n  }\n\n  start = start === null ? 0 : start;\n  end = end === null ? 0 : end;\n  return [start + offset, end + offset];\n};\n\nvar getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {\n  var _a = __read(visibleBoundary, 2),\n      start = _a[0],\n      end = _a[1];\n\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n  return [start, end];\n};\n\nvar getColumnBoundaries = function (columns, left, width, getColumnWidth) {\n  return getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns);\n};\n\nvar getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight, isDataRemote) {\n  var beforePosition = offset * rowHeight;\n  var noVisibleRowsLoaded = rowHeight > 0 && beforePosition + rows.length * rowHeight < top || top < beforePosition;\n  var boundaries;\n\n  if (isDataRemote && noVisibleRowsLoaded) {\n    var topIndex = Math.round(top / rowHeight);\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);\n  }\n\n  return boundaries;\n};\n\nvar getColumnsRenderBoundary = function (columnCount, visibleBoundary) {\n  return getRenderBoundary(columnCount, visibleBoundary, 1);\n};\n\nvar getRowsRenderBoundary = function (rowsCount, visibleBoundary) {\n  return getRenderBoundary(rowsCount, visibleBoundary, 3);\n};\n\nvar getSpanBoundary = function (items, visibleBoundaries, getItemSpan) {\n  return visibleBoundaries.map(function (visibleBoundary) {\n    var endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    var end = endIndex;\n    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n\n    for (var index = 0; index <= endIndex; index += 1) {\n      var span = getItemSpan(items[index]);\n\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n\n    return [start, end];\n  });\n};\n\nvar collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {\n  var breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(function (rowBoundaries) {\n    return rowBoundaries.forEach(function (boundary) {\n      breakpoints.add(boundary[0]); // next interval starts after span end point\n\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    });\n  });\n  visibleBoundaries.filter(function (boundary) {\n    return boundary.every(function (bound) {\n      return 0 <= bound && bound < itemsCount;\n    });\n  }).forEach(function (boundary) {\n    for (var point = boundary[0]; point <= boundary[1]; point += 1) {\n      breakpoints.add(point);\n    }\n\n    if (boundary[1] + 1 < itemsCount) {\n      // close last visible point\n      breakpoints.add(boundary[1] + 1);\n    }\n  });\n\n  var bp = __spread(breakpoints).sort(function (a, b) {\n    return a - b;\n  });\n\n  var bounds = [];\n\n  for (var i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([bp[i], bp[i + 1] - 1]);\n  }\n\n  return bounds;\n};\n\nvar getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {\n  var size = 0;\n\n  for (var i = startIndex; i <= endIndex; i += 1) {\n    size += getColumnSize(columns[i], 0) || 0;\n  }\n\n  return size;\n};\n\nvar getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {\n  var collapsedColumns = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) {\n      return acc || visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    }, false);\n\n    if (isVisible) {\n      var column = columns[boundary[0]];\n      collapsedColumns.push(__assign(__assign({}, column), {\n        width: getColumnWidth(column)\n      }));\n    } else {\n      collapsedColumns.push({\n        key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n        type: TABLE_STUB_TYPE,\n        width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth)\n      });\n    }\n  });\n  return collapsedColumns;\n};\n\nvar getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {\n  var collapsedRows = [];\n  boundaries.forEach(function (boundary) {\n    var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n\n    if (isVisible) {\n      var row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row: row,\n        cells: getCells(row)\n      });\n    } else {\n      var row = {};\n      collapsedRows.push({\n        row: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE,\n          height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight)\n        },\n        cells: getCells(row)\n      });\n    }\n  });\n  return collapsedRows;\n};\n\nvar getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {\n  var collapsedCells = [];\n  var index = 0;\n\n  var _loop_1 = function () {\n    var boundary = boundaries[index];\n    var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) {\n      return acc || spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1];\n    }, false);\n\n    if (isSpan) {\n      var column = columns[boundary[0]];\n      var realColSpan = getColSpan(column);\n      var realColSpanEnd_1 = realColSpan + boundary[0] - 1;\n      var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) {\n        return colSpanBoundary[0] <= realColSpanEnd_1 && realColSpanEnd_1 <= colSpanBoundary[1];\n      });\n      collapsedCells.push({\n        column: column,\n        colSpan: colSpanEnd - index + 1\n      });\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: TABLE_STUB_TYPE.toString() + \"_\" + boundary[0] + \"_\" + boundary[1],\n          type: TABLE_STUB_TYPE\n        },\n        colSpan: 1\n      });\n      index += 1;\n    }\n  };\n\n  while (index < boundaries.length) {\n    _loop_1();\n  }\n\n  return collapsedCells;\n};\n\nvar getCollapsedGrid = function (_a) {\n  var rows = _a.rows,\n      columns = _a.columns,\n      rowsVisibleBoundary = _a.rowsVisibleBoundary,\n      columnsVisibleBoundary = _a.columnsVisibleBoundary,\n      _b = _a.getColumnWidth,\n      getColumnWidth = _b === void 0 ? function (column) {\n    return column.width;\n  } : _b,\n      _c = _a.getRowHeight,\n      getRowHeight = _c === void 0 ? function (row) {\n    return row.height;\n  } : _c,\n      _d = _a.getColSpan,\n      getColSpan = _d === void 0 ? function () {\n    return 1;\n  } : _d,\n      totalRowCount = _a.totalRowCount,\n      offset = _a.offset;\n\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: []\n    };\n  }\n\n  var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n  var rowSpanBoundaries = rows.slice(boundaries[0], boundaries[1]).map(function (row) {\n    return getSpanBoundary(columns, columnsVisibleBoundary, function (column) {\n      return getColSpan(row, column);\n    });\n  });\n  var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);\n  var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);\n  return {\n    columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),\n    rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) {\n      return getCollapsedCells(columns, getSpanBoundary(columns, columnsVisibleBoundary, function (column) {\n        return getColSpan(row, column);\n      }), columnBoundaries, function (column) {\n        return getColSpan(row, column);\n      });\n    }, offset)\n  };\n};\n\nvar getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {\n  var colsHavingWidth = tableColumns.filter(function (col) {\n    return typeof col.width === 'number';\n  });\n  var columnsWidth = colsHavingWidth.reduce(function (acc, col) {\n    return acc + col.width;\n  }, 0);\n  var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  var autoColWidth = Math.max(autoWidth, minColumnWidth);\n  return function (column) {\n    return column.type === TABLE_FLEX_TYPE ? null : typeof column.width === 'number' ? column.width : autoColWidth;\n  };\n};\n\nvar getCollapsedGrids = function (_a) {\n  var _b = _a.headerRows,\n      headerRows = _b === void 0 ? [] : _b,\n      _c = _a.bodyRows,\n      bodyRows = _c === void 0 ? [] : _c,\n      _d = _a.footerRows,\n      footerRows = _d === void 0 ? [] : _d,\n      columns = _a.columns,\n      loadedRowsStart = _a.loadedRowsStart,\n      totalRowCount = _a.totalRowCount,\n      getCellColSpan = _a.getCellColSpan,\n      viewport = _a.viewport,\n      getRowHeight = _a.getRowHeight,\n      getColumnWidth = _a.getColumnWidth;\n\n  var getColSpan = function (tableRow, tableColumn) {\n    return getCellColSpan({\n      tableRow: tableRow,\n      tableColumn: tableColumn,\n      tableColumns: columns\n    });\n  };\n\n  var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {\n    if (rowCount === void 0) {\n      rowCount = rows.length;\n    }\n\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    return getCollapsedGrid({\n      rows: rows,\n      columns: columns,\n      rowsVisibleBoundary: rowsVisibleBoundary,\n      columnsVisibleBoundary: viewport.columns,\n      getColumnWidth: getColumnWidth,\n      getRowHeight: getRowHeight,\n      getColSpan: getColSpan,\n      totalRowCount: rowCount,\n      offset: offset\n    });\n  };\n\n  var headerGrid = getCollapsedGridBlock(headerRows, getRenderRowBounds(viewport.headerRows, headerRows.length));\n  var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);\n  var footerGrid = getCollapsedGridBlock(footerRows, getRenderRowBounds(viewport.footerRows, footerRows.length));\n  return {\n    headerGrid: headerGrid,\n    bodyGrid: bodyGrid,\n    footerGrid: footerGrid\n  };\n};\n\nvar getRenderRowBounds = function (visibleBounds, rowCount) {\n  return getRowsRenderBoundary(rowCount, visibleBounds);\n};\n\nvar adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {\n  var renderRowBoundaries = getRenderRowBounds(visibleBounds, loadedRowsStart + rowCount);\n  var adjustedInterval = intervalUtil.intersect({\n    start: renderRowBoundaries[0],\n    end: renderRowBoundaries[1]\n  }, {\n    start: loadedRowsStart,\n    end: loadedRowsStart + rowCount\n  });\n  return [adjustedInterval.start, adjustedInterval.end];\n};\n\nvar getGroupIndexByColumn = function (grouping, tableColumn) {\n  return grouping.findIndex(function (columnGrouping) {\n    return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name;\n  });\n};\n\nvar isIndentCell = function (tableRow, tableColumn, grouping) {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  var rowGroupIndex = grouping.findIndex(function (columnGrouping) {\n    return columnGrouping.columnName === tableRow.row.groupedBy;\n  });\n  var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n  return columnGroupIndex < rowGroupIndex;\n};\n\nvar isGroupTableCell = function (tableRow, tableColumn) {\n  return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && tableColumn.column && tableColumn.column.name === tableRow.row.groupedBy);\n};\n\nvar isGroupIndentTableCell = function (tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\n\nvar isGroupIndentStubTableCell = function (tableRow, tableColumn, grouping) {\n  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE && isIndentCell(tableRow, tableColumn, grouping);\n};\n\nvar isGroupTableRow = function (tableRow) {\n  return tableRow.type === TABLE_GROUP_TYPE;\n};\n\nvar isGroupRowOrdinaryCell = function (tableRow, tableColumn) {\n  return isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn);\n};\n\nvar columnHasGroupRowSummary = function (tableColumn, groupSummaryItems) {\n  return !!(groupSummaryItems && groupSummaryItems.some(function (item) {\n    return !item.showInGroupFooter && item.alignByColumn && item.columnName === (tableColumn.column && tableColumn.column.name);\n  }));\n};\n\nvar isRowSummaryCell = function (tableRow, tableColumn, grouping, groupSummaryItems) {\n  return columnHasGroupRowSummary(tableColumn, groupSummaryItems) && !isGroupIndentTableCell(tableRow, tableColumn, grouping);\n};\n\nvar isPreviousCellContainSummary = function (tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {\n  var columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);\n};\n\nvar calculateGroupCellIndent = function (tableColumn, grouping, indentWidth) {\n  return indentWidth * getGroupIndexByColumn(grouping, tableColumn);\n};\n\nexport { BAND_DUPLICATE_RENDER, BAND_EMPTY_CELL, BAND_FILL_LEVEL_CELL, BAND_GROUP_CELL, BAND_HEADER_CELL, BOTTOM_POSITION, DEFAULT_COLUMN_WIDTH, DEFAULT_FILTER_OPERATIONS, FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, GROUP_KEY_SEPARATOR, ROOT_GROUP, TABLE_ADDED_TYPE, TABLE_BAND_TYPE, TABLE_DATA_TYPE, TABLE_DETAIL_TYPE, TABLE_EDIT_COMMAND_TYPE, TABLE_EDIT_TYPE, TABLE_FILTER_TYPE, TABLE_FIXED_TYPE, TABLE_FLEX_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_GROUP_TYPE, TABLE_HEADING_TYPE, TABLE_NODATA_TYPE, TABLE_REORDERING_TYPE, TABLE_SELECT_TYPE, TABLE_STUB_TYPE, TABLE_TOTAL_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE, TOP_POSITION, addRow, addedRowsByIds, adjustSortIndex, allSelected, bandLevelsVisibility, buildGroupTree, calculateFixedColumnProps, calculateGroupCellIndent, calculateKeepOther, calculateRequestedRange, calculateScrollHeight, calculateStartPage, cancelAddedRows, cancelChanges, cancelColumnGroupingDraft, cancelDeletedRows, cancelTableColumnWidthDraft, cellValueGetter, changeAddedRow, changeColumnFilter, changeColumnGrouping, changeColumnOrder, changeColumnSorting, changeRow, changeSearchValue, changeTableColumnWidth, changedRowsByIds, checkColumnWidths, checkTableColumnExtensions, clamp, closeGroupGetter, closeSheet, collapsedTreeRowsGetter, columnBandLevels, columnChooserItems, columnVisibleIntervals, columnsWithEditingCells, convertWidth, createRowChangeGetter, currentPage, customGroupedRows, customGroupingRowIdGetter, customTreeRowIdGetter, customTreeRowLevelKeyGetter, customTreeRowsWithMeta, defaultFilterPredicate, defaultFormatlessSummaries, defaultSummaryCalculator, deleteRows, draftColumnGrouping, draftOrder, draftTableColumnWidth, emptyViewport, emptyVirtualRows, evalAnimations, expandedGroupRows, expandedTreeRows, exportHeader, exportRows, exportSummaryGetter, exportSummaryItems, filterActiveAnimations, filterExpression, filteredCollapsedRowsGetter, filteredRows, findChainByColumnIndex, findRanges, firstRowOnPage, generateSimpleChains, getAnimations, getAvailableFilterOperationsGetter, getAvailableRowCount, getBandComponent, getCollapsedGrid, getCollapsedGrids, getColumnBoundaries, getColumnExtension, getColumnExtensionValueGetter, getColumnFilterConfig, getColumnFilterOperations, getColumnMeta, getColumnSizes, getColumnSortingDirection, getColumnSummaries, getColumnWidthGetter, getColumnsRenderBoundary, getFixedColumnKeys, getForceReloadInterval, getGroupCellTargetIndex, getGroupInlineSummaries, getNextColumnName, getPersistentSortedColumns, getReferenceIndex, getRequestMeta, getRowChange, getRowsRenderBoundary, getRowsVisibleBoundary, getScrollTop, getSelectedFilterOperation, getTableColumnGeometries, getTableTargetColumnIndex, getTopRowId, getTreeRowLevelGetter, getViewport, groupCollapsedRowsGetter, groupFooterSummaryExists, groupOutlineLevels, groupRowChecker, groupRowLevelKeyGetter, groupSummaryValues, groupedRows, groupingPanelItems, intervalUtil, isAddedTableRow, isBandedOrHeaderRow, isBandedTableRow, isDataTableCell, isDataTableRow, isDetailRowExpanded, isDetailTableCell, isDetailTableRow, isDetailToggleTableCell, isEditCommandsTableCell, isEditTableCell, isEditTableRow, isFilterTableCell, isFilterTableRow, isFilterValueEmpty, isFixedTableRow, isFooterSummary, isGroupIndentStubTableCell, isGroupIndentTableCell, isGroupRowOrdinaryCell, isGroupSummaryTableCell, isGroupSummaryTableRow, isGroupTableCell, isGroupTableRow, isHeaderStubTableCell, isHeadingEditCommandsTableCell, isHeadingTableCell, isHeadingTableRow, isInlineGroupCaptionSummary, isNoDataColumn, isNoDataTableCell, isNoDataTableRow, isPreviousCellContainSummary, isRowHighlighted, isRowSummaryCell, isSelectAllTableCell, isSelectTableCell, isStubTableCell, isTotalSummaryTableCell, isTotalSummaryTableRow, isTreeRowLeafGetter, isTreeSummaryTableCell, isTreeSummaryTableRow, isTreeTableCell, isValidValue, lastRowOnPage, loadedRowsStart, maximumGroupLevel, mergeRows, needFetchMorePages, normalizeRanges, orderedColumns, pageCount, paginatedRows, plainRows, prepareGroupSummaryItems, recalculateBounds, removeEmptyGroups, rowCount, rowIdGetter, rowToPageIndex, rowsToExport, rowsWithAvailableToSelect, rowsWithEditingCells, rowsWithPageHeaders, searchFilterExpression, setCurrentPage, setPageSize, shouldSendRequest, someSelected, sortedRows, splitHeaderColumnChains, startEditCells, startEditRows, stopEditCells, stopEditRows, tableCellColSpanGetter, tableColumnsWithDataRows, tableColumnsWithDetail, tableColumnsWithDraftWidths, tableColumnsWithEditing, tableColumnsWithFixed, tableColumnsWithGrouping, tableColumnsWithSelection, tableColumnsWithWidths, tableDataColumnsExist, tableDetailCellColSpanGetter, tableGroupCellColSpanGetter, tableHeaderColumnChainsWithBands, tableHeaderColumnChainsWithFixed, tableHeaderRowsWithFilter, tableHeaderRowsWithFixed, tableHeaderRowsWithReordering, tableRowsWithBands, tableRowsWithDataRows, tableRowsWithEditing, tableRowsWithExpandedDetail, tableRowsWithGrouping, tableRowsWithHeading, tableRowsWithSummaries, tableRowsWithTotalSummaries, toggleColumn, toggleDetailRowExpanded, toggleExpandedGroups, toggleRowExpanded, toggleSelection, totalSummaryValues, treeSummaryValues, trimRowsToInterval, unwrapSelectedRows, unwrappedCustomTreeRows, unwrappedFilteredRows, virtualRowsWithCache, visibleTableColumns };","map":{"version":3,"sources":["../src/plugins/integrated-grouping/constants.ts","../src/plugins/grid-core/computeds.ts","../src/plugins/sorting-state/reducers.ts","../src/plugins/sorting-state/helpers.ts","../src/utils/merge-sort.ts","../src/utils/hierarchical-data.ts","../src/plugins/integrated-sorting/computeds.ts","../src/plugins/filtering-state/reducers.ts","../src/plugins/filtering-state/helpers.ts","../src/plugins/filtering-state/computeds.ts","../src/plugins/integrated-filtering/computeds.ts","../src/plugins/grouping-state/constants.ts","../src/plugins/grouping-state/reducers.ts","../src/plugins/grouping-state/helpers.ts","../src/plugins/integrated-grouping/computeds.ts","../src/plugins/custom-grouping/computeds.ts","../src/plugins/grouping-panel/helpers.ts","../src/plugins/paging-state/reducers.ts","../src/plugins/integrated-paging/helpers.ts","../src/plugins/integrated-paging/computeds.ts","../src/plugins/paging-panel/helpers.ts","../src/utils/common-reducers.ts","../src/plugins/selection-state/reducers.ts","../src/plugins/integrated-selection/computeds.ts","../src/plugins/editing-state/reducers.ts","../src/plugins/editing-state/computeds.ts","../src/plugins/editing-state/helpers.ts","../src/plugins/table-column-reordering/constants.ts","../src/plugins/table-column-reordering/reducers.ts","../src/plugins/table/constants.ts","../src/plugins/table-column-reordering/computeds.ts","../src/plugins/table-column-resizing/helpers.ts","../src/plugins/table-column-resizing/computeds.ts","../src/plugins/table-column-resizing/reducers.ts","../src/plugins/table-edit-column/constants.ts","../src/plugins/table-edit-row/constants.ts","../src/plugins/table-header-row/constants.ts","../src/plugins/table-edit-column/helpers.ts","../src/plugins/table-edit-column/computeds.ts","../src/plugins/table-edit-row/helpers.ts","../src/plugins/table-edit-row/computeds.ts","../src/plugins/table-inline-cell-editing/computeds.ts","../src/plugins/table-filter-row/constants.ts","../src/plugins/table-filter-row/helpers.ts","../src/plugins/table-filter-row/computeds.ts","../src/plugins/table-group-row/constants.ts","../src/plugins/table-group-row/computeds.ts","../src/plugins/table-header-row/helpers.ts","../src/plugins/table-header-row/computeds.ts","../src/plugins/table-band-header/constants.ts","../src/plugins/table-band-header/helpers.ts","../src/plugins/virtual-table-state/helpers.ts","../src/plugins/virtual-table-state/utils.ts","../src/plugins/table-band-header/computeds.ts","../src/plugins/row-detail-state/reducers.ts","../src/plugins/table-row-detail/constants.ts","../src/plugins/table-row-detail/helpers.ts","../src/plugins/table-row-detail/computeds.ts","../src/plugins/table-selection/constants.ts","../src/plugins/table-selection/helpers.ts","../src/plugins/table-selection/computeds.ts","../src/plugins/table/helpers.ts","../src/utils/column-extension.ts","../src/plugins/table/computeds.ts","../src/plugins/table-column-visibility/computeds.ts","../src/plugins/table-column-visibility/helpers.ts","../src/plugins/column-chooser/computeds.ts","../src/plugins/column-chooser/reducers.ts","../src/plugins/tree-data-state/reducers.ts","../src/plugins/custom-tree-data/constants.ts","../src/plugins/custom-tree-data/computeds.ts","../src/plugins/table-tree-column/helpers.ts","../src/plugins/search-state/reducers.ts","../src/plugins/search-state/computeds.ts","../src/plugins/data-type-provider/computeds.ts","../src/plugins/table-fixed-columns/constants.ts","../src/plugins/table-fixed-columns/helpers.ts","../src/plugins/table-fixed-columns/computeds.ts","../src/plugins/integrated-summary/computeds.ts","../src/plugins/table-summary-row/constants.ts","../src/plugins/table-summary-row/helpers.ts","../src/plugins/table-summary-row/computeds.ts","../src/plugins/summary-state/helpers.ts","../src/utils/column-geometries.ts","../src/utils/table.ts","../src/utils/group-panel.ts","../src/plugins/virtual-table/utils.ts","../src/plugins/virtual-table/constants.ts","../src/plugins/virtual-table/helpers.ts","../src/plugins/virtual-table-state/computeds.ts","../src/plugins/grid-exporter/constants.ts","../src/plugins/grid-exporter/helpers.ts","../src/plugins/grid-exporter/computeds.ts","../src/utils/virtual-table.ts","../src/plugins/table-group-row/helpers.ts"],"names":["VALID_UNITS"],"mappings":"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","sourcesContent":["export const GRID_GROUP_TYPE = Symbol('group');\nexport const GRID_GROUP_CHECK = Symbol(`${GRID_GROUP_TYPE.toString()}_check`);\nexport const GRID_GROUP_LEVEL_KEY = Symbol(`${GRID_GROUP_TYPE.toString()}_levelKey`);\nexport const GRID_GROUP_COLLAPSED_ROWS = Symbol(`${GRID_GROUP_TYPE.toString()}_collapsedRows`);\n","import { GRID_GROUP_CHECK } from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, GetCellValueFn, Column } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst warnIfRowIdUndefined: PureComputed<[GetRowIdFn]> = getRowId => (row) => {\n  const result = getRowId(row);\n  if (!row[GRID_GROUP_CHECK] && result === undefined) {\n    // tslint:disable-next-line: no-console\n    console.warn('The row id is undefined. Check the getRowId function. The row is', row);\n  }\n  return result;\n};\n\nexport const rowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  if (!getRowId) {\n    const map = new Map(rows.map((row, rowIndex) => [row, rowIndex]) as [any, number]);\n    return (row: Row) => map.get(row) as RowId;\n  }\n  return warnIfRowIdUndefined(getRowId);\n};\n\nconst defaultGetCellValue: GetCellValueFn = (row, columnName) => row[columnName];\n\nexport const cellValueGetter: PureComputed<[GetCellValueFn, Column[]]> = (\n  getCellValue = defaultGetCellValue, columns,\n) => {\n  let useFastAccessor = true;\n  const map = columns.reduce((acc, column) => {\n    if (column.getCellValue) {\n      useFastAccessor = false;\n      acc[column.name] = column.getCellValue;\n    }\n    return acc;\n  }, {});\n\n  if (useFastAccessor) {\n    return getCellValue;\n  }\n\n  return (row, columnName) => (map[columnName]\n    ? map[columnName](row, columnName)\n    : getCellValue(row, columnName));\n};\n","import { ColumnSortingState, ChangeSortingPayload, Sorting } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnSorting: PureReducer<ColumnSortingState, ChangeSortingPayload> = (\n  state, {\n  columnName, direction, keepOther, sortIndex,\n}) => {\n  const { sorting } = state;\n\n  let nextSorting: any[] = [];\n  if (keepOther === true) {\n    nextSorting = sorting as Sorting[];\n  }\n  if (Array.isArray(keepOther)) {\n    nextSorting = slice(sorting)\n      .filter(s =>\n        keepOther.indexOf(s.columnName) > -1);\n  }\n\n  const columnSortingIndex = sorting.findIndex(s => s.columnName === columnName);\n  const columnSorting = sorting[columnSortingIndex];\n  const newColumnSorting = {\n    columnName,\n    direction: direction\n      || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),\n  };\n\n  if (columnSortingIndex > -1) {\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(columnSortingIndex, 1);\n  }\n\n  if (direction !== null) {\n    const newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;\n    const newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;\n    nextSorting = slice(nextSorting);\n    nextSorting.splice(newIndex, 0, newColumnSorting);\n  }\n\n  return {\n    sorting: nextSorting,\n  };\n};\n","import {\n  KeepOtherSorting, GetColumnSortingDirectionFn, GetPersistentSortedColumnsFn,\n  CalculateKeepOtherFn,\n} from '../../types';\n\nconst unique = (arr: any[]) => [...Array.from(new Set(arr))];\n\nexport const getColumnSortingDirection: GetColumnSortingDirectionFn = (\n  sorting, columnName,\n) => {\n  const columnSorting = sorting.filter(s => s.columnName === columnName)[0];\n  return columnSorting ? columnSorting.direction : null;\n};\n\nexport const getPersistentSortedColumns: GetPersistentSortedColumnsFn = (\n  sorting, columnExtensions = [],\n) => columnExtensions.reduce((acc, { columnName, sortingEnabled }) => {\n  if (sortingEnabled === false) {\n    if (sorting.findIndex(sortItem => sortItem.columnName === columnName) > -1) {\n      acc.push(columnName);\n    }\n  }\n  return acc;\n}, [] as string[]);\n\nexport const calculateKeepOther: CalculateKeepOtherFn = (\n  sorting, keepOther, persistentSortedColumns = [],\n) => {\n  if (!persistentSortedColumns.length) return keepOther as KeepOtherSorting;\n  if (!keepOther) return persistentSortedColumns as KeepOtherSorting;\n\n  return Array.isArray(keepOther)\n    ? unique([...keepOther, ...persistentSortedColumns])\n    : unique([...sorting.map(item => item.columnName), ...persistentSortedColumns]);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { MergeFn, SortArrayToAuxiliaryFn, CompareFn } from '../types';\n\n/* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */\n/* tslint:disable no-increment-decrement */\n\nconst merge: MergeFn = (array, auxiliary, lo, mid, hi, compare) => {\n  let i = lo;\n  let j = mid + 1;\n  let k = lo;\n  while (true) {\n    const cmp = compare(array[i], array[j]);\n    if (cmp <= 0) {\n      auxiliary[k++] = array[i++];\n      if (i > mid) {\n        do {\n          auxiliary[k++] = array[j++];\n        } while (j <= hi);\n        break;\n      }\n    } else {\n      auxiliary[k++] = array[j++];\n      if (j > hi) {\n        do {\n          auxiliary[k++] = array[i++];\n        } while (i <= mid);\n        break;\n      }\n    }\n  }\n};\n\nconst sortArrayToAuxiliary: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi < lo) return;\n  if (hi === lo) {\n    auxiliary[lo] = array[lo];\n    return;\n  }\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);\n  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);\n  merge(array, auxiliary, lo, mid, hi, compare);\n};\n\nconst sortAuxiliaryToArray: SortArrayToAuxiliaryFn = (array, auxiliary, lo, hi, compare) => {\n  if (hi <= lo) return;\n  const mid = Math.floor(lo + ((hi - lo) / 2));\n  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);\n  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);\n  merge(auxiliary, array, lo, mid, hi, compare);\n};\n\nexport default (\n  array: any[] | ReadonlyArray<any>,\n  compare: CompareFn = (a, b): number => {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  },\n) => {\n  const result = slice(array);\n  const auxiliary = slice(array);\n  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);\n  return result;\n};\n","import { RowsToTreeFn, TreeToRowsFn, TreeNode } from '../types';\n\nexport const NODE_CHECK = Symbol('node');\n\nexport const rowsToTree: RowsToTreeFn = (rows, getRowLevelKey) => {\n  if (!rows.length) return rows;\n\n  const levels: any[] = [{ children: [] }];\n\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.slice(1)\n        .findIndex(level => getRowLevelKey(level.root) === levelKey) + 1;\n      if (levelIndex > 0) {\n        levels.splice(levelIndex, levels.length - levelIndex);\n      }\n      const node = { [NODE_CHECK]: true, root: row, children: [] };\n      levels[levels.length - 1].children.push(node);\n      levels.push(node);\n    } else {\n      levels[levels.length - 1].children.push(row);\n    }\n  });\n\n  return levels[0].children;\n};\n\nexport const treeToRows: TreeToRowsFn = (tree, rows = []) => {\n  if (!tree.length) return tree;\n  return tree.reduce(\n    (acc, node) => {\n      if (node[NODE_CHECK]) {\n        acc.push(node.root);\n        treeToRows(node.children, rows);\n      } else {\n        acc.push(node);\n      }\n      return acc;\n    },\n    rows as TreeNode[],\n  );\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport {\n  Row, GetRowLevelKeyFn, CompareFn, CreateCompareFn, SortedRowsFn, TreeNode,\n} from '../../types';\n\nconst defaultCompare = (a: any, b: any) => {\n  if (a === b) return 0;\n\n  if (a === null) {\n    return b === undefined ? -1 : 1;\n  }\n  if (a === undefined) {\n    return 1;\n  }\n  if (b === null || b === undefined) {\n    return -1;\n  }\n  return a < b ? -1 : 1;\n};\n\nconst createCompare: CreateCompareFn = (\n  sorting, getColumnCompare, getComparableValue,\n) => sorting.reduceRight((prevCompare, columnSorting) => {\n  const { columnName } = columnSorting;\n  const inverse = columnSorting.direction === 'desc';\n  const columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;\n\n  return (aRow: Row, bRow: Row) => {\n    const a = getComparableValue(aRow, columnName);\n    const b = getComparableValue(bRow, columnName);\n    const result = columnCompare(a, b);\n\n    if (result !== 0) {\n      return inverse ? -result : result;\n    }\n    return prevCompare(aRow, bRow);\n  };\n}, (...args: any[]) => 0);\n\nconst sortTree: PureComputed<[TreeNode[], CompareFn]> = (tree, compare) => {\n  const sortedTree = tree.map((node) => {\n    if (node[NODE_CHECK]) {\n      return {\n        ...node,\n        children: sortTree(node.children, compare),\n      };\n    }\n    return node;\n  });\n\n  return mergeSort(\n    sortedTree, (a, b) => compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b),\n  );\n};\n\nconst sortHierarchicalRows: PureComputed<[Row[], CompareFn, GetRowLevelKeyFn]> = (\n  rows, compare, getRowLevelKey,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n\n  const sortedTree = sortTree(tree, compare);\n\n  return treeToRows(sortedTree);\n};\n\nexport const sortedRows: SortedRowsFn = (\n  rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey,\n) => {\n  if (!sorting.length || !rows.length) return rows;\n\n  let compare;\n  if (!getRowLevelKey) {\n    compare = createCompare(sorting, getColumnCompare, getCellValue);\n    return mergeSort(rows.slice(), compare);\n  }\n\n  compare = createCompare(sorting, getColumnCompare, (row, columnName) => {\n    if (isGroupRow && isGroupRow(row)) {\n      if (row.groupedBy === columnName) {\n        return row.value;\n      }\n      return undefined;\n    }\n    return getCellValue(row, columnName);\n  });\n  return sortHierarchicalRows(\n    rows,\n    compare,\n    getRowLevelKey,\n  );\n};\n","import { Filter, ChangeFilterPayload } from '../../types';\nimport { PureReducer, slice } from '@devexpress/dx-core';\n\nexport const changeColumnFilter: PureReducer<Filter[], ChangeFilterPayload> = (\n  filters, { columnName, config },\n) => {\n  const filterIndex = filters.findIndex(f => f.columnName === columnName);\n  const nextState = slice(filters);\n\n  if (config) {\n    const filter = { columnName, ...config };\n    if (filterIndex > -1) {\n      nextState.splice(filterIndex, 1, filter);\n    } else {\n      nextState.push(filter);\n    }\n  } else if (filterIndex > -1) {\n    nextState.splice(filterIndex, 1);\n  }\n\n  return nextState;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Filter } from '../../types';\n\nexport const getColumnFilterConfig: PureComputed<\n  [Filter[], string], Filter | null\n> = (filters, columnName) => (\n  filters.length && filters.filter(s => s.columnName === columnName)[0] || null\n);\n","import { FilterExpression, Filter } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const filterExpression: PureComputed<\n  [Filter[], FilterExpression?], FilterExpression\n> = (filters, expression) => {\n  // tslint:disable-next-line: no-object-literal-type-assertion\n  const selfFilterExpr = { filters, operator: 'and' as 'and' } as FilterExpression;\n  if (!expression) {\n    return selfFilterExpr;\n  }\n  return {\n    operator: 'and' as 'and',\n    filters: [expression, selfFilterExpr] as FilterExpression[],\n  };\n};\n","import { NODE_CHECK, rowsToTree, treeToRows } from '../../utils/hierarchical-data';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  Row, Filter, FilterPredicate,\n  FilterExpression, GetCellValueFn, RowsWithCollapsedRowsMetaMap,\n  UnwrapRowsComputed, FilteredRowsFn, FilterHierarchicalRowsFn,\n  CompiledPredicate, GetColumnPredicateFn, FilteredCollapsedRowsGetterFn, TreeNode,\n} from '../../types';\n\nconst operators = {\n  or: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc || predicate(row), false)\n  ),\n  and: (predicates: CompiledPredicate[]) => (row: Row) => (\n    predicates.reduce((acc, predicate) => acc && predicate(row), true)\n  ),\n};\n\nconst toLowerCase = (value: any) => String(value).toLowerCase();\n\nconst operationPredicates: { [key: string]: FilterPredicate } = {\n  contains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) > -1,\n\n  notContains: (value, filter) => toLowerCase(value)\n    .indexOf(toLowerCase(filter.value)) === -1,\n\n  startsWith: (value, filter) => toLowerCase(value)\n    .startsWith(toLowerCase(filter.value)),\n\n  endsWith: (value, filter) => toLowerCase(value)\n    .endsWith(toLowerCase(filter.value)),\n\n  equal: (value, filter) => String(value) === String(filter.value),\n  notEqual: (value, filter) => String(value) !== String(filter.value),\n\n  greaterThan: (value, filter) => value > filter.value!,\n  greaterThanOrEqual: (value, filter) => value >= filter.value!,\n  lessThan: (value, filter) => value < filter.value!,\n  lessThanOrEqual: (value, filter) => value <= filter.value!,\n};\n\nexport const defaultFilterPredicate: FilterPredicate = (value, filter) => {\n  const operation = filter.operation || 'contains';\n  return operationPredicates[operation](value, filter);\n};\n\nconst filterTree: PureComputed<[TreeNode[], CompiledPredicate]> = (tree, predicate) => tree.reduce(\n  (acc, node) => {\n    if (node[NODE_CHECK]) {\n      const filteredChildren = filterTree(node.children, predicate) as TreeNode[];\n      if (filteredChildren.length > 0) {\n        acc.push({\n          ...node,\n          children: filteredChildren,\n        });\n        return acc;\n      }\n      if (predicate(node.root, true)) {\n        acc.push(node.root);\n        return acc;\n      }\n      return acc;\n    }\n\n    if (predicate(node)) {\n      acc.push(node);\n      return acc;\n    }\n\n    return acc;\n  },\n  [] as TreeNode[],\n);\n\nconst filterHierarchicalRows: FilterHierarchicalRowsFn = (\n  rows, predicate, getRowLevelKey, getCollapsedRows,\n) => {\n  const tree = rowsToTree(rows, getRowLevelKey);\n  const collapsedRowsMeta: any[] = [];\n\n  const filteredTree = filterTree(tree, (row, isNode) => {\n    if (isNode) {\n      const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n      if (collapsedRows && collapsedRows.length) {\n        const filteredCollapsedRows = collapsedRows.filter(predicate);\n        collapsedRowsMeta.push([row, filteredCollapsedRows]);\n        return !!filteredCollapsedRows.length || predicate(row);\n      }\n      if (predicate(row)) {\n        collapsedRowsMeta.push([row, []]);\n        return true;\n      }\n      return false;\n    }\n    return predicate(row);\n  });\n\n  return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };\n};\n\nconst buildPredicate: PureComputed<\n  [FilterExpression, GetCellValueFn, GetColumnPredicateFn],\n  CompiledPredicate\n> = (\n  initialFilterExpression, getCellValue, getColumnPredicate,\n) => {\n  const getSimplePredicate = (filter: Filter) => {\n    const { columnName } = filter;\n    const customPredicate = getColumnPredicate && getColumnPredicate(columnName);\n    const predicate = customPredicate || defaultFilterPredicate;\n    return (row: Row) => predicate(getCellValue(row, columnName), filter, row);\n  };\n\n  const getOperatorPredicate: any = (filterExpression: FilterExpression) => {\n    const build = operators[toLowerCase(filterExpression.operator)];\n    return build && build(filterExpression.filters.map(getPredicate));\n  };\n\n  const getPredicate = (filterExpression: any) => (\n    getOperatorPredicate(filterExpression)\n    || getSimplePredicate(filterExpression)\n  );\n\n  return getPredicate(initialFilterExpression);\n};\n\nexport const filteredRows: FilteredRowsFn = (\n  rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows,\n) => {\n  if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return { rows } as Partial<RowsWithCollapsedRowsMetaMap>;\n  }\n\n  const predicate = buildPredicate(\n    filterExpression,\n    getCellValue,\n    getColumnPredicate,\n  );\n\n  return getRowLevelKey\n    ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)\n    : { rows: rows.filter(predicate) };\n};\n\nexport const filteredCollapsedRowsGetter: FilteredCollapsedRowsGetterFn = (\n  { collapsedRowsMeta },\n) => row => collapsedRowsMeta && collapsedRowsMeta.get(row);\n\nexport const unwrappedFilteredRows: UnwrapRowsComputed = ({ rows }) => rows;\n","export const GROUP_KEY_SEPARATOR = '|';\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { Getters } from '@devexpress/dx-react-core';\nimport { GROUP_KEY_SEPARATOR } from './constants';\nimport {\n  Grouping, ColumnGroupingState, ChangeGroupingPayload, ToggleGroupPayload, DraftGroupingState,\n} from '../../types';\n\nconst applyColumnGrouping: PureReducer<Grouping[], ChangeGroupingPayload> = (\n  grouping, { columnName, groupIndex },\n) => {\n  let nextGrouping = grouping;\n  const groupingIndex = nextGrouping.findIndex(g => g.columnName === columnName);\n  let targetIndex = groupIndex;\n\n  if (groupingIndex > -1) {\n    nextGrouping = slice(grouping);\n    (nextGrouping as Grouping[]).splice(groupingIndex, 1);\n  } else if (groupIndex === undefined) {\n    targetIndex = nextGrouping.length;\n  }\n\n  if (targetIndex > -1) {\n    nextGrouping = slice(nextGrouping);\n    (nextGrouping as Grouping[]).splice(targetIndex, 0, {\n      columnName,\n    });\n  }\n\n  return nextGrouping;\n};\n\nexport const changeColumnGrouping: PureReducer<ColumnGroupingState, ChangeGroupingPayload> = (\n  { grouping, expandedGroups }, { columnName, groupIndex },\n) => {\n  const nextGrouping = applyColumnGrouping(grouping!, { columnName, groupIndex });\n\n  const ungroupedColumnIndex = grouping!.findIndex(\n    (group, index) => !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName,\n  );\n  if (ungroupedColumnIndex === -1) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  const filteredExpandedGroups = expandedGroups!.filter(\n    group => group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex,\n  );\n  if (filteredExpandedGroups.length === expandedGroups!.length) {\n    return {\n      grouping: nextGrouping,\n    };\n  }\n\n  return {\n    grouping: nextGrouping,\n    expandedGroups: filteredExpandedGroups,\n  };\n};\n\nexport const toggleExpandedGroups: PureReducer<ColumnGroupingState, ToggleGroupPayload> = (\n  state, { groupKey },\n) => {\n  const expandedGroups = slice(state.expandedGroups);\n  const groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups,\n  };\n};\n\nexport const draftColumnGrouping: PureReducer<\n  Getters, ChangeGroupingPayload, DraftGroupingState\n> = (\n  { grouping, draftGrouping },\n  { columnName, groupIndex },\n) => ({\n  draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName, groupIndex }),\n});\n\nexport const cancelColumnGroupingDraft = () => ({\n  draftGrouping: null,\n});\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Grouping, Sorting, GroupIndex } from '../../types';\n\nexport const adjustSortIndex: PureComputed<[GroupIndex, Grouping[], Sorting[]]> = (\n  groupingIndex, grouping, sorting,\n) => Math.max(\n  grouping.slice(0, groupingIndex).reduce(\n    (acc, columnGrouping) => {\n      const columnSortingIndex = sorting.findIndex(\n        columnSorting => columnSorting.columnName === columnGrouping.columnName,\n      );\n      return (columnSortingIndex === -1 ? acc - 1 : acc);\n    },\n    groupingIndex,\n  ),\n  0,\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GROUP_KEY_SEPARATOR } from '../grouping-state/constants';\nimport {\n  GRID_GROUP_TYPE,\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n  GRID_GROUP_COLLAPSED_ROWS,\n} from './constants';\nimport {\n  Grouping, GroupKey, Row, GetCollapsedRowsFn, IsSpecificRowFn, GroupedRowsFn,\n} from '../../types';\n\nexport const groupRowChecker: IsSpecificRowFn = row => row[GRID_GROUP_CHECK];\n\nexport const groupRowLevelKeyGetter = (row: Row) => (row ? row[GRID_GROUP_LEVEL_KEY] : undefined);\n\nconst defaultColumnCriteria = (value: any) => ({\n  value,\n  key: String(value),\n});\n\nexport const groupedRows: GroupedRowsFn = (\n  rows, grouping, getCellValue, getColumnCriteria, keyPrefix = '',\n) => {\n  if (!grouping.length) return rows;\n\n  const { columnName } = grouping[0];\n  const groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))\n    || defaultColumnCriteria;\n\n  const groups = new Map();\n  rows.forEach((row) => {\n    const rawValue = getCellValue(row, columnName);\n    const { key, value } = groupCriteria(rawValue, row);\n    const sameKeyItems = groups.get(key);\n\n    if (!sameKeyItems) {\n      const groupingValue = value === rawValue ? value : value || key;\n      groups.set(key, [groupingValue, key, [row]]);\n    } else {\n      sameKeyItems[2].push(row);\n    }\n  });\n\n  const groupedBy = grouping[0].columnName;\n  const nestedGrouping = grouping.slice(1);\n  return [...groups.values()]\n    .reduce((acc, [value, key, items]) => {\n      const compoundKey = `${keyPrefix}${key}`;\n      acc.push({\n        groupedBy,\n        compoundKey,\n        key,\n        value,\n        [GRID_GROUP_CHECK]: true,\n        [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      });\n      acc.push(...groupedRows(\n        items,\n        nestedGrouping,\n        getCellValue,\n        getColumnCriteria,\n        `${compoundKey}${GROUP_KEY_SEPARATOR}`,\n      ));\n      return acc;\n    }, []);\n};\n\nexport const expandedGroupRows: PureComputed<[Row[], Grouping[], GroupKey[], boolean]> = (\n  rows,\n  grouping,\n  expandedGroups,\n  isExporting,\n) => {\n  if (!grouping.length) return rows;\n\n  const groupingColumnNames = grouping.map(columnGrouping => columnGrouping.columnName);\n  const expandedGroupsSet = new Set(expandedGroups);\n  let currentGroupExpanded = true;\n  let currentGroupLevel = 0;\n\n  return rows.reduce((acc, row) => {\n    if (!row[GRID_GROUP_CHECK]) {\n      if (currentGroupExpanded) {\n        acc.push(row);\n      } else {\n        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);\n      }\n      return acc;\n    }\n\n    const groupLevel = groupingColumnNames.indexOf(row.groupedBy);\n    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {\n      return acc;\n    }\n\n    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;\n    currentGroupLevel = groupLevel;\n\n    if (currentGroupExpanded) {\n      acc.push(row);\n    } else {\n      acc.push({\n        ...row,\n        [GRID_GROUP_COLLAPSED_ROWS]: [],\n      });\n    }\n\n    return acc;\n  }, []);\n};\n\nexport const groupCollapsedRowsGetter: PureComputed<[GetCollapsedRowsFn]> =\n  getCollapsedRows => row => (\n  row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GROUP_KEY_SEPARATOR } from '../grouping-state/constants';\nimport {\n  GRID_GROUP_TYPE,\n  GRID_GROUP_CHECK,\n  GRID_GROUP_LEVEL_KEY,\n} from '../integrated-grouping/constants';\nimport { GetRowIdFn, Row, RowId, CustomGroupedRowsFn } from '../../types';\n\nexport const customGroupedRows: CustomGroupedRowsFn = (\n  currentRows, grouping, getChildGroups, rootRows = currentRows, keyPrefix = '',\n) => {\n  if (!currentRows || !currentRows.length) return [];\n  if (!grouping.length) return currentRows;\n\n  const groupedBy = grouping[0].columnName;\n  const nestedGrouping = grouping.slice(1);\n  return getChildGroups(currentRows as any[], grouping[0], rootRows as any[])\n    .reduce((acc, { key, value = key, childRows }) => {\n      const compoundKey = `${keyPrefix}${key}`;\n      acc.push({\n        groupedBy,\n        compoundKey,\n        key,\n        value,\n        [GRID_GROUP_CHECK]: true,\n        [GRID_GROUP_LEVEL_KEY]: `${GRID_GROUP_TYPE.toString()}_${groupedBy}`,\n      });\n      acc.push(...customGroupedRows(\n        childRows!,\n        nestedGrouping,\n        getChildGroups,\n        rootRows,\n        `${compoundKey}${GROUP_KEY_SEPARATOR}`,\n      ));\n      return acc;\n    }, [] as Row[]);\n};\n\nexport const customGroupingRowIdGetter: PureComputed<[GetRowIdFn, Row[]]> = (getRowId, rows) => {\n  const firstRow = rows.find(row => !row[GRID_GROUP_CHECK]);\n  if (!firstRow || getRowId(firstRow) !== undefined) {\n    return getRowId;\n  }\n\n  const map = new Map<Row, RowId>(rows\n    .filter(row => !row[GRID_GROUP_CHECK])\n    .map((row, rowIndex) => [row, rowIndex]) as [Row, RowId]);\n\n  return row => map.get(row)!;\n};\n","import { GroupingPanelItemsFn } from '../../types/';\n\nexport const groupingPanelItems: GroupingPanelItemsFn = (\n  columns, grouping, draftGrouping,\n) => {\n  const items = draftGrouping.map(({ columnName }) => ({\n    column: columns.find(c => c.name === columnName)!,\n    draft: !grouping.some(columnGrouping => columnGrouping.columnName === columnName),\n  }));\n\n  grouping.forEach(({ columnName }, index) => {\n    if (draftGrouping.some(columnGrouping => columnGrouping.columnName === columnName)) return;\n    items.splice(index, 0, {\n      column: columns.find(c => c.name === columnName)!,\n      draft: true,\n    });\n  });\n\n  return items;\n};\n","export const setCurrentPage = (prevPage: number, page: number) => page;\nexport const setPageSize = (prevPageSize: number, size: number) => size;\n","import { PureComputed } from '@devexpress/dx-core';\n\nexport const clamp: PureComputed<[number, number]> = (value, max) => (\n  Math.max(Math.min(value, max), 0)\n);\n","import { clamp } from './helpers';\nimport { Row, GetRowLevelKeyFn, CurrentPageFn } from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\n// tslint:disable-next-line:max-line-length\nconst PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';\n\nexport const paginatedRows: PureComputed<[Row[], number, number]> = (rows, pageSize, page) => (\n  pageSize\n    ? rows.slice(pageSize * page, pageSize * (page + 1))\n    : rows as Row[]\n);\n\nexport const rowsWithPageHeaders: PureComputed<[Row[], number, GetRowLevelKeyFn]> = (\n  rows, pageSize, getRowLevelKey,\n) => {\n  if (!pageSize || !getRowLevelKey) return rows as Row[];\n\n  let result = rows.slice();\n\n  let headerRows: any[] = [];\n  let currentIndex = 0;\n  while (result.length > currentIndex) {\n    const row = result[currentIndex];\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const headerIndex = headerRows.findIndex(headerRow => getRowLevelKey(headerRow) === levelKey);\n      // tslint:disable-next-line:prefer-conditional-expression\n      if (headerIndex === -1) {\n        headerRows = [...headerRows, row];\n      } else {\n        headerRows = [...headerRows.slice(0, headerIndex), row];\n      }\n      if (headerRows.length >= pageSize) {\n        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);\n      }\n    }\n    const indexInPage = currentIndex % pageSize;\n    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {\n      result = [\n        ...result.slice(0, currentIndex),\n        headerRows[indexInPage],\n        ...result.slice(currentIndex),\n      ];\n    }\n    currentIndex += 1;\n  }\n\n  return result;\n};\n\nexport const rowCount = (rows: Row[]) => rows.length;\n\nexport const pageCount: PureComputed<[number, number]> = (count, pageSize) => (\n  pageSize ? Math.ceil(count / pageSize) : 1\n);\n\nexport const currentPage: CurrentPageFn = (\n  page, totalCount, pageSize, setCurrentPage,\n) => {\n  const totalPages = pageCount(totalCount, pageSize);\n  const adjustedCurrentPage = clamp(page, totalPages - 1);\n  if (page !== adjustedCurrentPage) {\n    setTimeout(() => setCurrentPage(adjustedCurrentPage));\n  }\n  return adjustedCurrentPage;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { NthRowOnPageFn } from '../../types';\n\nexport const firstRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalCount) => {\n  if (totalCount === 0) {\n    return 0;\n  }\n  return pageSize ? (currentPage * pageSize) + 1 : 1;\n};\n\nexport const lastRowOnPage: NthRowOnPageFn = (currentPage, pageSize, totalRowCount) => {\n  let result = totalRowCount;\n  if (pageSize) {\n    const index = (currentPage + 1) * pageSize;\n    result = index > totalRowCount ? totalRowCount : index;\n  }\n\n  return result;\n};\n\nexport const calculateStartPage: PureComputed<[number, number, number]> = (\n  currentPage, maxButtonCount, totalPageCount,\n) => (\n  Math.max(\n    Math.min(\n    currentPage - Math.floor(maxButtonCount / 2),\n      (totalPageCount - maxButtonCount) + 1,\n    ),\n    1,\n  )\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId } from '../types';\n\nexport const toggle: PureComputed<[RowId[], RowId[], boolean?]> = (\n  source, items, state?,\n) => {\n  const itemsSet = new Set(items);\n\n  let sourceState: any = state;\n  if (sourceState === undefined) {\n    const availableSelection = source.filter(item => itemsSet.has(item));\n    sourceState = availableSelection.length !== itemsSet.size;\n  }\n\n  if (sourceState) {\n    const sourceSet = new Set(source);\n    return [\n      ...source,\n      ...items.filter(item => !sourceSet.has(item)),\n    ];\n  }\n\n  return source.filter(item => !itemsSet.has(item));\n};\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowsFieldReducer } from '../../types';\n\nexport const toggleSelection: ToggleRowsFieldReducer = (\n  selection, { rowIds, state },\n) => toggle(selection, rowIds, state);\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  RowsWithSelection, UnwrapRowsComputed, RowId, RowsWithAvailableToSelectFn,\n} from '../../types';\n\ntype RowsSelectedFn = PureComputed<[RowsWithSelection, RowId[]], boolean>;\n\nexport const rowsWithAvailableToSelect: RowsWithAvailableToSelectFn = (\n  rows, getRowId, isGroupRow,\n) => {\n  let dataRows = rows;\n  if (isGroupRow) {\n    dataRows = dataRows.filter(row => !isGroupRow(row));\n  }\n  return { rows, availableToSelect: dataRows.map(row => getRowId(row)) };\n};\n\nexport const someSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return availableToSelect.length !== 0 && selectionSet.size !== 0\n    && availableToSelect.some(elem => selectionSet.has(elem))\n    && availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const allSelected: RowsSelectedFn = ({ availableToSelect }, selection) => {\n  const selectionSet = new Set(selection);\n\n  return selectionSet.size !== 0 && availableToSelect.length !== 0\n    && !availableToSelect.some(elem => !selectionSet.has(elem));\n};\n\nexport const unwrapSelectedRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { PureReducer } from '@devexpress/dx-core';\nimport { RowId, Row, RowIdsPayload, RowPayload, RowChangePayload,\n  RowChanges, EditingCell, EditingCellsPayload,\n} from '../../types';\n\nexport const startEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => [...prevEditingRowIds, ...rowIds];\n\nexport const stopEditRows: PureReducer<RowId[], RowIdsPayload> = (\n  prevEditingRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return prevEditingRowIds.filter(id => !rowIdSet.has(id));\n};\n\nexport const startEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => [...prevEditingCells, ...editingCells];\n\nexport const stopEditCells: PureReducer<EditingCell[], EditingCellsPayload> = (\n  prevEditingCells, { editingCells },\n) => {\n  return prevEditingCells.filter(({ rowId, columnName }) => (\n    !editingCells.some(({ rowId: currentRowId, columnName: currentColumnName }) => (\n      currentRowId === rowId && currentColumnName === columnName\n    ))\n  ));\n};\n\nexport const addRow: PureReducer<Row[], RowPayload> = (\n  addedRows, { row } = { row: {} },\n) => [...addedRows, row];\n\nexport const changeAddedRow: PureReducer<Row[], RowChangePayload> = (\n  addedRows, { rowId, change },\n) => {\n  const result = addedRows.slice();\n  result[rowId] = { ...result[rowId], ...change };\n  return result;\n};\n\nexport const cancelAddedRows: PureReducer<Row[], RowIdsPayload> = (addedRows, { rowIds }) => {\n  const result: Row[] = [];\n  const indexSet = new Set(rowIds);\n  addedRows.forEach((row, index) => {\n    if (!indexSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nexport const changeRow: PureReducer<RowChanges, RowChangePayload> = (\n  prevRowChanges, { rowId, change },\n) => {\n  const prevChange = prevRowChanges[rowId] || {};\n  return {\n    ...prevRowChanges,\n    [rowId]: {\n      ...prevChange,\n      ...change,\n    },\n  };\n};\n\nexport const cancelChanges: PureReducer<RowChanges, RowIdsPayload> = (\n  prevRowChanges, { rowIds },\n) => {\n  const result = { ...prevRowChanges };\n  rowIds.forEach((rowId) => {\n    delete result[rowId];\n  });\n  return result;\n};\n\nexport const deleteRows: PureReducer<RowId[], RowIdsPayload> = (deletedRowIds, { rowIds }) => [\n  ...deletedRowIds, ...rowIds,\n];\n\nexport const cancelDeletedRows: PureReducer<RowId[], RowIdsPayload> = (\n  deletedRowIds, { rowIds },\n) => {\n  const rowIdSet = new Set(rowIds);\n  return deletedRowIds.filter(rowId => !rowIdSet.has(rowId));\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  EditingColumnExtension, CreateRowChangeFn, Row, RowId, RowChanges,\n} from '../../types';\n\nexport const changedRowsByIds: PureComputed<\n  [any, RowId[]], RowChanges\n> = (changes, rowIds) => {\n  const result = {};\n  rowIds.forEach((rowId) => {\n    result[rowId] = changes[rowId];\n  });\n  return result;\n};\n\nexport const addedRowsByIds: PureComputed<[Row[], RowId[]]> = (addedRows, rowIds) => {\n  const rowIdSet = new Set(rowIds);\n  const result: Row[] = [];\n  addedRows.forEach((row, index) => {\n    if (rowIdSet.has(index)) {\n      result.push(row);\n    }\n  });\n  return result;\n};\n\nconst defaultCreateRowChange: CreateRowChangeFn = (row, value, columnName) => (\n  { [columnName]: value }\n);\nexport const createRowChangeGetter: PureComputed<\n  [CreateRowChangeFn?, EditingColumnExtension[]?], CreateRowChangeFn\n> = (\n  createRowChange = defaultCreateRowChange,\n  columnExtensions = [],\n) => {\n  const map = columnExtensions.reduce((acc, columnExtension) => {\n    if (columnExtension.createRowChange) {\n      acc[columnExtension.columnName] = columnExtension.createRowChange;\n    }\n    return acc;\n  }, {});\n\n  return (row, value, columnName) => {\n    if (map[columnName]) {\n      return map[columnName](row, value, columnName);\n    }\n    return createRowChange(row, value, columnName);\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { RowId, RowChanges } from '../../types';\n\nexport const getRowChange: PureComputed<[RowChanges, RowId], any> = (\n  rowChanges, rowId,\n) => rowChanges[rowId] || {};\n","export const TABLE_REORDERING_TYPE = Symbol('reordering');\n","import { PureReducer, slice } from '@devexpress/dx-core';\nimport { ColumnOrder, ChangeColumnOrderPayload } from '../../types';\n\nexport const changeColumnOrder: PureReducer<ColumnOrder, ChangeColumnOrderPayload> = (\n  order, { sourceColumnName, targetColumnName },\n) => {\n  const sourceColumnIndex = order.indexOf(sourceColumnName);\n  const targetColumnIndex = order.indexOf(targetColumnName);\n  const newOrder = slice(order);\n\n  newOrder.splice(sourceColumnIndex, 1);\n  newOrder.splice(targetColumnIndex, 0, sourceColumnName);\n  return newOrder;\n};\n","export const TABLE_DATA_TYPE = Symbol('data');\nexport const TABLE_NODATA_TYPE = Symbol('nodata');\nexport const TABLE_FLEX_TYPE = Symbol('flex');\n","import { PureComputed, slice } from '@devexpress/dx-core';\nimport mergeSort from '../../utils/merge-sort';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_REORDERING_TYPE } from './constants';\nimport { OrderedColumnsComputed, DraftOrderComputed, TableRow } from '../../types';\n\nexport const orderedColumns: OrderedColumnsComputed = (\n  tableColumns = [], order,\n) => mergeSort(tableColumns, (a, b) => {\n  if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE) return 0;\n\n  const aPos = order.indexOf(a.column.name);\n  const bPos = order.indexOf(b.column.name);\n  return aPos - bPos;\n});\n\nexport const tableHeaderRowsWithReordering: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  {\n    key: TABLE_REORDERING_TYPE.toString(),\n    type: TABLE_REORDERING_TYPE,\n    height: 0,\n  },\n];\n\nexport const draftOrder: DraftOrderComputed = (order, sourceColumnIndex, targetColumnIndex) => {\n  if (sourceColumnIndex === -1\n    || targetColumnIndex === -1\n    || sourceColumnIndex === targetColumnIndex) {\n    return order;\n  }\n\n  const result = slice(order);\n  const sourceColumn = order[sourceColumnIndex];\n  result.splice(sourceColumnIndex, 1);\n  result.splice(targetColumnIndex, 0, sourceColumn);\n\n  return result;\n};\n","import { ColumnSizesFn, ValidValueFn, ConvertWidthFn, ColumnWidthFn } from '../../types';\n\nconst getColumnWidth: ColumnWidthFn = (\n  columnWidths, name, {\n    columnName, cachedWidths, shift, minColumnWidth, maxColumnWidth, columnExtensions = [],\n}) => {\n  const change = name === columnName ? shift : -shift;\n  const column  = columnWidths.find(elem => elem.columnName === name)!;\n  const extension = columnExtensions.find(elem => elem.columnName === name);\n  const width = typeof column.width === 'number'\n    ? column.width\n    : cachedWidths[name];\n  const minWidth = extension && extension.minWidth! >= 0\n    ? extension.minWidth\n    : minColumnWidth;\n  const maxWidth = extension && extension.maxWidth! >= 0\n    ? extension.maxWidth\n    : maxColumnWidth;\n  const size = Math.max(\n    minWidth!,\n    Math.min(width + change, maxWidth!),\n  );\n\n  return ({ width, size });\n};\n\nexport const getColumnSizes: ColumnSizesFn = (\n  columnWidths, payload) => {\n  const { columnName, nextColumnName, resizingMode, shift } = payload;\n  const { width, size } = getColumnWidth(columnWidths, columnName, payload);\n\n  if (resizingMode === 'nextColumn') {\n    const { width: nextWidth, size: nextSize } = getColumnWidth(\n      columnWidths, nextColumnName, payload,\n    );\n\n    if (size + nextSize !== width + nextWidth) {\n      const moreThanLimit = size + nextSize > width + nextWidth;\n      const columnExpand = shift > 0;\n      if (moreThanLimit !== columnExpand) {\n        return { size, nextSize: width + nextWidth - size };\n      }\n      return { size: width + nextWidth - nextSize, nextSize };\n    }\n    return { size, nextSize };\n  }\n\n  return { size };\n};\n\nexport const isValidValue: ValidValueFn = (value, validUnits) => {\n  const numb = parseInt(value, 10);\n  const unit = numb ? value.substr(numb.toString().length) : value;\n  const sizeIsAuto = isNaN(numb) && unit === 'auto';\n  const sizeIsValid = numb >= 0 && validUnits.some(validUnit => validUnit === unit);\n  return sizeIsAuto || sizeIsValid;\n};\n\nexport const convertWidth: ConvertWidthFn = (value) => {\n  if (typeof value === 'string') {\n    const numb = parseInt(value, 10);\n    if (value.substr(numb.toString().length).length > 0) {\n      return value;\n    }\n    return numb;\n  }\n  return value;\n};\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn, SpecifyWidthsFn, TableColumnsWithWidthFn, ErrorFn } from '../../types';\nimport { isValidValue, convertWidth } from './helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst NOT_FOR_WIDGET_UNITS = ['%'];\n/* tslint:disable max-line-length */\nconst COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';\n\nconst specifyWidths: SpecifyWidthsFn = (tableColumns, widths, resizingMode, onError) => {\n  if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {\n    onError();\n  }\n  if (!widths.length) return tableColumns;\n  return tableColumns\n    .reduce((acc, tableColumn) => {\n      if (tableColumn.type === TABLE_DATA_TYPE) {\n        const columnName = tableColumn.column!.name;\n        const column = widths.find(el => el.columnName === columnName);\n        const width = column && column.width;\n        if (typeof width !== 'number') {\n          if (width === undefined) {\n            onError();\n          } else if (!isValidValue(width, VALID_UNITS)) {\n            onError();\n          } else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {\n            onError();\n          }\n        } else if (width < 0) {\n          onError();\n        }\n        if (width === undefined) {\n          acc.push(tableColumn);\n        } else {\n          acc.push({ ...tableColumn, width: convertWidth(width) });\n        }\n      } else {\n        acc.push(tableColumn);\n      }\n      return acc;\n    }, [] as TableColumn[]);\n};\n\nexport const tableColumnsWithWidths: TableColumnsWithWidthFn = (\n  tableColumns, columnWidths, resizingMode,\n) => specifyWidths(tableColumns, columnWidths, resizingMode, throwError);\n\nexport const tableColumnsWithDraftWidths: TableColumnsWithWidthFn = (\n  tableColumns, draftColumnWidths, resizingMode,\n) => specifyWidths(tableColumns, draftColumnWidths, resizingMode, () => {});\n\nconst throwError: ErrorFn = () => {\n  throw new Error(COLUMN_RESIZING_ERROR);\n};\n","import { slice } from '@devexpress/dx-core';\nimport { ColumnWidthReducer } from '../../types';\nimport { getColumnSizes } from './helpers';\n\nexport const changeTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const nextColumnWidth = slice(columnWidths);\n  const index = nextColumnWidth.findIndex(elem => elem.columnName === columnName);\n  const nextIndex = nextColumnWidth.findIndex(elem => elem.columnName === nextColumnName);\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  nextColumnWidth.splice(index, 1, { columnName, width: size });\n  if (resizingMode === 'nextColumn') {\n    nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });\n  }\n  return {\n    columnWidths: nextColumnWidth,\n  };\n};\n\nexport const draftTableColumnWidth: ColumnWidthReducer = (state, payload) => {\n  const { columnWidths } = state;\n  const { columnName, nextColumnName, resizingMode } = payload;\n  const { size, nextSize } = getColumnSizes(columnWidths, payload);\n\n  if (resizingMode === 'nextColumn') {\n    return { draftColumnWidths: [\n      { columnName, width: size }, { columnName: nextColumnName, width: nextSize! },\n    ] };\n  }\n  return { draftColumnWidths: [{ columnName, width: size }] };\n};\n\nexport const cancelTableColumnWidthDraft = () => ({\n  draftColumnWidths: [],\n});\n","export const TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');\n","export const TABLE_ADDED_TYPE = Symbol('added');\nexport const TABLE_EDIT_TYPE = Symbol('edit');\n","export const TABLE_HEADING_TYPE = Symbol('heading');\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from '../table-edit-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { IsSpecificCellFn } from '../../types';\n\nexport const isHeadingEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\nexport const isEditCommandsTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE\n  || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_EDIT_COMMAND_TYPE } from './constants';\nimport { TableColumn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithEditing: PureComputed<[TableColumn[], number | string]> = (\n  tableColumns, width,\n) => [\n  { width: convertWidth(width),\n    key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE },\n  ...tableColumns];\n","import { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificRowFn, IsSpecificCellFn } from '../../types';\n\nexport const isEditTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)\n  && tableColumn.type === TABLE_DATA_TYPE;\nexport const isAddedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_ADDED_TYPE;\nexport const isEditTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_EDIT_TYPE;\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_ADDED_TYPE, TABLE_EDIT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRowsWithEditingFn } from '../../types';\n\nexport const tableRowsWithEditing: TableRowsWithEditingFn = (\n  tableRows, editingRowIds, addedRows, rowHeight,\n) => {\n  const rowIds = new Set(editingRowIds);\n  const editedTableRows = tableRows\n    .map(tableRow => (\n      tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId!)\n        ? {\n          ...tableRow,\n          type: TABLE_EDIT_TYPE,\n          height: rowHeight,\n        }\n        : tableRow\n    ));\n\n  const addedTableRows = addedRows\n    .map((row, rowIndex) => ({\n      row,\n      key: `${TABLE_ADDED_TYPE.toString()}_${rowIndex}`,\n      type: TABLE_ADDED_TYPE,\n      rowId: rowIndex,\n      height: rowHeight,\n    }));\n\n  return [\n    ...slice(addedTableRows).reverse(),\n    ...editedTableRows,\n  ];\n};\n","import { TableRowsWithEditingCellsFn, TableColumnsWithEditingCellsFn } from '../../types';\n\nexport const rowsWithEditingCells: TableRowsWithEditingCellsFn = (\n  tableBodyRows, editingCells,\n) => tableBodyRows.map((row) => {\n  const { rowId } = row;\n  if (rowId !== undefined && editingCells.some(elem => elem.rowId === rowId)) {\n    return {\n      ...row,\n      hasEditCell: true,\n    };\n  }\n  return row;\n});\n\nexport const columnsWithEditingCells: TableColumnsWithEditingCellsFn = (\n  tableColumns, editingCells,\n) => tableColumns.map((tableColumn) => {\n  const columnName = tableColumn.column ? tableColumn.column.name : undefined;\n  if (columnName !== undefined && editingCells.some(elem => elem.columnName === columnName)) {\n    return {\n      ...tableColumn,\n      hasEditCell: true,\n    };\n  }\n  return tableColumn;\n});\n","export const TABLE_FILTER_TYPE = Symbol('filter');\nexport const DEFAULT_FILTER_OPERATIONS = [\n  'contains',\n  'notContains',\n  'startsWith',\n  'endsWith',\n  'equal',\n  'notEqual',\n];\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE, DEFAULT_FILTER_OPERATIONS } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, FilterOperation, GetAvailableFilterOperationsFn,\n  GetSelectedFilterOperationFn,\n} from '../../types';\n\nexport const isFilterTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isFilterTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FILTER_TYPE;\n\nexport const getColumnFilterOperations: PureComputed<\n  [GetAvailableFilterOperationsFn, string],\n  FilterOperation[]\n> = (\n  getAvailableFilterOperations, columnName,\n) => (getAvailableFilterOperations && getAvailableFilterOperations(columnName))\n  || DEFAULT_FILTER_OPERATIONS;\n\nexport const isFilterValueEmpty = (value: any) => value === undefined || !String(value).length;\n\nexport const getSelectedFilterOperation: GetSelectedFilterOperationFn = (\n  filterOperations, columnName, columnFilter, columnFilterOperations,\n) => {\n  if (columnFilter && columnFilter.operation) {\n    return columnFilter.operation;\n  }\n  if (filterOperations[columnName]) {\n    return filterOperations[columnName];\n  }\n  return columnFilterOperations[0];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_FILTER_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableHeaderRowsWithFilter: PureComputed<[TableRow[], number]> = (\n  headerRows, rowHeight,\n) => [\n  ...headerRows,\n  { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }];\n","export const TABLE_GROUP_TYPE = Symbol('group');\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, TableRow, IsSpecificRowFn,\n  TableColumnsWithDraftGroupingFn,\n  TableColumnsWithGroupingFn,\n  GroupCellColSpanGetter,\n  GroupSummaryChainsFn,\n  SummaryItem,\n} from '../../types';\n\nconst tableColumnsWithDraftGrouping: TableColumnsWithDraftGroupingFn = (\n  tableColumns, grouping, draftGrouping, showColumnWhenGrouped,\n) => tableColumns\n  .reduce((acc, tableColumn) => {\n    if (tableColumn.type !== TABLE_DATA_TYPE) {\n      acc.push(tableColumn);\n      return acc;\n    }\n\n    const columnName = tableColumn.column && tableColumn.column.name || '';\n    const columnGroupingExists = grouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n    const columnDraftGroupingExists = draftGrouping\n      .some(columnGrouping => columnGrouping.columnName === columnName);\n\n    if ((!columnGroupingExists && !columnDraftGroupingExists)\n        || showColumnWhenGrouped(columnName)) {\n      acc.push(tableColumn);\n    } else if ((!columnGroupingExists && columnDraftGroupingExists)\n        || (columnGroupingExists && !columnDraftGroupingExists)) {\n      acc.push({\n        ...tableColumn,\n        draft: true,\n      });\n    }\n    return acc;\n  // tslint:disable-next-line: prefer-array-literal\n  }, [] as Array<TableColumn & { draft?: boolean }>);\n\nexport const tableColumnsWithGrouping: TableColumnsWithGroupingFn = (\n  columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped,\n) => [\n  ...grouping.map((columnGrouping) => {\n    const groupedColumn = columns.find(column => column.name === columnGrouping.columnName);\n    return {\n      key: `${TABLE_GROUP_TYPE.toString()}_${groupedColumn!.name}`,\n      type: TABLE_GROUP_TYPE,\n      column: groupedColumn,\n      width: indentColumnWidth,\n    };\n  }),\n  ...tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped),\n];\n\nexport const tableRowsWithGrouping: PureComputed<[TableRow[], IsSpecificRowFn]> = (\n  tableRows, isGroupRow,\n) => tableRows.map((tableRow) => {\n  if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {\n    return tableRow;\n  }\n  return {\n    ...tableRow,\n    key: `${TABLE_GROUP_TYPE.toString()}_${tableRow.row.compoundKey}`,\n    type: TABLE_GROUP_TYPE,\n  };\n});\n\nconst isRowLevelSummary: PureComputed<[SummaryItem[], string], boolean> = (\n  groupSummaryItems, colName,\n) => (\n  groupSummaryItems.some((item: any) => (\n    !item.showInGroupFooter && item.alignByColumn && item.columnName === colName),\n  )\n);\n\nconst groupSummaryChains: GroupSummaryChainsFn = (tableRow, tableColumns, groupSummaryItems) => {\n  let captionStarted = false;\n  return tableColumns\n    .reduce((acc, col) => {\n      const colName = (col.column && col.column.name) as string;\n      const isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy === colName;\n      const isIndentColumn = col.type === TABLE_GROUP_TYPE\n        && tableRow.row.groupedBy !== colName && !captionStarted;\n\n      if (isStartOfGroupCaption) {\n        captionStarted = true;\n      }\n\n      if (isStartOfGroupCaption || isIndentColumn) {\n        acc.push([colName]);\n      } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {\n        acc.push([colName]);\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(colName);\n      }\n      return acc;\n    }, [[]] as string[][]);\n};\n\nexport const tableGroupCellColSpanGetter: GroupCellColSpanGetter = (\n  getTableCellColSpan, groupSummaryItems,\n) => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n\n  if (tableRow.type === TABLE_GROUP_TYPE) {\n    const chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems);\n    const chain = chains.find(ch => ch[0] === (tableColumn.column && tableColumn.column.name));\n    if (chain) {\n      return chain.length;\n    }\n  }\n  return getTableCellColSpan(params);\n};\n","import { TABLE_HEADING_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, HeaderColumnChain,\n  SplitHeaderColumnChainsFn, FindChainByColumnIndexFn,\n  GenerateChainsFn,\n  NextColumnNameFn,\n  GetNextColumnNameFn,\n} from '../../types';\n\nexport const isHeadingTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;\n\nexport const isHeadingTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_HEADING_TYPE\n);\n\nexport const findChainByColumnIndex: FindChainByColumnIndexFn = (chains, columnIndex) => (\n  chains.find(chain => (\n    chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length\n  ))!\n);\n\nexport const splitHeaderColumnChains: SplitHeaderColumnChainsFn = (\n  tableColumnChains, tableColumns, shouldSplitChain, extendChainProps,\n) => (\n  tableColumnChains.map((row, rowIndex) => row\n    .reduce((acc, chain) => {\n      let currentChain: any = null;\n      chain.columns.forEach((col) => {\n        const column = tableColumns.find(c => c.key === col.key);\n        const isNewGroup = shouldSplitChain(currentChain, column!, rowIndex);\n\n        if (isNewGroup) {\n          const start = currentChain\n            ? (currentChain.start + currentChain.columns.length)\n            : chain.start;\n\n          acc.push({\n            ...chain,\n            ...extendChainProps(column!),\n            start,\n            columns: [],\n          });\n          currentChain = acc[acc.length - 1];\n        }\n\n        currentChain.columns.push(column);\n      });\n\n      return acc;\n    }, [] as HeaderColumnChain[]))\n);\n\nexport const generateSimpleChains: GenerateChainsFn = (rows, columns) => (\n  rows.map(() => ([{\n    columns,\n    start: 0,\n  }]))\n);\n\nconst nextColumnName: NextColumnNameFn = (tableColumns , index) => {\n  const isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;\n  return isNextColumnHasName\n    ? tableColumns[index + 1].column!.name\n    : undefined;\n};\n\nexport const getNextColumnName: GetNextColumnNameFn = (tableColumns, columnName) => {\n  const index = tableColumns.findIndex(elem =>\n    elem.column && elem.column.name === columnName,\n  );\n  return index >= 0\n    ? nextColumnName(tableColumns, index)\n    : undefined;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_HEADING_TYPE } from './constants';\nimport { TableRow } from '../../types';\n\nexport const tableRowsWithHeading: PureComputed<[TableRow[]]> = headerRows => [\n  { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE },\n  ...headerRows];\n","export const TABLE_BAND_TYPE = Symbol('band');\nexport const BAND_GROUP_CELL = 'bandGroupCell';\nexport const BAND_HEADER_CELL = 'bandHeaderCell';\nexport const BAND_EMPTY_CELL = 'bandEmptyCell';\nexport const BAND_DUPLICATE_RENDER = 'bandDuplicateRender';\nexport const BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';\n","import {\n  TABLE_BAND_TYPE, BAND_GROUP_CELL, BAND_HEADER_CELL, BAND_EMPTY_CELL,\n  BAND_DUPLICATE_RENDER, BAND_FILL_LEVEL_CELL,\n} from './constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  IsSpecificRowFn, GetColumnBandMetaFn, GetBandComponentFn,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\n\nexport const isBandedTableRow: IsSpecificRowFn = tableRow => (tableRow.type === TABLE_BAND_TYPE);\nexport const isBandedOrHeaderRow: IsSpecificRowFn = tableRow => isBandedTableRow(tableRow)\n  || tableRow.type === TABLE_HEADING_TYPE;\nexport const isNoDataColumn = (columnType: symbol) => columnType !== TABLE_DATA_TYPE;\n\nexport const getColumnMeta: GetColumnBandMetaFn = (\n  columnName, bands, tableRowLevel, key = '',\n  level = 0, title = null, result = null,\n) => bands.reduce((acc, band) => {\n  if (band.columnName === columnName) {\n    return { ...acc, title, level, key };\n  }\n  if (band.children !== undefined) {\n    const rowLevelPassed = level > tableRowLevel;\n    const bandTitle = rowLevelPassed ? title : band.title;\n    const bandKey = rowLevelPassed ? key : `${key}_${bandTitle}`;\n\n    return getColumnMeta(\n      columnName,\n      band.children,\n      tableRowLevel,\n      bandKey,\n      level + 1,\n      bandTitle,\n      acc,\n    );\n  }\n  return acc;\n}, result || { level, title, key: title });\n\n// TODO: refactor\nexport const getBandComponent: GetBandComponentFn = (\n  { tableColumn: currentTableColumn, tableRow, rowSpan },\n  tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains,\n  columnVisibleIntervals, bandLevelsVisibility,\n) => {\n  if (rowSpan) return { type: BAND_DUPLICATE_RENDER, payload: null };\n\n  const maxLevel = tableHeaderRows.filter(column => column.type === TABLE_BAND_TYPE).length + 1;\n  const { level } = tableRow;\n  const currentRowLevel = level === undefined\n    ? maxLevel - 1 : level;\n  const currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE\n    ? getColumnMeta(currentTableColumn.column!.name, columnBands, currentRowLevel)\n    : { level: 0, title: '' };\n\n  const currentColumnIndex = tableColumns\n    .findIndex(column => column.key === currentTableColumn.key);\n\n  const levelsCount = bandLevelsVisibility.length;\n  const visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;\n\n  if (currentColumnMeta.level < currentRowLevel) {\n    const shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount\n      && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;\n\n    if (shouldFillLevel) {\n      return { type: BAND_FILL_LEVEL_CELL, payload: null };\n    }\n    return { type: BAND_EMPTY_CELL, payload: null };\n  }\n\n  const previousTableColumn = tableColumns[currentColumnIndex - 1];\n  let beforeBorder = false;\n  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE\n    && isNoDataColumn(previousTableColumn.type)) {\n    beforeBorder = true;\n  }\n\n  if (currentColumnMeta.level === currentRowLevel) {\n    if (currentTableColumn.type === TABLE_STUB_TYPE) {\n      const cellRowSpan = visibleLevelsCount < levelsCount\n        ? visibleLevelsCount || 1\n        : maxLevel;\n\n      return {\n        type: BAND_FILL_LEVEL_CELL,\n        payload: {\n          rowSpan: cellRowSpan,\n        },\n      };\n    }\n\n    return {\n      type: BAND_HEADER_CELL,\n      payload: {\n        tableRow: tableHeaderRows.find(row => row.type === TABLE_HEADING_TYPE),\n        rowSpan: maxLevel - currentRowLevel,\n        ...beforeBorder && { beforeBorder },\n      },\n    };\n  }\n\n  const currentColumnChain = findChainByColumnIndex(\n    tableHeaderColumnChains[currentRowLevel],\n    currentColumnIndex,\n  );\n\n  const columnVisibleBoundary = columnVisibleIntervals.find(([start, end]) => (\n    start <= currentColumnIndex && currentColumnIndex <= end\n  ))!;\n  const bandStart = Math.max(columnVisibleBoundary[0], currentColumnChain.start);\n  if (bandStart < currentColumnIndex) {\n    return { type: null, payload: null };\n  }\n\n  const bandEnd = Math.min(\n    columnVisibleBoundary[1] + 1,\n    currentColumnChain.start + currentColumnChain.columns.length,\n  );\n\n  return {\n    type: BAND_GROUP_CELL,\n    payload: {\n      colSpan: bandEnd - bandStart,\n      value: currentColumnMeta.title!,\n      column: currentColumnMeta,\n      ...beforeBorder && { beforeBorder },\n    },\n  };\n};\n","import { intervalUtil } from './utils';\nimport {\n  VirtualRows, Row, MergeRowsFn, CalculateRequestedRangeFn,\n  Interval, GridViewport, GetRequestMeta, CorrectRangeFn,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nexport const emptyVirtualRows: VirtualRows = {\n  skip: Number.POSITIVE_INFINITY,\n  rows: [],\n};\n\nconst pluckSubarray: PureComputed<[Row[], ...number[]]> = (source, sourceStart, left, right) => (\n  source.slice(left - sourceStart, right - sourceStart)\n);\n\nexport const mergeRows: MergeRowsFn = (\n  rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart,\n) => {\n  const breakpoints = [\n    rowsInterval.start, rowsInterval.end,\n    cacheInterval.start, cacheInterval.end,\n  ]\n    .filter(i => 0 <= i && i < Number.POSITIVE_INFINITY)\n    .sort((a, b) => a - b);\n\n  let result: Row[] = [];\n  if (breakpoints.length > 1) {\n    for (let i = 0; i < breakpoints.length - 1; i += 1) {\n      const left = breakpoints[i];\n      const right = breakpoints[i + 1];\n      const chunk = rowsInterval.start <= left && right <= rowsInterval.end\n        ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority\n        : pluckSubarray(cacheRows, cacheStart, left, right);\n\n      result = result.concat(chunk);\n    }\n  }\n\n  return {\n    skip: breakpoints[0],\n    rows: result,\n  };\n};\n\nconst correctRequestedRange: CorrectRangeFn = (calculatedRange, referenceIndex, pageSize) => {\n  const { start, end } = calculatedRange;\n\n  if (start - referenceIndex > pageSize / 2) {\n    return { start: start - pageSize, end: end - pageSize };\n  }\n  return { start, end };\n};\n\nexport const calculateRequestedRange: CalculateRequestedRangeFn = (\n  virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll,\n) => {\n  const loadedInterval = intervalUtil.getRowsInterval(virtualRows);\n  const isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;\n  if (isAdjacentPage) {\n    const calculatedRange = intervalUtil.difference(newRange, loadedInterval);\n    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {\n      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);\n    }\n    return calculatedRange;\n  }\n\n  // load 3 pages at once because a missing page will be loaded anyway\n  return newRange;\n};\n\nexport const rowToPageIndex: PureComputed<[number, number]> = (\n  rowIndex, pageSize,\n) => Math.floor(rowIndex / pageSize);\n\nexport const recalculateBounds: PureComputed<[number, number, number], Interval> = (\n  middleIndex, pageSize, totalCount,\n) => {\n  const currentPageIndex = rowToPageIndex(middleIndex, pageSize);\n\n  const prevPageIndex = currentPageIndex - 1;\n  const nextPageIndex = currentPageIndex + 2;\n  const start = Math.max(0, prevPageIndex * pageSize);\n  const end = Math.min(nextPageIndex * pageSize, totalCount);\n\n  return {\n    start,\n    end,\n  };\n};\n\nexport const trimRowsToInterval: PureComputed<[VirtualRows, Interval]> = (\n  virtualRows, targetInterval,\n) => {\n  const rowsInterval = intervalUtil.getRowsInterval(virtualRows);\n  const intersection = intervalUtil.intersect(rowsInterval, targetInterval);\n  if (intervalUtil.empty === intersection) {\n    return emptyVirtualRows;\n  }\n\n  const rows = pluckSubarray(\n    virtualRows.rows, virtualRows.skip, intersection.start, intersection.end,\n  );\n\n  return {\n    rows,\n    skip: intersection.start,\n  };\n};\n\nexport const getAvailableRowCount: PureComputed<[boolean, number, number, number], number> = (\n  isInfiniteScroll, newRowCount, lastRowCount, totalRowCount,\n) => {\n  return (isInfiniteScroll\n    ? Math.min(\n        Math.max(newRowCount, lastRowCount),\n        totalRowCount)\n    : totalRowCount\n  );\n};\n\nexport const getForceReloadInterval: PureComputed<[VirtualRows, number, number], Interval> = (\n  virtualRows, pageSize, totalRowCount,\n) => {\n  const { start, end: intervalEnd } = intervalUtil.getRowsInterval(virtualRows);\n  const end = Math.min(\n    Math.max(start + pageSize * 2, intervalEnd),\n    Math.max(start + pageSize * 2, totalRowCount),\n  );\n  return {\n    start,\n    end,\n  };\n};\n\nexport const getRequestMeta: GetRequestMeta = (\n  referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll,\n) => {\n  const actualBounds = forceReload\n    ? getForceReloadInterval(virtualRows, pageSize!, totalRowCount)\n    : recalculateBounds(referenceIndex, pageSize!, totalRowCount);\n  const requestedRange = forceReload\n    ? actualBounds\n    : calculateRequestedRange(\n        virtualRows, actualBounds, pageSize!, referenceIndex, isInfiniteScroll,\n      );\n\n  return { requestedRange, actualBounds };\n};\n\nexport const needFetchMorePages: PureComputed<[VirtualRows, number, number], boolean> = (\n  virtualRows, referenceIndex,  pageSize,\n) => {\n  const { start, end } = intervalUtil.getRowsInterval(virtualRows);\n  const loadCount = end - start;\n  const topTriggerIndex = start > 0 ? start + pageSize! : 0;\n  const bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize! * 1.5);\n\n  if (loadCount <= 0) {\n    return false;\n  }\n\n  return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);\n};\n\nexport const getReferenceIndex: PureComputed<[GridViewport], number> = (\n  { rows: [top, bottom] },\n) => (\n  (top + bottom) / 2\n);\n\nexport const shouldSendRequest: PureComputed<[Interval, number], boolean> = (\n  { start, end }, requestedPageIndex,\n) => {\n  const newPageIndex = start;\n  const loadCount = (end - start);\n  return newPageIndex !== requestedPageIndex && loadCount > 0;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { emptyVirtualRows } from './helpers';\nimport { Interval, VirtualRows } from '../../types';\n\nconst empty: Interval = {\n  start: Number.POSITIVE_INFINITY,\n  end: Number.NEGATIVE_INFINITY,\n};\n\nconst getRowsInterval: PureComputed<[VirtualRows], Interval> = r => (\n  r === emptyVirtualRows\n    ? empty\n    : {\n      start: r.skip,\n      end: r.skip + r.rows.length,\n    }\n);\n\nconst getLength = (a: Interval) => a.end - a.start;\n\nconst intersect = (a: Interval, b: Interval) => {\n  if (a.end < b.start || b.end < a.start) {\n    return empty;\n  }\n\n  return {\n    start: Math.max(a.start, b.start),\n    end: Math.min(a.end, b.end),\n  };\n};\n\nconst difference = (a: Interval, b: Interval) => {\n  if (empty === intervalUtil.intersect(a, b)) {\n    return a;\n  }\n\n  if (b.end < a.end) {\n    return {\n      start: b.end,\n      end: a.end,\n    };\n  }\n  if (a.start < b.start) {\n    return {\n      start: a.start,\n      end: b.start,\n    };\n  }\n  return empty;\n};\n\nexport const intervalUtil = {\n  empty,\n\n  getRowsInterval,\n  getLength,\n\n  intersect,\n  difference,\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_BAND_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { getColumnMeta } from './helpers';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  ColumnBands, GetHeaderColumnChainsFn, ShouldSplitChainFn,\n  GetMaxNestedLevelFn, TableRow, TableColumn, HeaderColumnChainRows,\n  BandLevels, BandColumnChainExtension, HeaderColumnChain, VisibleBoundary, GridViewport,\n} from '../../types';\nimport { intervalUtil } from '../virtual-table-state/utils';\n\nexport const tableRowsWithBands: PureComputed<\n  [TableRow[], ColumnBands[], TableColumn[]]\n> = (\n  tableHeaderRows, columnBands, tableColumns,\n) => {\n  const tableDataColumns = tableColumns.filter(column => column.type === TABLE_DATA_TYPE);\n  const getMaxNestedLevel: GetMaxNestedLevelFn = (bands, level = 0, result = null) => (\n    bands.reduce((acc, column) => {\n      if (column.children !== undefined) {\n        return getMaxNestedLevel(column.children, level + 1, acc);\n      }\n      const isDataColumn = tableDataColumns.findIndex(\n        dataColumn => !!dataColumn.column && dataColumn.column.name === column.columnName,\n      ) > -1;\n      if (level > acc.level && isDataColumn) {\n        return { ...acc, level };\n      }\n      return acc;\n    }, result || { level: 0 })\n  );\n\n  const tableBandHeaders = Array.from({\n    length: getMaxNestedLevel(columnBands as ColumnBands[], 0).level,\n  })\n    .map((row, index) => ({\n      key: `${TABLE_BAND_TYPE.toString()}_${index}`,\n      type: TABLE_BAND_TYPE,\n      level: index,\n    }));\n  return [...tableBandHeaders, ...tableHeaderRows];\n};\n\nexport const tableHeaderColumnChainsWithBands: GetHeaderColumnChainsFn<\n  TableRow[], TableColumn[], ColumnBands[]\n> = (\n  tableHeaderRows, tableColumns, bands,\n) => {\n  const chains = generateSimpleChains(tableHeaderRows, tableColumns);\n  const maxBandRowIndex = tableHeaderRows\n    .filter(row => row.type === TABLE_BAND_TYPE)\n    .length;\n  const rawBandChains = chains.slice(0, maxBandRowIndex);\n\n  let currentBand: any = null;\n  const shouldSplitChain: ShouldSplitChainFn = (chain, column, rowIndex) => {\n    if (rowIndex > maxBandRowIndex) return false;\n\n    const columnName = column.column && column.column.name || '';\n    currentBand = getColumnMeta(columnName, bands, rowIndex);\n    return !chain\n      || (chain as any).key !== currentBand.key;\n  };\n  const extendChainProps = () => ({\n    bandTitle: currentBand?.title,\n    key: currentBand?.key,\n  });\n\n  const bandChains = splitHeaderColumnChains(\n    rawBandChains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n\n  return [...bandChains, ...chains.slice(maxBandRowIndex)];\n};\n\nconst getBandLevel: PureComputed<[ColumnBands[], string, number?], number> = (\n  bands, bandTitle, level = 0,\n) => {\n  for (const band of bands) {\n    if (band.title === bandTitle) {\n      return level;\n    }\n    if (band.children !== undefined) {\n      const result = getBandLevel(band.children, bandTitle, level + 1);\n      if (result >= 0) return result;\n    }\n  }\n  return -1;\n};\n\nconst getBandLevels = (columnsBands: readonly ColumnBands[], levels = {}, level = 0) => {\n  columnsBands.forEach((band) => {\n    if (band.title) {\n      levels[band.title] = level;\n    }\n    if (band.children) {\n      getBandLevels(band.children, levels, level + 1);\n    }\n  });\n  return levels;\n};\n\nexport const columnBandLevels: PureComputed<[ColumnBands[]], BandLevels> = columnsBands => (\n  getBandLevels(columnsBands)\n);\n\nexport const bandLevelsVisibility: PureComputed<\n  [VisibleBoundary[], HeaderColumnChainRows<BandColumnChainExtension>, BandLevels],\n  boolean[]\n> = (columnIntervals, tableHeaderColumnChains, bandLevels) => {\n  const rowsWithBands = tableHeaderColumnChains\n    .filter(r => r.filter(ch => !!ch.bandTitle).length);\n\n  const visibleIntervals = columnIntervals.map(([start, end]) => ({ start, end }));\n\n  const isBandChainVisible = (chain: HeaderColumnChain) => (\n    visibleIntervals.some(interval => (\n      intervalUtil.intersect(\n        interval,\n        { start: chain.start, end: chain.start + chain.columns.length - 1 },\n      ) !== intervalUtil.empty\n    ),\n  ));\n\n  const getVisibleBandsByLevel = (level: number) => (\n    // Note: a visible band level always matches with it's row\n    rowsWithBands[level]\n    ? rowsWithBands[level].filter(chain => (\n        bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)\n      ))\n    : []\n  );\n\n  return rowsWithBands.reduce((acc, _, index) => {\n    const rowBands = getVisibleBandsByLevel(index);\n    return [...acc, !!rowBands.length];\n  }, [] as boolean[]);\n};\n\nexport const columnVisibleIntervals: PureComputed<\n  [GridViewport, TableColumn[]],\n  VisibleBoundary[]\n> = (\n  viewport, tableColumns,\n) => (\n  viewport ? viewport.columns : [[0, tableColumns.length]]\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleDetailRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const TABLE_DETAIL_TYPE = Symbol('detail');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, IsSpecificRowFn, TableColumn, RowId } from '../../types';\n\nexport const isDetailRowExpanded: PureComputed<[RowId[], RowId], boolean> = (\n  expandedDetailRowIds, rowId,\n) => expandedDetailRowIds.indexOf(rowId) > -1;\n\nexport const isDetailToggleTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;\n\nexport const isDetailTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DETAIL_TYPE;\n\nexport const isDetailTableCell: PureComputed<[TableColumn, TableColumn[]], boolean> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn) === 0;\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DETAIL_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableRow, TableColumn, CellColSpanGetter } from '../../types';\n\nexport const tableRowsWithExpandedDetail: PureComputed<[TableRow[], number[], number]> = (\n  tableRows, expandedDetailRowIds, rowHeight,\n) => {\n  let result = tableRows;\n  expandedDetailRowIds\n    .forEach((expandedRowId) => {\n      const rowIndex = result.findIndex(\n        tableRow => tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId,\n      );\n      if (rowIndex === -1) return;\n      const insertIndex = rowIndex + 1;\n      const { row, rowId } = result[rowIndex];\n      result = [\n        ...result.slice(0, insertIndex),\n        {\n          rowId,\n          row,\n          key: `${TABLE_DETAIL_TYPE.toString()}_${rowId}`,\n          type: TABLE_DETAIL_TYPE,\n          height: rowHeight,\n        },\n        ...result.slice(insertIndex),\n      ];\n    });\n  return result;\n};\n\nexport const tableColumnsWithDetail: PureComputed<[TableColumn[], number]> = (\n  tableColumns, toggleColumnWidth,\n) => [\n  { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth },\n  ...tableColumns,\n];\n\nexport const tableDetailCellColSpanGetter: CellColSpanGetter = getTableCellColSpan => (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return getTableCellColSpan(params);\n};\n","export const TABLE_SELECT_TYPE = Symbol('select');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TABLE_HEADING_TYPE } from '../table-header-row/constants';\nimport { IsSpecificCellFn, TableRow } from '../../types';\n\nexport const isSelectTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;\nexport const isSelectAllTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;\n\nexport const isRowHighlighted: PureComputed<[boolean, any[], TableRow], boolean> = (\n  highlightRow, selection, tableRow,\n) => (\n  highlightRow && selection && selection.includes(tableRow.rowId)\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_SELECT_TYPE } from './constants';\nimport { TableColumn } from '../../types';\n\nexport const tableColumnsWithSelection: PureComputed<[TableColumn[], number]> = (\n  tableColumns, selectionColumnWidth,\n) => [\n  { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth },\n  ...tableColumns,\n];\n","import { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport {\n  IsSpecificCellFn, IsSpecificRowFn, TableRow, TableColumn, CheckColumnExtensionsFn,\n} from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\nimport { isValidValue } from '../table-column-resizing/helpers';\n\nconst VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];\nconst TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';\n\nexport const isDataTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isHeaderStubTableCell: IsSpecificCellFn<TableRow, TableRow[]> = (\n  tableRow, headerRows,\n) => headerRows.indexOf(tableRow) > -1;\nexport const isDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_DATA_TYPE;\nexport const isNoDataTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_NODATA_TYPE;\nexport const isNoDataTableCell: IsSpecificCellFn<TableColumn, TableColumn[]> = (\n  tableColumn, tableColumns,\n) => tableColumns.indexOf(tableColumn as any) === 0;\nexport const isStubTableCell: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_STUB_TYPE\n);\n\nexport const checkTableColumnExtensions: CheckColumnExtensionsFn = (columnExtensions) => {\n  if (columnExtensions) {\n    columnExtensions.map((column) => {\n      const { width } = column;\n      if (typeof width === 'string') {\n        if (!isValidValue(width, VALID_UNITS)) {\n          throw new Error(TABLE_ERROR);\n        }\n      }\n    });\n  }\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GridColumnExtension, GetColumnExtensionValueGetterFn,\n} from '../types';\n\nexport const getColumnExtension: PureComputed<\n  [GridColumnExtension[] | undefined, string], GridColumnExtension\n> = (columnExtensions, columnName) => {\n  if (!columnExtensions) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  const columnExtension = columnExtensions.find(extension => extension.columnName === columnName);\n  if (!columnExtension) {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    return {} as GridColumnExtension;\n  }\n  return columnExtension;\n};\n\nexport const getColumnExtensionValueGetter: GetColumnExtensionValueGetterFn = (\n  columnExtensions, extensionName, defaultValue,\n) => (columnName) => {\n  if (columnExtensions) {\n    const columnExtension = getColumnExtension(columnExtensions, columnName);\n    const extensionValue = columnExtension[extensionName];\n    return extensionValue !== undefined ? extensionValue : defaultValue;\n  }\n  return defaultValue;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE, TABLE_NODATA_TYPE } from './constants';\nimport { getColumnExtension } from '../../utils/column-extension';\nimport { GridColumnExtension, GetCellColSpanFn } from './../../types/table.types';\nimport { Row, GetRowIdFn } from '../../types';\nimport { convertWidth } from '../table-column-resizing/helpers';\n\nexport const tableColumnsWithDataRows: PureComputed<[any[], GridColumnExtension[]]> = (\n  columns, columnExtensions,\n) => columns.map((column) => {\n  const { name } = column;\n  const columnExtension = getColumnExtension(columnExtensions as GridColumnExtension[], name);\n  const width = convertWidth(columnExtension.width!);\n  return {\n    column,\n    key: `${TABLE_DATA_TYPE.toString()}_${name}`,\n    type: TABLE_DATA_TYPE,\n    width,\n    align: columnExtension.align,\n    wordWrapEnabled: columnExtension.wordWrapEnabled,\n  };\n});\n\nexport const tableRowsWithDataRows: PureComputed<[Row[], GetRowIdFn, number]> = (\n  rows, getRowId, isRemoteRowsLoading,\n) => (\n  !rows.length && !isRemoteRowsLoading\n    ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]\n    : rows.map((row, dataIndex) => {\n      const rowId = getRowId(row);\n      return {\n        row,\n        // dataIndex,\n        rowId,\n        type: TABLE_DATA_TYPE,\n        key: `${TABLE_DATA_TYPE.toString()}_${rowId}`,\n      };\n    }));\n\nexport const tableCellColSpanGetter: GetCellColSpanFn = (params) => {\n  const { tableRow, tableColumns, tableColumn } = params;\n  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {\n    return tableColumns.length;\n  }\n  return 1;\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const visibleTableColumns: PureComputed<[TableColumn[], string[]]> = (\n  tableColumns = [], hiddenColumnNames,\n) => tableColumns.filter(tableColumn => tableColumn.type !== TABLE_DATA_TYPE\n    || hiddenColumnNames.indexOf(tableColumn.column!.name) === -1);\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { TableColumn } from '../../types';\n\nexport const tableDataColumnsExist = (tableColumns: TableColumn[]) => tableColumns.some(\n  column => column.type === TABLE_DATA_TYPE,\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport { Column } from '../../types/grid-core.types';\nimport { ColumnChooserItem } from '../../types';\n\nexport const columnChooserItems: PureComputed<[Column[], string[]], ColumnChooserItem[]> = (\n  columns, hiddenColumnNames,\n) => columns.map(column => ({\n  column,\n  hidden: hiddenColumnNames.indexOf(column.name) !== -1,\n}));\n","import { PureReducer } from '@devexpress/dx-core';\n\nexport const toggleColumn: PureReducer<string[], string> = (\n  hiddenColumnNames, columnName,\n) => (\n  hiddenColumnNames.indexOf(columnName) === -1\n    ? [...hiddenColumnNames, columnName]\n    : hiddenColumnNames.filter(hiddenColumn => hiddenColumn !== columnName)\n);\n","import { toggle } from '../../utils/common-reducers';\nimport { ToggleRowFieldReducer } from '../../types';\n\nexport const toggleRowExpanded: ToggleRowFieldReducer = (\n  prevExpanded, { rowId, state },\n) => toggle(prevExpanded, [rowId], state);\n","export const GRID_TREE_NODE_TYPE = Symbol('treeNode');\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GRID_TREE_NODE_TYPE } from './constants';\nimport {\n  RowsWithTreeMetaMap, RowsWithCollapsedRowsMetaMap, IsSpecificTreeRowGetter, GetRowIdFn,\n  GetRowLevelKeyFn, GetCollapsedRowsFn, CustomTreeRowsWithMetaComputed, GetCustomTreeRowsFn,\n  UnwrapRowsComputed, GetTreeRowLevelGetter, ExpandedTreeRowsFn,\n} from '../../types';\n\nconst customTreeRows: GetCustomTreeRowsFn = (\n  currentRow, getChildRows, rootRows, level = 0,\n) => {\n  const childRows = getChildRows(currentRow, rootRows as any[]);\n\n  if (!childRows) return { rows: [], treeMeta: [], empty: true };\n\n  return childRows\n    .reduce((acc, row) => {\n      const nestedResult = customTreeRows(\n        row,\n        getChildRows,\n        rootRows,\n        level + 1,\n      );\n      acc.rows.push(row, ...nestedResult.rows);\n      acc.treeMeta.push([row, { level, leaf: !!nestedResult.empty }], ...nestedResult.treeMeta);\n\n      return acc;\n    }, { rows: [], treeMeta: [] });\n};\n\nexport const customTreeRowsWithMeta: CustomTreeRowsWithMetaComputed = (\n  rows, getChildRows,\n) => {\n  const result = customTreeRows(null, getChildRows, rows);\n\n  return {\n    rows: result.rows,\n    treeMeta: new Map(result.treeMeta),\n  };\n};\n\nexport const customTreeRowIdGetter: PureComputed<[GetRowIdFn, RowsWithTreeMetaMap]> = (\n  getRowId, { rows, treeMeta },\n) => {\n  const firstNestedRowIndex = rows.findIndex(row => treeMeta.get(row)!.level > 0);\n  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {\n    return getRowId;\n  }\n  const map = new Map(rows\n    .map((row, rowIndex) => [row, rowIndex] as [any, any]));\n  return row => map.get(row);\n};\n\nexport const customTreeRowLevelKeyGetter: PureComputed<\n  [GetRowLevelKeyFn, RowsWithTreeMetaMap]\n> = (\n  getRowLevelKey, { treeMeta },\n) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  if (rowMeta !== undefined) {\n    return `${GRID_TREE_NODE_TYPE.toString()}_${rowMeta.level}`;\n  }\n  return getRowLevelKey && getRowLevelKey();\n};\n\nexport const expandedTreeRows: ExpandedTreeRowsFn = (\n  { rows, treeMeta }, getRowId, expandedRowIds,\n) => {\n  const expandedRowIdsSet = new Set(expandedRowIds);\n\n  let currentExpanded = true;\n  let currentLevel = 0;\n\n  const collapsedRowsMeta = new Map();\n  const resultRows: object[] = [];\n\n  rows.forEach((row) => {\n    const rowMeta = treeMeta.get(row);\n    const level = rowMeta && rowMeta.level;\n    if (level === undefined && currentExpanded) {\n      resultRows.push(row);\n    } else if (!currentExpanded && (level === undefined || level > currentLevel)) {\n      const lastRow = resultRows[resultRows.length - 1];\n      let collapsedItems = collapsedRowsMeta.get(lastRow);\n      if (!collapsedItems) {\n        collapsedItems = [];\n        collapsedRowsMeta.set(lastRow, collapsedItems);\n      }\n      collapsedItems.push(row);\n    } else {\n      currentExpanded = expandedRowIdsSet.has(getRowId(row));\n      currentLevel = level!;\n\n      resultRows.push(row);\n    }\n  });\n\n  return {\n    treeMeta,\n    collapsedRowsMeta,\n    rows: resultRows,\n  };\n};\n\nexport const collapsedTreeRowsGetter: PureComputed<\n  [GetCollapsedRowsFn, RowsWithCollapsedRowsMetaMap]\n> = (\n  getCollapsedRows, { collapsedRowsMeta },\n) => row => collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row));\n\nexport const isTreeRowLeafGetter: IsSpecificTreeRowGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return rowMeta && rowMeta.leaf;\n};\n\nexport const getTreeRowLevelGetter: GetTreeRowLevelGetter = ({ treeMeta }) => (row) => {\n  const rowMeta = treeMeta.get(row);\n  return (rowMeta && rowMeta.level) as number;\n};\n\nexport const unwrappedCustomTreeRows: UnwrapRowsComputed = ({ rows }) => rows;\n","import { TABLE_DATA_TYPE } from '../table/constants';\nimport { IsSpecificCellFn, TableRow, TableColumn } from '../../types';\n\nexport const isTreeTableCell: IsSpecificCellFn<TableRow, TableColumn, string> = (\n  tableRow, tableColumn, forColumnName,\n) => tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE\n  && tableColumn.column!.name === forColumnName;\n","export const changeSearchValue = (\n  prevSearchValue: string, searchValue: string,\n) => searchValue;\n","import { SearchFilterExpressionFn, FilterExpression } from '../../types';\n\nexport const searchFilterExpression: SearchFilterExpressionFn = (\n  searchValue, columns, filterExpression,\n) => {\n  const filters = columns.map(({ name }) => ({ columnName: name, value: searchValue }));\n  const selfFilterExpression: FilterExpression = { filters, operator: 'or' };\n  if (!filterExpression) {\n    return selfFilterExpression;\n  }\n  return {\n    operator: 'and',\n    filters: [filterExpression as FilterExpression, selfFilterExpression],\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { GetAvailableFilterOperationsFn, FilterOperation } from '../../types';\n\nexport const getAvailableFilterOperationsGetter: PureComputed<\n  [GetAvailableFilterOperationsFn, FilterOperation[], string[]]\n> = (\n  getAvailableFilterOperations,\n  availableFilterOperations,\n  columnNames,\n) => columnName => (columnNames.indexOf(columnName) > -1 && availableFilterOperations)\n// tslint:disable-next-line: max-line-length\n    || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))\n    || undefined;\n","export const FIXED_COLUMN_LEFT_SIDE = 'left';\nexport const FIXED_COLUMN_RIGHT_SIDE = 'right';\nexport const TABLE_FIXED_TYPE = Symbol('fixed');\n","import { slice } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  FIXED_COLUMN_LEFT_SIDE, TABLE_FIXED_TYPE,\n} from './constants';\nimport { findChainByColumnIndex } from '../table-header-row/helpers';\nimport {\n  GetFixedColumnKeysFn, IsSpecificRowFn, CalculatePositionFn, CalculateFixedColumnPropsFn,\n} from '../../types';\n\nexport const getFixedColumnKeys: GetFixedColumnKeysFn = (tableColumns, fixedNames) => tableColumns\n  .filter(tableColumn => (\n    (tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column!.name) !== -1)\n    || fixedNames.indexOf(tableColumn.type) !== -1\n  ))\n  .map(({ key }) => key);\n\nexport const isFixedTableRow: IsSpecificRowFn = tableRow => tableRow.type === TABLE_FIXED_TYPE;\n\nconst calculatePosition: CalculatePositionFn = (array, index, tableColumnDimensions) => (\n  index === 0\n    ? 0\n    : array\n      .slice(0, index)\n      .reduce((acc, target) => acc + tableColumnDimensions[target] || 0, 0)\n);\n\nexport const calculateFixedColumnProps: CalculateFixedColumnPropsFn = (\n  { tableColumn },\n  { leftColumns, rightColumns },\n  tableColumns,\n  tableColumnDimensions,\n  tableHeaderColumnChains,\n) => {\n  const side = tableColumn.fixed!;\n  const targetArray = side === FIXED_COLUMN_LEFT_SIDE\n    ? getFixedColumnKeys(tableColumns, leftColumns)\n    : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();\n\n  const index = tableColumns.findIndex(({ key }) => key === tableColumn.key);\n  const fixedIndex = targetArray.indexOf(tableColumn.key);\n  const columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index)!;\n\n  const showLeftDivider = columnChain.start === index && index !== 0;\n  const showRightDivider = columnChain.start + columnChain.columns.length - 1 === index\n    && index < tableColumns.length - 1;\n\n  const position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);\n\n  return {\n    showRightDivider,\n    showLeftDivider,\n    position,\n    side,\n  };\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport { FIXED_COLUMN_LEFT_SIDE, FIXED_COLUMN_RIGHT_SIDE, TABLE_FIXED_TYPE } from './constants';\nimport { splitHeaderColumnChains, generateSimpleChains } from '../table-header-row/helpers';\nimport {\n  FixedColumnName, TableColumn, FixedColumnSide, TableRow, HeaderColumnChainRows,\n  ShouldSplitChainFn,\n} from '../../types';\n\nexport const tableColumnsWithFixed: PureComputed<\n  [TableColumn[], FixedColumnName[], FixedColumnName[]]\n> = (\n  tableColumns, leftColumns, rightColumns,\n) => tableColumns\n  .map((tableColumn) => {\n    let fixed!: FixedColumnSide;\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && leftColumns.indexOf(tableColumn.column!.name) !== -1)\n      || leftColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_LEFT_SIDE;\n    }\n    if ((tableColumn.type === TABLE_DATA_TYPE\n      && rightColumns.indexOf(tableColumn.column!.name) !== -1)\n      || rightColumns.indexOf(tableColumn.type) !== -1) {\n      fixed = FIXED_COLUMN_RIGHT_SIDE;\n    }\n    return fixed ? { ...tableColumn, fixed } : tableColumn;\n  });\n\nexport const tableHeaderRowsWithFixed: PureComputed<[TableRow[]]> = tableHeaderRows => [\n  ...tableHeaderRows,\n  { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },\n];\n\nexport const tableHeaderColumnChainsWithFixed: PureComputed<\n  [HeaderColumnChainRows, TableRow[], TableColumn[]]\n> = (\n  tableHeaderColumnChains, tableHeaderRows, tableColumns,\n) => {\n  const chains = tableHeaderColumnChains\n    || generateSimpleChains(tableHeaderRows, tableColumns);\n\n  const shouldSplitChain: ShouldSplitChainFn = (currentGroup, column) => (\n    !currentGroup || (currentGroup as any).fixed !== column.fixed\n  );\n  const extendChainProps = (column: TableColumn) => ({\n    fixed: column.fixed,\n  });\n  return splitHeaderColumnChains(\n    chains,\n    tableColumns,\n    shouldSplitChain,\n    extendChainProps,\n  );\n};\n","import {\n  SummaryValue, SummaryCalculator,\n  DefaultSummaryCalculators,\n  Row,\n  TotalSummaryValuesFn,\n  GroupSummaryValuesFn,\n  TreeSummaryValuesFn,\n  RowsSummaryValuesFn,\n  ExpandRowsFn,\n  TableRow,\n  GroupLevel,\n} from '../../types';\n\nconst defaultSummaryCalculators: DefaultSummaryCalculators = {\n  count: rows => rows.length,\n  sum: (rows, getValue) => rows.reduce((acc, row) => acc + getValue(row), 0),\n  max: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.max(acc, getValue(row)), -Infinity)\n    : null),\n  min: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => Math.min(acc, getValue(row)), Infinity)\n    : null),\n  avg: (rows, getValue) => (rows.length\n    ? rows.reduce((acc, row) => acc + getValue(row), 0) / rows.length\n    : null),\n};\n\nexport const defaultSummaryCalculator: SummaryCalculator = (type, rows, getValue) => {\n  const summaryCalculator = defaultSummaryCalculators[type];\n  if (!summaryCalculator) {\n    throw new Error(`The summary type '${type}' is not defined`);\n  }\n  return summaryCalculator(rows, getValue);\n};\n\nconst rowsSummary: RowsSummaryValuesFn = (\n  rows, summaryItems, getCellValue, calculator,\n) => summaryItems\n  .reduce((acc, { type, columnName }) => {\n    const getValue = (row: Row) => getCellValue(row, columnName);\n    acc.push(calculator(type, rows as any[], getValue));\n    return acc;\n  }, [] as SummaryValue[]);\n\nconst expandRows: ExpandRowsFn = (\n  rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow = false,\n) => {\n  const shouldIncludeRow = includeGroupRow || !isGroupRow\n    ? () => true\n    : (row: TableRow) => !isGroupRow(row);\n\n  return rows\n    .reduce((acc, row) => {\n      if (getRowLevelKey && getRowLevelKey(row)) {\n        if (shouldIncludeRow(row)) {\n          acc.push(row);\n        }\n        const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n        if (collapsedRows) {\n          acc.push(...collapsedRows);\n        }\n        return acc;\n      }\n      acc.push(row);\n      return acc;\n    }, [] as TableRow[]);\n};\n\nexport const totalSummaryValues: TotalSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  const plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);\n  return rowsSummary(plainRows, summaryItems, getCellValue, calculator);\n};\n\nexport const groupSummaryValues: GroupSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getCollapsedRows,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: GroupLevel[] = [];\n  const getLevelIndex = (levelKey: string) => (\n    levels.findIndex(level => level.levelKey === levelKey)\n  );\n  const summaries = {};\n\n  const anyRowLevelSummaryExist = summaryItems.some(item => (\n    !(item as any).showInGroupFooter\n  ));\n  const expandedRows = anyRowLevelSummaryExist\n    ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)\n    : rows;\n\n  expandedRows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    const collapsedRows = getCollapsedRows && getCollapsedRows(row);\n    let levelIndex = getLevelIndex(levelKey);\n    if (levelIndex > -1) {\n      levels.forEach((level) => {\n        summaries[level.row.compoundKey] = rowsSummary(\n          level.rows, summaryItems, getCellValue, calculator,\n        );\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (isGroupRow!(row)) {\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n      levelIndex = getLevelIndex(levelKey);\n    }\n    // when row level summary exists, these rows had already been expanded earlier\n    const isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;\n    const rowsToAppend = !levelKey ? [row] : collapsedRows;\n    if (!levelKey || isCollapsedNestedGroupRow) {\n      levels.forEach((level) => {\n        level.rows.push(...rowsToAppend);\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    summaries[level.row.compoundKey] = rowsSummary(\n      level.rows, summaryItems, getCellValue, calculator,\n    );\n  });\n  return summaries;\n};\n\nexport const treeSummaryValues: TreeSummaryValuesFn = (\n  rows,\n  summaryItems,\n  getCellValue,\n  getRowLevelKey,\n  isGroupRow,\n  getRowId,\n  calculator = defaultSummaryCalculator,\n) => {\n  let levels: any[] = [];\n  const summaries = {};\n  rows.forEach((row) => {\n    const levelKey = getRowLevelKey(row);\n    if (!levelKey) {\n      levels[levels.length - 1].rows.push(row);\n      return;\n    }\n    const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n    if (levelIndex > -1) {\n      levels.slice(levelIndex).forEach((level) => {\n        if (level.rows.length) {\n          summaries[getRowId(level.row)] = rowsSummary(\n            level.rows, summaryItems, getCellValue, calculator,\n          );\n        }\n      });\n      levels = levels.slice(0, levelIndex);\n    }\n    if (!isGroupRow || !isGroupRow(row)) {\n      if (levels.length) {\n        levels[levels.length - 1].rows.push(row);\n      }\n      levels.push({\n        levelKey,\n        row,\n        rows: [],\n      });\n    }\n  }, {});\n  levels.forEach((level) => {\n    if (level.rows.length) {\n      summaries[getRowId(level.row)] = rowsSummary(\n        level.rows, summaryItems, getCellValue, calculator,\n      );\n    }\n  });\n  return summaries;\n};\n","export const TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');\nexport const TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');\nexport const TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');\n\nexport const defaultFormatlessSummaries = ['count'];\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE, TABLE_GROUP_SUMMARY_TYPE, TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport { TABLE_DATA_TYPE } from '../table/constants';\nimport {\n  GetColumnSummariesFn, IsSpecificCellFn, IsSpecificRowFn, SummaryItem,\n  GetGroupInlineSummariesFn, ColumnInlineSummaries, GroupSummaryItem,\n} from '../../types';\n\nexport const isTotalSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isGroupSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTreeSummaryTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;\nexport const isTotalSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TOTAL_SUMMARY_TYPE\n);\nexport const isGroupSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_GROUP_SUMMARY_TYPE\n);\nexport const isTreeSummaryTableRow: IsSpecificRowFn = tableRow => (\n  tableRow.type === TABLE_TREE_SUMMARY_TYPE\n);\n\nexport const getColumnSummaries: GetColumnSummariesFn = (\n  summaryItems, columnName, summaryValues, predicate = () => true,\n) => summaryItems\n  .map((item, index) => [item, index] as [SummaryItem, number])\n  .filter(([item]) => item.columnName === columnName && predicate(item))\n  .map(([item, index]) => ({\n    type: item.type,\n    value: summaryValues[index],\n  }));\n\nexport const isFooterSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  (summaryItem as GroupSummaryItem).showInGroupFooter!\n);\nexport const isInlineGroupCaptionSummary: PureComputed<[SummaryItem], boolean> = summaryItem => (\n  !((summaryItem as GroupSummaryItem).showInGroupFooter ||\n  (summaryItem as GroupSummaryItem).alignByColumn)\n);\nexport const groupFooterSummaryExists: PureComputed<[GroupSummaryItem[]], boolean> =\n  groupSummaryItems => groupSummaryItems?.some(isFooterSummary);\n\nexport const getGroupInlineSummaries: GetGroupInlineSummariesFn = (\n  summaryItems, columns, summaryValues,\n) => {\n  if (!summaryItems.some(isInlineGroupCaptionSummary)) {\n    return [];\n  }\n\n  return columns.reduce((acc, column) => {\n    const colName = column.name;\n    const summaries = getColumnSummaries(\n      summaryItems, colName, summaryValues, isInlineGroupCaptionSummary,\n    );\n    if (summaries.length) {\n      acc.push({\n        column,\n        summaries,\n      });\n    }\n\n    return acc;\n  }, [] as ColumnInlineSummaries[]);\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  TABLE_TOTAL_SUMMARY_TYPE,\n  TABLE_GROUP_SUMMARY_TYPE,\n  TABLE_TREE_SUMMARY_TYPE,\n} from './constants';\nimport {\n  TableRow, RowLevel, TableRowsWithSummariesFn,\n} from '../../types';\nimport { groupFooterSummaryExists } from './helpers';\n\nexport const tableRowsWithTotalSummaries: PureComputed<[TableRow[]]> = footerRows => [\n  { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE },\n  ...footerRows,\n];\n\nexport const tableRowsWithSummaries: TableRowsWithSummariesFn = (\n  tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId,\n) => {\n  if (!getRowLevelKey || !(groupSummaryItems || treeSummaryItems)) return tableRows;\n\n  const hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);\n  const result: TableRow[] = [];\n  const closeLevel = (level: RowLevel) => {\n    if (!level.opened) return;\n    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {\n      const { compoundKey } = level.row;\n      result.push({\n        key: `${TABLE_GROUP_SUMMARY_TYPE.toString()}_${compoundKey}`,\n        type: TABLE_GROUP_SUMMARY_TYPE,\n        row: level.row,\n      });\n    } else if (treeSummaryItems) {\n      const rowId = getRowId(level.row);\n      result.push({\n        key: `${TABLE_TREE_SUMMARY_TYPE.toString()}_${rowId}`,\n        type: TABLE_TREE_SUMMARY_TYPE,\n        row: level.row,\n      });\n    }\n  };\n\n  let levels: RowLevel[] = [];\n  tableRows.forEach((tableRow) => {\n    const { row } = tableRow;\n    const levelKey = getRowLevelKey(row);\n    if (levelKey) {\n      const levelIndex = levels.findIndex(level => level.levelKey === levelKey);\n      if (levelIndex > -1) {\n        levels.slice(levelIndex).reverse().forEach(closeLevel);\n        levels = levels.slice(0, levelIndex);\n      }\n      if (!isGroupRow || !isGroupRow(row)) {\n        levels = levels.map(level => ({\n          ...level,\n          opened: true,\n        }));\n      }\n      levels.push({\n        levelKey,\n        row,\n        opened: false,\n      });\n    } else {\n      levels = levels.map(level => ({\n        ...level,\n        opened: true,\n      }));\n    }\n    result.push(tableRow);\n  });\n  levels.slice().reverse().forEach(closeLevel);\n\n  return result;\n};\n","import { GroupSummaryItem } from '../../types';\n\nexport const prepareGroupSummaryItems = (items: GroupSummaryItem[]) => (\n  !!items\n    ? items.map(item => ({\n      ...item,\n      showInGroupFooter: (\n        item.showInGroupFooter === undefined && !item.alignByColumn\n      )\n        ? true\n        : item.showInGroupFooter,\n    }))\n    : items\n);\n","import { GetTargetColumnGeometriesFn } from '../types';\n\nexport const getTargetColumnGeometries: GetTargetColumnGeometriesFn = (\n  columnGeometries, sourceIndex,\n) => {\n  const sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;\n  const getWidthDifference = (index: number) => columnGeometries[index].right\n                                      - columnGeometries[index].left\n                                      - sourceWidth;\n\n  return columnGeometries\n    .map(({\n      top, right, bottom, left,\n    }, targetIndex) => {\n      let leftBorder = left;\n      if (targetIndex > 0 && targetIndex <= sourceIndex) {\n        leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));\n      }\n      if (targetIndex > sourceIndex) {\n        leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));\n      }\n      let rightBorder = right;\n      if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {\n        rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));\n      }\n      if (targetIndex < sourceIndex) {\n        rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));\n      }\n\n      return {\n        top,\n        bottom,\n        right: rightBorder,\n        left: leftBorder,\n      };\n    });\n};\n","import { easeOutCubic } from '@devexpress/dx-core';\nimport { getTargetColumnGeometries } from './column-geometries';\nimport {\n  GetTableColumnGeometriesFn, GetTableTargetColumnIndexFn, ColumnAnimation,\n  GetColumnAnimationsFn, ColumnGeometry, FilterActiveAnimationsFn, EvalAnimationsFn,\n} from '../types';\n\nexport const getTableColumnGeometries: GetTableColumnGeometriesFn = (columns, tableWidth) => {\n  const columnWidths = columns\n    .map(column => column.width);\n\n  const freeSpace = tableWidth;\n  const restrictedSpace = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width === 'number' ? width : 0), 0) as number;\n  const freeSpacePortions = columnWidths\n    .reduce(\n      (accum, width) => (accum as number)! + (typeof width !== 'number' ? 1 : 0), 0) as number;\n  const freeSpacePortion = (freeSpace - restrictedSpace!) / freeSpacePortions!;\n\n  let lastRightPosition = 0;\n  return columnWidths\n    .map(width => (typeof width !== 'number' ? freeSpacePortion : width))\n    .map((width) => {\n      lastRightPosition += width;\n      return {\n        left: lastRightPosition - width,\n        right: lastRightPosition,\n      };\n    });\n};\n\nexport const getTableTargetColumnIndex: GetTableTargetColumnIndexFn = (\n  columnGeometries, sourceIndex, offset,\n) => getTargetColumnGeometries(columnGeometries, sourceIndex)\n  .findIndex(({ left, right }) => offset > left && offset < right);\n\nconst ANIMATION_DURATION = 200;\n\nconst getAnimationProgress = (animation: ColumnAnimation) => (\n  new Date().getTime() - animation.startTime) / ANIMATION_DURATION;\n\nexport const getAnimations: GetColumnAnimationsFn = (\n  prevColumns,\n  nextColumns,\n  tableWidth,\n  prevAnimations,\n) => {\n  const resizing = prevColumns.map(column => column.key).join()\n    === nextColumns.map(column => column.key).join();\n\n  const prevColumnGeometries = new Map<string, ColumnGeometry>(\n    getTableColumnGeometries(prevColumns, tableWidth)\n      .map((geometry, index) => [prevColumns[index].key, geometry] as [string, ColumnGeometry])\n      .map(([key, geometry]) => {\n        const animation = prevAnimations.get(key);\n        if (!animation) return [key, geometry];\n        const progress = easeOutCubic(getAnimationProgress(animation));\n        const { to, from } = animation.left!;\n        const left = ((to - from) * progress) + from;\n        return [key, {\n          left,\n          right: geometry.right - (geometry.left - left),\n        }];\n      // tslint:disable-next-line:array-type\n      }) as [string, ColumnGeometry][],\n    );\n\n  const nextColumnGeometries = new Map(\n    getTableColumnGeometries(nextColumns, tableWidth)\n      // tslint:disable-next-line:array-type\n      .map((geometry, index) => [nextColumns[index].key, geometry]) as [string, ColumnGeometry][],\n  );\n\n  return new Map([...nextColumnGeometries.keys()]\n    .map((key) => {\n      const prev: any = prevColumnGeometries.get(key);\n      const next: any = nextColumnGeometries.get(key);\n\n      const result: ColumnAnimation = { startTime: new Date().getTime(), style: {} };\n      const takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);\n      if (Math.abs((takePrevColumnIntoAccount ? prev!.left : next!.left) - next!.left) > 1) {\n        result.left = { from: prev.left, to: next.left };\n      }\n      return [key, result] as [string, ColumnAnimation];\n    })\n    .filter((animation: [string, ColumnAnimation]) => animation[1].left));\n};\n\nexport const filterActiveAnimations: FilterActiveAnimationsFn = animations => new Map(\n  [...animations.entries()]\n    .filter(([, animation]) => getAnimationProgress(animation) < 1),\n);\n\nexport const evalAnimations: EvalAnimationsFn = animations => new Map([...animations.entries()]\n  .map(([key, animation]): [string, object] => {\n    const progress = easeOutCubic(getAnimationProgress(animation));\n    const result = { ...animation.style };\n    if (animation.left) {\n      const offset = (animation.left.to - animation.left.from) * (progress - 1);\n      (result as any).transform = `translateX(${offset}px)`;\n    }\n    return [key, result];\n  }));\n","import { getTargetColumnGeometries } from './column-geometries';\nimport { TargetColumnGeometry, GetGroupCellTargetIndexFn } from '../types';\nimport { PureComputed } from '@devexpress/dx-core';\n\nconst isOnTheSameLine: PureComputed<[TargetColumnGeometry, number], boolean> = (geometry, y) => (\n  y >= geometry.top && y <= geometry.bottom\n);\n\nconst rectToObject = ({\n  top, right, bottom, left,\n}: TargetColumnGeometry) => ({\n  top, right, bottom, left,\n});\n\nconst collapseGapsBetweenItems: PureComputed<[TargetColumnGeometry[]]> = geometries => (\n  geometries.map((geometry, index) => {\n    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {\n      return {\n        ...geometry,\n        right: geometries[index + 1].left,\n      };\n    }\n    return geometry;\n  }));\n\nexport const getGroupCellTargetIndex: GetGroupCellTargetIndexFn = (\n  geometries, sourceIndex, { x, y },\n) => {\n  if (geometries.length === 0) return 0;\n\n  const targetGeometries = sourceIndex !== -1\n    ? getTargetColumnGeometries(geometries, sourceIndex)\n    : geometries.map(rectToObject);\n\n  const targetIndex = collapseGapsBetweenItems(targetGeometries)\n    .findIndex((geometry, index) => {\n      const inVerticalBounds = isOnTheSameLine(geometry, y);\n      const inHorizontalBounds = x >= geometry.left && x <= geometry.right;\n      const shouldGoFirst = index === 0 && x < geometry.left;\n      const shouldGoOnLineBreak = !inVerticalBounds\n        && !!geometries[index - 1]\n        && isOnTheSameLine(geometries[index - 1], y);\n\n      return (inVerticalBounds && inHorizontalBounds)\n        || shouldGoFirst\n        || shouldGoOnLineBreak;\n    });\n\n  return targetIndex === -1 ? geometries.length : targetIndex;\n};\n","import { PureComputed } from '@devexpress/dx-core';\n\ntype CompareFn = (...args: [any, any]) => boolean;\n/** @internal */\nexport const arraysEqual: PureComputed<[any[], any[], CompareFn?], boolean> = (\n  arrA, arrB, comparator = (a, b) => a === b,\n) => {\n  if (arrA.length !== arrB.length) {\n    return false;\n  }\n  for (let i = 0; i < arrA.length; i += 1) {\n    if (!comparator(arrA[i], arrB[i])) {\n      return false;\n    }\n  }\n  return true;\n};\n","import { GridViewport } from '../../types';\n\n/** @internal */\nexport const emptyViewport: GridViewport = {\n  columns: [[0, 0]],\n  rows: [0, 0],\n  headerRows: [0, 0],\n  footerRows: [0, 0],\n  top: 0,\n  left: 0,\n  width: 800,\n  height: 600,\n};\n\nexport const TOP_POSITION = Symbol('top');\nexport const BOTTOM_POSITION = Symbol('bottom');\n","import {\n  getRowsVisibleBoundary, getColumnBoundaries,\n} from '../../utils/virtual-table';\nimport {\n  GetViewportFn,\n  CheckTableColumnWidths,\n  TableColumn,\n  GetScrollHeightByIndex,\n  GetScrollPosition,\n  GetTopRowId,\n} from '../../types';\nimport { arraysEqual } from './utils';\nimport { TOP_POSITION, BOTTOM_POSITION } from './constants';\n\nconst VALID_UNITS = ['px', ''];\n/* tslint:disable max-line-length */\nconst VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';\n\nexport const getViewport: GetViewportFn = (\n  state, getters, estimatedRowHeight, getRowHeight, getColumnWidth,\n) => {\n  const {\n    viewportTop, viewportLeft, containerWidth, containerHeight, headerHeight, footerHeight,\n  } = state;\n  const {\n    loadedRowsStart,\n    bodyRows: tableBodyRows,\n    columns: tableColumns,\n    headerRows: tableHeaderRows = [],\n    footerRows: tableFooterRows = [],\n    isDataRemote,\n    viewport,\n  } = getters;\n\n  const rows = getRowsVisibleBoundary(\n    tableBodyRows, viewportTop, containerHeight - headerHeight - footerHeight,\n    getRowHeight, loadedRowsStart, estimatedRowHeight, isDataRemote,\n  );\n  const headerRows = getRowsVisibleBoundary(\n    tableHeaderRows, 0, headerHeight,\n    getRowHeight, 0, estimatedRowHeight, false,\n  );\n  const footerRows = getRowsVisibleBoundary(\n    tableFooterRows, 0, footerHeight,\n    getRowHeight, 0, estimatedRowHeight, false,\n  );\n  const columns = getColumnBoundaries(\n    tableColumns, viewportLeft, containerWidth, getColumnWidth,\n  );\n\n  // NOTE: prevent unnecessary updates\n  // e.g. when rows changed but bounds remain the same.\n  let result = viewport;\n  if (viewportTop !== viewport.top) {\n    result = { ...result, top: viewportTop };\n  }\n  if (viewportLeft !== viewport.left) {\n    result = { ...result, left: viewportLeft };\n  }\n  if (containerWidth !== viewport.width) {\n    result = { ...result, width: containerWidth };\n  }\n  if (containerHeight !== viewport.height) {\n    result = { ...result, height: containerHeight };\n  }\n  if (!arraysEqual(rows, viewport.rows)) {\n    result = { ...result, rows };\n  }\n  if (!arraysEqual(headerRows, viewport.headerRows)) {\n    result = { ...result, headerRows };\n  }\n  if (!arraysEqual(footerRows, viewport.footerRows)) {\n    result = { ...result, footerRows };\n  }\n  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {\n    result = { ...result, columns };\n  }\n\n  return result;\n};\n\nexport const checkColumnWidths: CheckTableColumnWidths = (tableColumns) => {\n  return tableColumns.reduce((acc, tableColumn) => {\n    const { width } = tableColumn;\n    if (typeof width === 'string') {\n      const numb = parseInt(width, 10);\n      const unit = numb ? width.substr(numb.toString().length) : width;\n      const isValidUnit = VALID_UNITS.some(validUnit => validUnit === unit);\n      if (!isValidUnit) {\n        throw new Error(VIRTUAL_TABLE_ERROR);\n      }\n      acc.push({ ...tableColumn, width: numb });\n    } else {\n      acc.push(tableColumn);\n    }\n    return acc;\n  }, []  as TableColumn[]);\n};\n\nexport const calculateScrollHeight: GetScrollHeightByIndex = (rowHeight, index) =>\n  index > -1 ? rowHeight * index : undefined;\n\nexport const getScrollTop: GetScrollPosition = (rows, rowsCount, rowId, rowHeight, isDataRemote) => {\n  if (rowId === TOP_POSITION) {\n    return 0;\n  }\n  if (rowId === BOTTOM_POSITION) {\n    return rowsCount * rowHeight;\n  }\n\n  const searchIndexRequired = !isDataRemote && rowId !== undefined;\n  const indexById = searchIndexRequired\n    ? rows.findIndex(row => row.rowId === rowId)\n    : undefined;\n\n  return calculateScrollHeight(\n    rowHeight,\n    indexById!,\n  );\n};\n\nexport const getTopRowId: GetTopRowId = (viewport, tableBodyRows, isDataRemote) => {\n  const hasViewportRows = viewport && viewport.rows;\n  const hasBodyRows = tableBodyRows && tableBodyRows.length;\n  if (hasViewportRows && hasBodyRows && !isDataRemote) {\n    const index = viewport.rows[0];\n\n    return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;\n  }\n\n  return undefined;\n};\n","import { mergeRows } from './helpers';\nimport { intervalUtil } from './utils';\nimport { VirtualRowsWithCacheFn, PlainRowsFn, LoadedRowsStartFn } from '../../types';\n\nexport const virtualRowsWithCache: VirtualRowsWithCacheFn = (skip, rows, cache) => {\n  const rowsInterval = intervalUtil.getRowsInterval({ skip, rows });\n  const cacheInterval = intervalUtil.getRowsInterval(cache);\n\n  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);\n};\n\nexport const plainRows: PlainRowsFn = (virtualRows, availableRowCount) => {\n  return virtualRows.rows.length > availableRowCount\n    ? virtualRows.rows.slice(0, availableRowCount)\n    : virtualRows.rows;\n};\n\nexport const loadedRowsStart: LoadedRowsStartFn = virtualRows => virtualRows.skip;\n","export const ROOT_GROUP = '__root__';\nexport const DEFAULT_COLUMN_WIDTH = 150;\n","// tslint:disable-next-line: no-submodule-imports\nimport * as Excel from 'exceljs';\nimport { PureComputed } from '@devexpress/dx-core';\nimport {\n  TableColumn, FindRangesFn, ExportRowsFn,\n  CloseSheetFn,\n  ExportSummaryItemsFn,\n  RemoveEmptyGroupsFn,\n} from '../../types';\nimport { ROOT_GROUP, DEFAULT_COLUMN_WIDTH } from './constants';\n\nexport const exportHeader = (worksheet: Excel.Worksheet, columns: TableColumn[]) => {\n  const cols = columns\n    .map(({ column, width }) => ({\n      width: (width as number || DEFAULT_COLUMN_WIDTH) / 8,\n      key: column?.name,\n    }));\n  worksheet.columns = cols;\n\n  const { lastRow } = worksheet;\n  if (lastRow) {\n    worksheet.addRow({});\n  }\n\n  const headerRow = columns.reduce((acc, { column: { name, title } = {} }) => ({\n    ...acc,\n    [name!]: title,\n  }), {});\n  worksheet.addRow(headerRow);\n\n  worksheet.views.push({\n    state: 'frozen', ySplit: worksheet.lastRow!.number,\n  });\n};\n\nexport const findRanges: FindRangesFn = (groupTree, compoundKey, level, maxLevel, result = []) => {\n  if (level !== maxLevel) {\n    const ranges = (groupTree[compoundKey] as string[]).reduce((acc, groupKey) => (\n      [...acc, ...findRanges(groupTree, groupKey, level + 1, maxLevel, result)]\n    ), [] as Array<number[]>);\n    return [...result, ...ranges];\n  }\n  return [...result, groupTree[compoundKey] as number[]];\n};\n\nexport const exportRows: ExportRowsFn = (\n  worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels,\n  rowsOffset, getCellValue, getCloseGroup, customizeCell,\n) => {\n  let currentLevel = 0;\n  let openGroups: any[] = [];\n  const closeGroup = getCloseGroup(rowsOffset);\n\n  allRows.forEach((row) => {\n    let excelRow;\n\n    if (isGroupRow && isGroupRow(row)) {\n      currentLevel = outlineLevels[row.groupedBy];\n\n      // close nested groups first\n      openGroups.slice(currentLevel).reverse().forEach(closeGroup);\n\n      openGroups = openGroups.slice(0, currentLevel);\n      openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };\n\n      // add group row\n      const title = dataColumns.find(({ name }) => name === row.groupedBy)?.title;\n      excelRow = { [columns[0].column!.name]: `${title}: ${row.value}` };\n\n      worksheet.addRow(excelRow);\n      const lastIndex = worksheet.lastRow!.number;\n\n      // merge into single cell\n      worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);\n      worksheet.lastRow!.getCell(1).font = { bold: true };\n\n      if (currentLevel > 0) {\n        worksheet.lastRow!.outlineLevel = currentLevel;\n      }\n      currentLevel += 1;\n    } else {\n      excelRow = columns.reduce((acc, { column }) => ({\n        ...acc,\n        ...(column ? { [column.name]: getCellValue(row, column.name) } : null),\n      }), {});\n      worksheet.addRow(excelRow);\n      worksheet.lastRow!.outlineLevel = currentLevel;\n    }\n\n    worksheet.lastRow!.eachCell((cell, colNumber) => {\n      customizeCell(cell, row, columns[colNumber - 1].column!);\n    });\n  });\n\n  openGroups.reverse().forEach(closeGroup);\n};\n\nexport const closeSheet: CloseSheetFn = (\n  worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary,\n) => {\n  exportSummaryItems(\n    worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1,\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const normalizeRanges: PureComputed<[number[][], number]> = (ranges, offset) => (\n  ranges.map(range => range.map(index => + index + offset))\n);\n\nexport const exportSummaryItems: ExportSummaryItemsFn = (\n  worksheet, groupTree, summaryItems, groupKey, groupLevel,\n  rowsOffset, maxGroupLevel, exportSummary,\n) => {\n  if (!summaryItems) return;\n\n  worksheet.addRow({});\n\n  const ranges = normalizeRanges(\n    findRanges(groupTree, groupKey, groupLevel, maxGroupLevel),\n    rowsOffset,\n  );\n\n  summaryItems.forEach((s) => {\n    exportSummary(s, ranges);\n  });\n};\n\nexport const removeEmptyGroups: RemoveEmptyGroupsFn = (rows, grouping, isGroupRow) => {\n  if (!grouping) return rows;\n\n  const groupingColumns = grouping.map(({ columnName }) => columnName);\n  const result: any[] = [];\n  let groupChain: any[] = [];\n\n  rows.forEach((row) => {\n    if (isGroupRow(row)) {\n      const level = groupingColumns.indexOf(row.groupedBy);\n      if (level === groupChain.length) {\n        groupChain.push(row);\n      } else {\n        groupChain = [...groupChain.slice(0, level), row];\n      }\n    } else {\n      if (groupChain.length > 0) {\n        result.push(...groupChain);\n        groupChain = Array.from({ length: groupChain.length });\n      }\n      result.push(row);\n    }\n  });\n\n  return result.filter(row => !!row);\n};\n","import {\n  OutlineLevelsFn, FilterSelectedRowsFn, GetRowsToExportFn, Row, BuildGroupTreeFn,\n  GetExportSummaryFn, GetCloseGroupFn, Grouping, RowId,\n} from '../../types';\nimport { PureComputed } from '@devexpress/dx-core';\nimport { ROOT_GROUP } from './constants';\nimport { exportSummaryItems, removeEmptyGroups } from './helpers';\nimport { TABLE_DATA_TYPE } from '../table/constants';\n\nexport const groupOutlineLevels: OutlineLevelsFn = grouping => (\n  grouping?.reduce((acc, { columnName }, index) => ({\n    ...acc,\n    [columnName]: index,\n  }), {}) || {}\n);\n\nconst filterSelectedRows: FilterSelectedRowsFn = (rows, selection, getRowId, isGroupRow) => {\n  const selectionSet = new Set<RowId>(selection);\n  return rows.filter(row => (\n    isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)),\n  );\n};\n\nexport const rowsToExport: GetRowsToExportFn = (\n  rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow,\n) => {\n  const expandRows: PureComputed<[Row[]]> = collapsedRows => (\n    collapsedRows.reduce((acc, row) => (\n      [...acc, row, ...(expandRows(getCollapsedRows(row) || []))]\n    ), [])\n  );\n\n  const expandedRows = getCollapsedRows ? expandRows(rows) : rows;\n\n  if (!selection) {\n    return expandedRows;\n  }\n\n  const filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);\n  return removeEmptyGroups(filteredRows, grouping, isGroupRow);\n};\n\nexport const buildGroupTree: BuildGroupTreeFn = (\n  rows, outlineLevels, grouping, isGroupRow, groupSummaryItems,\n) => {\n  const groupTree = { [ROOT_GROUP]: [] as any[] };\n\n  if (!grouping?.length) {\n    groupTree[ROOT_GROUP] = [0, rows.length - 1];\n    return groupTree;\n  }\n\n  const maxLevel = Object.keys(outlineLevels).length - 1;\n  const groupSummaryExists = !!groupSummaryItems;\n  const parentChain = { '-1': ROOT_GROUP };\n  let lastDataIndex = 0;\n  let openGroup = '';\n  let index = 0;\n  let level = 0;\n  let prevLevel = 0;\n\n  rows.forEach((row) => {\n    const { groupedBy, compoundKey } = row;\n    if (isGroupRow(row)) {\n      level = outlineLevels[groupedBy];\n      groupTree[compoundKey] = [];\n      parentChain[level] = compoundKey;\n      if (level <= maxLevel) {\n        groupTree[parentChain[level - 1]].push(compoundKey);\n      }\n      if (level === maxLevel) {\n        if (openGroup) {\n          // close previous group\n          groupTree[openGroup].push(lastDataIndex);\n        }\n        openGroup = compoundKey;\n        if (groupSummaryExists && lastDataIndex > 0) {\n          index += 1;\n        }\n        groupTree[compoundKey].push(index + 1); // first row index\n      } else if (groupSummaryExists && level < prevLevel) {\n        // jump over summary rows\n        index += maxLevel - level;\n      }\n      prevLevel = level;\n    } else {\n      lastDataIndex = index;\n    }\n    index += 1;\n  });\n\n  if (openGroup) {\n    groupTree[openGroup].push(lastDataIndex);\n  }\n\n  return groupTree;\n};\n\nconst operations = {\n  count: 'COUNTA',\n};\nexport const exportSummaryGetter: GetExportSummaryFn = (\n  worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages,\n) => (\n  { columnName, type }, ranges,\n) => {\n  const { column } = tableColumns.find(({ column: dataColumn, type: columnType }) => (\n    columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName\n  )) || {};\n  // NOTE: column is hidden or the grid grouped by this column\n  if (!column) {\n    return;\n  }\n\n  const row = worksheet.lastRow!;\n  const letter = worksheet.getColumn(columnName).letter;\n  const operation = operations[type] || type.toUpperCase();\n  const rangesStr = ranges.map(range => (\n    range\n      .map(r => `${letter}${r}`)\n      .filter((val, index, arr) => arr.indexOf(val) === index)\n      .join(':')\n  )).join(',');\n\n  const cell = row.getCell(columnName);\n  cell.value = {\n    formula: `${operation}(${rangesStr})`,\n    date1904: false,\n  };\n  cell.numFmt = `\"${defaultSummaryMessages[type]}:\" 0`;\n\n  const summary = {\n    type,\n    ranges,\n  };\n  customizeSummaryCell(cell, column!, summary);\n};\n\nexport const closeGroupGetter: GetCloseGroupFn = (\n  worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary,\n) => rowsOffset => (group) => {\n  const { groupedBy, compoundKey } = group;\n\n  exportSummaryItems(\n    worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy],\n    rowsOffset, maxGroupLevel, exportSummary,\n  );\n};\n\nexport const maximumGroupLevel: PureComputed<[Grouping[]], number> = grouping => (\n  (grouping || []).length - 1\n);\n","import { PureComputed } from '@devexpress/dx-core';\nimport {\n  GetVisibleBoundaryWithFixedFn, VisibleBoundary, GetVisibleBoundaryFn, GetSpanBoundaryFn,\n  CollapseBoundariesFn, GetColumnsSizeFn, GetCollapsedColumnsFn, CollapsedColumn,\n  GetCollapsedAndStubRowsFn, GetCollapsedCellsFn, GetCollapsedGridFn, GetColumnWidthFn,\n  TableColumn,\n  CollapsedCell,\n  GetColumnWidthGetterFn,\n  GetCollapsedGridsFn,\n  CollapsedGrid,\n  GetSpecificRenderBoundaryFn,\n  GetRenderBoundaryFn,\n  GetRowsVisibleBoundaryFn,\n} from '../types';\nimport { TABLE_FLEX_TYPE, intervalUtil } from '..';\n\nexport const TABLE_STUB_TYPE = Symbol('stub');\n\nexport const getVisibleBoundaryWithFixed: GetVisibleBoundaryWithFixedFn = (\n  visibleBoundary, items,\n) => items.reduce((acc, item, index) => {\n  if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {\n    acc.push([index, index]);\n  }\n  return acc;\n}, [visibleBoundary] as [VisibleBoundary]);\n\nexport const getVisibleBoundary: GetVisibleBoundaryFn = (\n  items, viewportStart, viewportSize, getItemSize, offset = 0, itemSize = 0,\n) => {\n  let start: number | null = null;\n  let end: number | null = null;\n  let index = 0;\n  let beforePosition = offset * itemSize;\n\n  const viewportEnd = viewportStart + viewportSize;\n  while (end === null && index < items.length) {\n    const item = items[index];\n    const afterPosition = beforePosition + getItemSize(item)!;\n    const isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)\n      || (afterPosition > viewportStart && afterPosition <= viewportEnd)\n      || (beforePosition < viewportStart && afterPosition > viewportEnd);\n    if (isVisible && start === null) {\n      start = index;\n    }\n    if (!isVisible && start !== null) {\n      end = index - 1;\n      break;\n    }\n    index += 1;\n    beforePosition = afterPosition;\n  }\n  if (start !== null && end === null) {\n    end = index - 1;\n  }\n\n  start = start === null ? 0 : start;\n  end = end === null ? 0 : end;\n\n  return [start + offset, end + offset];\n};\n\nexport const getRenderBoundary: GetRenderBoundaryFn = (itemsCount, visibleBoundary, overscan) => {\n  let [start, end] = visibleBoundary;\n  start = Math.max(0, start - overscan);\n  end = Math.min(itemsCount - 1, end + overscan);\n\n  return [start, end];\n};\n\nexport const getColumnBoundaries: PureComputed<\n  [TableColumn[], number, number, GetColumnWidthFn], VisibleBoundary[]\n> = (columns, left, width, getColumnWidth) => (\n  getVisibleBoundaryWithFixed(\n    getColumnsRenderBoundary(\n      columns.length,\n      getVisibleBoundary(columns, left, width, getColumnWidth, 0),\n    ),\n    columns,\n  )\n);\nexport const getRowsVisibleBoundary: GetRowsVisibleBoundaryFn = (\n  rows, top, height, getRowHeight, offset, rowHeight, isDataRemote,\n) => {\n  const beforePosition = offset * rowHeight;\n  const noVisibleRowsLoaded = rowHeight > 0 &&\n    beforePosition + rows.length * rowHeight < top ||\n    top < beforePosition;\n\n  let boundaries;\n  if (isDataRemote && noVisibleRowsLoaded) {\n    const topIndex = Math.round(top / rowHeight);\n    boundaries = [topIndex, topIndex];\n  } else {\n    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);\n  }\n\n  return boundaries;\n};\n\nexport const getColumnsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  columnCount, visibleBoundary,\n) => getRenderBoundary(columnCount, visibleBoundary, 1);\n\nexport const getRowsRenderBoundary: GetSpecificRenderBoundaryFn = (\n  rowsCount, visibleBoundary,\n) => getRenderBoundary(rowsCount, visibleBoundary, 3);\n\nexport const getSpanBoundary: GetSpanBoundaryFn = (\n  items, visibleBoundaries, getItemSpan,\n) => visibleBoundaries\n  .map((visibleBoundary) => {\n    const endIndex = Math.min(visibleBoundary[1], items.length - 1);\n    let end = endIndex;\n    let start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;\n\n    for (let index = 0; index <= endIndex; index += 1) {\n      const span = getItemSpan(items[index]);\n      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {\n        start = index;\n      }\n      if (index + (span - 1) > visibleBoundary[1]) {\n        end = index + (span - 1);\n      }\n    }\n    return [start, end] as VisibleBoundary;\n  });\n\nexport const collapseBoundaries: CollapseBoundariesFn = (\n  itemsCount, visibleBoundaries, spanBoundaries,\n) => {\n  const breakpoints = new Set([0, itemsCount]);\n  spanBoundaries.forEach(rowBoundaries => rowBoundaries\n    .forEach((boundary) => {\n      breakpoints.add(boundary[0]);\n      // next interval starts after span end point\n      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));\n    }));\n\n  visibleBoundaries\n    .filter(boundary => boundary.every(bound => 0 <= bound && bound < itemsCount))\n    .forEach((boundary) => {\n      for (let point = boundary[0]; point <= boundary[1]; point += 1) {\n        breakpoints.add(point);\n      }\n      if (boundary[1] + 1 < itemsCount) {\n        // close last visible point\n        breakpoints.add(boundary[1] + 1);\n      }\n    });\n\n  const bp = [...breakpoints].sort((a, b) => a - b);\n  const bounds: any[] = [];\n  for (let i = 0; i < bp.length - 1; i += 1) {\n    bounds.push([\n      bp[i],\n      bp[i + 1] - 1,\n    ]);\n  }\n\n  return bounds;\n};\n\nconst getColumnsSize: GetColumnsSizeFn = (columns, startIndex, endIndex, getColumnSize) => {\n  let size = 0;\n  for (let i = startIndex; i <= endIndex; i += 1) {\n    size += getColumnSize(columns[i], 0) || 0;\n  }\n  return size;\n};\n\nexport const getCollapsedColumns: GetCollapsedColumnsFn = (\n  columns, visibleBoundaries, boundaries, getColumnWidth,\n) => {\n  const collapsedColumns: CollapsedColumn[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundaries.reduce((acc, visibleBoundary) => (\n      acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])\n    ), false);\n\n    if (isVisible) {\n      const column = columns[boundary[0]];\n      collapsedColumns.push({\n        ...column,\n        width: getColumnWidth(column) as number,\n      });\n    } else {\n      collapsedColumns.push({\n        key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n        type: TABLE_STUB_TYPE,\n        width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),\n      });\n    }\n  });\n  return collapsedColumns;\n};\n\nexport const getCollapsedRows: GetCollapsedAndStubRowsFn = (\n  rows, visibleBoundary, boundaries, getRowHeight, getCells, offset,\n) => {\n  const collapsedRows: any[] = [];\n  boundaries.forEach((boundary) => {\n    const isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];\n    if (isVisible) {\n      const row = rows[boundary[0] - offset];\n      collapsedRows.push({\n        row,\n        cells: getCells(row),\n      });\n    } else {\n      const row = {} as any;\n      collapsedRows.push({\n        row: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n          height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),\n        },\n        cells: getCells(row),\n      });\n    }\n  });\n  return collapsedRows;\n};\n\nexport const getCollapsedCells: GetCollapsedCellsFn = (\n  columns, spanBoundaries, boundaries, getColSpan,\n) => {\n  const collapsedCells: CollapsedCell[] = [];\n  let index = 0;\n  while (index < boundaries.length) {\n    const boundary = boundaries[index];\n    const isSpan = spanBoundaries.reduce((acc, spanBoundary) => (\n      acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])), false);\n    if (isSpan) {\n      const column = columns[boundary[0]];\n      const realColSpan = getColSpan(column);\n      const realColSpanEnd = (realColSpan + boundary[0]) - 1;\n      const colSpanEnd = boundaries.findIndex(\n        colSpanBoundary => colSpanBoundary[0]\n        <= realColSpanEnd && realColSpanEnd\n        <= colSpanBoundary[1],\n      );\n      collapsedCells.push({\n        column,\n        colSpan: (colSpanEnd - index) + 1,\n      });\n      index += 1;\n    } else {\n      collapsedCells.push({\n        column: {\n          key: `${TABLE_STUB_TYPE.toString()}_${boundary[0]}_${boundary[1]}`,\n          type: TABLE_STUB_TYPE,\n        },\n        colSpan: 1,\n      });\n      index += 1;\n    }\n  }\n  return collapsedCells;\n};\n\nexport const getCollapsedGrid: GetCollapsedGridFn = ({\n  rows,\n  columns,\n  rowsVisibleBoundary,\n  columnsVisibleBoundary,\n  getColumnWidth = (column: any) => column.width,\n  getRowHeight = (row: any) => row.height,\n  getColSpan = () => 1,\n  totalRowCount,\n  offset,\n}) => {\n  if (!columns.length) {\n    return {\n      columns: [],\n      rows: [],\n    };\n  }\n\n  const boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];\n\n  const rowSpanBoundaries = rows\n    .slice(boundaries[0], boundaries[1])\n    .map(row => getSpanBoundary(\n      columns,\n      columnsVisibleBoundary,\n      column => getColSpan(row, column),\n    ));\n  const columnBoundaries = collapseBoundaries(\n    columns.length,\n    columnsVisibleBoundary,\n    rowSpanBoundaries,\n  );\n\n  const rowBoundaries = collapseBoundaries(totalRowCount!, [boundaries], []);\n\n  return {\n    columns: getCollapsedColumns(\n      columns,\n      columnsVisibleBoundary,\n      columnBoundaries,\n      getColumnWidth,\n    ),\n    rows: getCollapsedRows(\n      rows,\n      boundaries,\n      rowBoundaries,\n      getRowHeight,\n      row => getCollapsedCells(\n        columns,\n        getSpanBoundary(\n          columns,\n          columnsVisibleBoundary,\n          column => getColSpan(row, column),\n        ),\n        columnBoundaries,\n        column => getColSpan(row, column),\n      ),\n      offset,\n    ),\n  };\n};\n\nexport const getColumnWidthGetter: GetColumnWidthGetterFn = (\n  tableColumns, tableWidth, minColumnWidth,\n) => {\n  const colsHavingWidth = tableColumns.filter(col => typeof col.width === 'number');\n  const columnsWidth = colsHavingWidth.reduce((acc, col) => (acc + (col.width as number)!), 0);\n  const autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);\n  const autoColWidth = Math.max(autoWidth, minColumnWidth!);\n\n  return column => (column.type === TABLE_FLEX_TYPE\n    ? null\n    : typeof column.width === 'number' ? column.width : autoColWidth);\n};\n\nexport const getCollapsedGrids: GetCollapsedGridsFn = ({\n    headerRows = [],\n    bodyRows = [],\n    footerRows = [],\n    columns,\n    loadedRowsStart,\n    totalRowCount,\n    getCellColSpan,\n    viewport,\n    getRowHeight,\n    getColumnWidth,\n  },\n) => {\n  const getColSpan = (\n    tableRow: any, tableColumn: any,\n  ) => getCellColSpan!({ tableRow, tableColumn, tableColumns: columns });\n\n  const getCollapsedGridBlock: PureComputed<\n    [any[], any[]?, number?, number?], CollapsedGrid\n  > = (\n    rows, rowsVisibleBoundary, rowCount = rows.length, offset = 0,\n  ) => getCollapsedGrid({\n    rows,\n    columns,\n    rowsVisibleBoundary,\n    columnsVisibleBoundary: viewport.columns,\n    getColumnWidth,\n    getRowHeight,\n    getColSpan,\n    totalRowCount: rowCount,\n    offset,\n  });\n\n  const headerGrid = getCollapsedGridBlock(\n    headerRows, getRenderRowBounds(viewport.headerRows, headerRows.length),\n  );\n  const bodyGrid = getCollapsedGridBlock(\n    bodyRows,\n    adjustedRenderRowBounds(\n      viewport.rows, bodyRows.length, loadedRowsStart,\n    ),\n    totalRowCount || 1,\n    loadedRowsStart,\n  );\n  const footerGrid = getCollapsedGridBlock(\n    footerRows, getRenderRowBounds(viewport.footerRows, footerRows.length),\n  );\n\n  return {\n    headerGrid,\n    bodyGrid,\n    footerGrid,\n  };\n};\n\nconst getRenderRowBounds: PureComputed<[VisibleBoundary, number], number[]> = (\n  visibleBounds, rowCount,\n) => getRowsRenderBoundary(\n  rowCount,\n  visibleBounds,\n);\n\nconst adjustedRenderRowBounds: PureComputed<[VisibleBoundary, number, number], number[]> = (\n  visibleBounds, rowCount, loadedRowsStart,\n) => {\n  const renderRowBoundaries = getRenderRowBounds(\n    visibleBounds, loadedRowsStart + rowCount,\n  );\n  const adjustedInterval = intervalUtil.intersect(\n    { start: renderRowBoundaries[0], end: renderRowBoundaries[1] },\n    { start: loadedRowsStart, end: loadedRowsStart + rowCount },\n  );\n  return [adjustedInterval.start, adjustedInterval.end];\n};\n","import { PureComputed } from '@devexpress/dx-core';\nimport { TABLE_GROUP_TYPE } from './constants';\nimport { TableRow, TableColumn, IsSpecificCellFn, Grouping, GroupSummaryItem } from '../../types';\nimport { TABLE_STUB_TYPE } from '../../utils/virtual-table';\n\ntype IsGroupIndentCellFn = PureComputed<[TableRow, TableColumn, Grouping[]], boolean>;\n\nconst getGroupIndexByColumn: PureComputed<[Grouping[], TableColumn], number> = (\n  grouping, tableColumn,\n) => grouping.findIndex(\n  columnGrouping => !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name,\n);\n\nconst isIndentCell: IsGroupIndentCellFn = (\n    tableRow,\n    tableColumn,\n    grouping,\n  ) => {\n  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name) return false;\n  const rowGroupIndex = grouping.findIndex(\n    columnGrouping => columnGrouping.columnName === tableRow.row.groupedBy,\n  );\n  const columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);\n\n  return columnGroupIndex < rowGroupIndex;\n};\n\nexport const isGroupTableCell: IsSpecificCellFn = (\n  tableRow, tableColumn,\n) => !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE\n  && tableColumn.column\n  && tableColumn.column.name === tableRow.row.groupedBy);\n\nexport const isGroupIndentTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&\n  isIndentCell(tableRow, tableColumn, grouping)\n);\n\nexport const isGroupIndentStubTableCell: IsGroupIndentCellFn = (\n  tableRow, tableColumn, grouping,\n) => (\n  (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&\n    isIndentCell(tableRow, tableColumn, grouping))\n);\n\nexport const isGroupTableRow = (tableRow: TableRow) => tableRow.type === TABLE_GROUP_TYPE;\n\nexport const isGroupRowOrdinaryCell: IsSpecificCellFn = (tableRow, tableColumn) => (\n  isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)\n);\n\nconst columnHasGroupRowSummary: PureComputed<[TableColumn, GroupSummaryItem[]], boolean> = (\n  tableColumn, groupSummaryItems,\n) => (\n  !!(groupSummaryItems && groupSummaryItems\n    .some(item => (\n      (!item.showInGroupFooter && item.alignByColumn)\n        && item.columnName === (tableColumn.column && tableColumn.column.name)\n    )))\n);\n\nexport const isRowSummaryCell: PureComputed<\n  [TableRow, TableColumn, Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, grouping, groupSummaryItems,\n) => (\n  columnHasGroupRowSummary(tableColumn, groupSummaryItems)\n  && !isGroupIndentTableCell(tableRow, tableColumn, grouping)\n);\n\nexport const isPreviousCellContainSummary: PureComputed<\n  [TableRow, TableColumn, TableColumn[], Grouping[], GroupSummaryItem[]], boolean\n> = (\n  tableRow, tableColumn, tableColumns, grouping, groupSummaryItems,\n) => {\n  const columnIndex = tableColumns.indexOf(tableColumn);\n  return columnIndex > 0 && isRowSummaryCell(\n    tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems,\n  );\n};\n\nexport const calculateGroupCellIndent: PureComputed<[TableColumn, Grouping[], number], number> = (\n  tableColumn, grouping, indentWidth,\n) => (\n  indentWidth * getGroupIndexByColumn(grouping, tableColumn)\n);\n"]},"metadata":{},"sourceType":"module"}