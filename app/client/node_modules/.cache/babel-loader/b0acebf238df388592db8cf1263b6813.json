{"ast":null,"code":"import { Result, ResultType } from './result';\nimport { Stream } from './stream';\n\nvar toArray = function (value) {\n  return (value || '').split('');\n};\n\nvar ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(parse) {\n    this.parse = parse;\n  }\n\n  Parser.prototype.run = function (input, control) {\n    if (control === void 0) {\n      control = '';\n    }\n\n    if (input instanceof Stream) {\n      return this.parse(input);\n    } else {\n      return this.parse(new Stream(toArray(input), toArray(control)));\n    }\n  }; // map :: Functor f => f a ~> (a -> b) -> f b\n\n\n  Parser.prototype.map = function (f) {\n    var _this = this;\n\n    return new Parser(function (stream) {\n      return _this.parse(stream).map(f);\n    });\n  }; // chain :: Chain m => m a ~> (a -> m b) -> m b\n\n\n  Parser.prototype.chain = function (f) {\n    var _this = this;\n\n    return new Parser(function (stream) {\n      return _this.parse(stream).chain(function (v, s) {\n        return f(v).run(s);\n      });\n    });\n  };\n\n  Parser.prototype.isLiteral = function (c) {\n    return this.run(c).type === ResultType.Literal;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\n * @hidden\n */\n\nexport var mask = function (_a) {\n  var prompt = _a.prompt,\n      promptPlaceholder = _a.promptPlaceholder;\n  return function (rule) {\n    return new Parser(function (stream) {\n      while (!stream.eof()) {\n        var _a = stream.peek(),\n            char = _a.char,\n            control = _a.control;\n\n        if (char === control && control === prompt) {\n          stream.eat();\n          return new Result(prompt, stream, ResultType.Mask);\n        }\n\n        if (rule.test(char)) {\n          stream.eat();\n          return new Result(char, stream, ResultType.Mask);\n        }\n\n        if (char === promptPlaceholder) {\n          stream.eat();\n          return new Result(prompt, stream, ResultType.Mask);\n        }\n\n        stream.eat_input();\n      }\n\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    });\n  };\n};\n/**\n * @hidden\n */\n\nexport var literal = function (_token) {\n  return new Parser(function (stream) {\n    //    let {char, control} = stream.peek();\n    var char = stream.peek().char;\n\n    if (char === _token) {\n      stream.eat();\n      return new Result(_token, stream, ResultType.Literal);\n    } //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n\n\n    return new Result(_token, stream, ResultType.Literal);\n  });\n};\n/**\n * @hidden\n */\n\nexport var unmask = function (prompt) {\n  return function (rule) {\n    return new Parser(function (stream) {\n      while (!stream.eof()) {\n        var _a = stream.peek(),\n            char = _a.char,\n            control = _a.control;\n\n        if (char === prompt && control === prompt) {\n          stream.eat();\n          return new Result(char, stream);\n        }\n\n        if (rule.test(char)) {\n          stream.eat();\n          return new Result(char, stream);\n        }\n\n        stream.eat_input();\n      }\n\n      stream.eat();\n      return new Result('', stream);\n    });\n  };\n};\n/**\n * @hidden\n */\n\nexport var unliteral = function (_token) {\n  return new Parser(function (stream) {\n    if (stream.eof()) {\n      return new Result('', stream);\n    }\n\n    var char = stream.peek().char;\n\n    if (char === _token) {\n      stream.eat();\n    }\n\n    return new Result(_token, stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var token = function (rules, creator) {\n  return new Parser(function (stream) {\n    var char = stream.next().char;\n    var rule = rules[char];\n\n    if (char === ESCAPE_CHARACTER) {\n      char = stream.next().char;\n      return new Result(creator.literal(char), stream);\n    }\n\n    if (!rule) {\n      return new Result(creator.literal(char), stream);\n    }\n\n    return new Result(creator.mask(rule), stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var rawMask = function (_a) {\n  var prompt = _a.prompt,\n      promptPlaceholder = _a.promptPlaceholder;\n  return new Parser(function (stream) {\n    var char = stream.next().char;\n\n    if (char === prompt) {\n      return new Result(promptPlaceholder, stream);\n    }\n\n    return new Result(char, stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var rawLiteral = function (includeLiterals) {\n  return new Parser(function (stream) {\n    var char = stream.next().char;\n\n    if (includeLiterals) {\n      return new Result(char, stream);\n    }\n\n    return new Result('', stream);\n  });\n};","map":{"version":3,"sources":["../../../../src/maskedtextbox/parsing/parsers.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,EAAiB,UAAjB,QAAmC,UAAnC;AACA,SAAS,MAAT,QAAuB,UAAvB;;AAEA,IAAM,OAAO,GAAG,UAAC,KAAD,EAAc;AAAK,SAAA,CAAC,KAAK,IAAI,EAAV,EAAc,KAAd,CAAA,EAAA,CAAA;AAAuB,CAA1D;;AAEA,IAAM,gBAAgB,GAAG,IAAzB;AAEA;;;;AAGA,IAAA,MAAA;AAAA;AAAA,YAAA;AACI,WAAA,MAAA,CAAoB,KAApB,EAAmC;AAAf,SAAA,KAAA,GAAA,KAAA;AAAoB;;AAEjC,EAAA,MAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,KAAX,EAAmC,OAAnC,EAAuD;AAApB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAoB;;AACnD,QAAI,KAAK,YAAY,MAArB,EAA6B;AACzB,aAAO,KAAK,KAAL,CAAW,KAAX,CAAP;AACH,KAFD,MAEO;AACH,aAAO,KAAK,KAAL,CAAW,IAAI,MAAJ,CAAW,OAAO,CAAC,KAAD,CAAlB,EAA2B,OAAO,CAAC,OAAD,CAAlC,CAAX,CAAP;AACH;AACJ,GANM,CAHX,CAWI;;;AACO,EAAA,MAAA,CAAA,SAAA,CAAA,GAAA,GAAP,UAAW,CAAX,EAAsB;AAAtB,QAAA,KAAA,GAAA,IAAA;;AACI,WAAO,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAAI,aAAA,KAAI,CAAC,KAAL,CAAW,MAAX,EAAmB,GAAnB,CAAA,CAAA,CAAA;AAAyB,KAA9C,CAAP;AACH,GAFM,CAZX,CAgBI;;;AACO,EAAA,MAAA,CAAA,SAAA,CAAA,KAAA,GAAP,UAAa,CAAb,EAAwB;AAAxB,QAAA,KAAA,GAAA,IAAA;;AACI,WAAO,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAAI,aAAA,KAAI,CAAC,KAAL,CAAW,MAAX,EAAmB,KAAnB,CAAyB,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,eAAA,CAAC,CAAC,CAAD,CAAD,CAAK,GAAL,CAAA,CAAA,CAAA;AAAnC,OAAA,CAAA;AAA+C,KAApE,CAAP;AACH,GAFM;;AAIA,EAAA,MAAA,CAAA,SAAA,CAAA,SAAA,GAAP,UAAiB,CAAjB,EAA0B;AACtB,WAAO,KAAK,GAAL,CAAS,CAAT,EAAY,IAAZ,KAAqB,UAAU,CAAC,OAAvC;AACH,GAFM;;AAGX,SAAA,MAAA;AAAC,CAxBD,EAAA;;;AA0BA;;;;AAGA,OAAO,IAAM,IAAI,GAAG,UAAC,EAAD,EAA4B;MAA1B,MAAA,GAAA,EAAA,CAAA,M;MAAQ,iBAAA,GAAA,EAAA,CAAA,iB;AAAuB,SAAA,UAAA,IAAA,EAAI;AAAI,WAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAC1E,aAAO,CAAC,MAAM,CAAC,GAAP,EAAR,EAAsB;AACZ,YAAA,EAAA,GAAA,MAAA,CAAA,IAAA,EAAA;AAAA,YAAC,IAAA,GAAA,EAAA,CAAA,IAAD;AAAA,YAAO,OAAA,GAAA,EAAA,CAAA,OAAP;;AAEN,YAAI,IAAI,KAAK,OAAT,IAAoB,OAAO,KAAK,MAApC,EAA4C;AACxC,UAAA,MAAM,CAAC,GAAP;AACA,iBAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,EAA2B,UAAU,CAAC,IAAtC,CAAP;AACH;;AAED,YAAI,IAAI,CAAC,IAAL,CAAU,IAAV,CAAJ,EAAqB;AACjB,UAAA,MAAM,CAAC,GAAP;AACA,iBAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,MAAjB,EAAyB,UAAU,CAAC,IAApC,CAAP;AACH;;AAED,YAAI,IAAI,KAAK,iBAAb,EAAgC;AAC5B,UAAA,MAAM,CAAC,GAAP;AACA,iBAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,EAA2B,UAAU,CAAC,IAAtC,CAAP;AACH;;AAED,QAAA,MAAM,CAAC,SAAP;AACH;;AAED,MAAA,MAAM,CAAC,GAAP;AACA,aAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,EAA2B,UAAU,CAAC,IAAtC,CAAP;AAvByD,KAAA,CAAA;AAwB3D,GAxBmD;AAwBnD,CAxBK;AA0BP;;;;AAGA,OAAO,IAAM,OAAO,GAAG,UAAA,MAAA,EAAM;AAAI,SAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAClD;AACI,QAAI,IAAI,GAAG,MAAM,CAAC,IAAP,GAAc,IAAzB;;AAEA,QAAI,IAAI,KAAK,MAAb,EAAqB;AACjB,MAAA,MAAM,CAAC,GAAP;AACA,aAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,EAA2B,UAAU,CAAC,OAAtC,CAAP;AACH,KAP6C,CASlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEI,WAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,EAA2B,UAAU,CAAC,OAAtC,CAAP;AApB6B,GAAA,CAAA;AAqB/B,CArBK;AAuBP;;;;AAGA,OAAO,IAAM,MAAM,GAAG,UAAA,MAAA,EAAM;AAAI,SAAA,UAAA,IAAA,EAAI;AAAI,WAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AACrD,aAAO,CAAC,MAAM,CAAC,GAAP,EAAR,EAAsB;AACZ,YAAA,EAAA,GAAA,MAAA,CAAA,IAAA,EAAA;AAAA,YAAE,IAAA,GAAA,EAAA,CAAA,IAAF;AAAA,YAAQ,OAAA,GAAA,EAAA,CAAA,OAAR;;AAEN,YAAI,IAAI,KAAK,MAAT,IAAmB,OAAO,KAAK,MAAnC,EAA2C;AACvC,UAAA,MAAM,CAAC,GAAP;AACA,iBAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,MAAjB,CAAP;AACH;;AAED,YAAI,IAAI,CAAC,IAAL,CAAU,IAAV,CAAJ,EAAqB;AACjB,UAAA,MAAM,CAAC,GAAP;AACA,iBAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,MAAjB,CAAP;AACH;;AAED,QAAA,MAAM,CAAC,SAAP;AACH;;AAED,MAAA,MAAM,CAAC,GAAP;AACA,aAAO,IAAI,MAAJ,CAAW,EAAX,EAAe,MAAf,CAAP;AAlBoC,KAAA,CAAA;AAAR,GAAA;AAmB9B,CAnBK;AAqBP;;;;AAGA,OAAO,IAAM,SAAS,GAAG,UAAA,MAAA,EAAM;AAAI,SAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAChD,QAAI,MAAM,CAAC,GAAP,EAAJ,EAAkB;AACd,aAAO,IAAI,MAAJ,CAAW,EAAX,EAAe,MAAf,CAAP;AACH;;AAEO,QAAA,IAAA,GAAA,MAAA,CAAA,IAAA,GAAA,IAAA;;AAER,QAAI,IAAI,KAAK,MAAb,EAAqB;AACjB,MAAA,MAAM,CAAC,GAAP;AACH;;AAED,WAAO,IAAI,MAAJ,CAAW,MAAX,EAAmB,MAAnB,CAAP;AAX+B,GAAA,CAAA;AAYjC,CAZK;AAcP;;;;AAGA,OAAO,IAAM,KAAK,GAAG,UAAC,KAAD,EAAQ,OAAR,EAAe;AAAK,SAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAChD,QAAA,IAAA,GAAA,MAAA,CAAA,IAAA,GAAA,IAAA;AACN,QAAM,IAAI,GAAG,KAAK,CAAC,IAAD,CAAlB;;AAEA,QAAI,IAAI,KAAK,gBAAb,EAA+B;AAC3B,MAAA,IAAI,GAAG,MAAM,CAAC,IAAP,GAAc,IAArB;AAEA,aAAO,IAAI,MAAJ,CAAW,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAX,EAAkC,MAAlC,CAAP;AACH;;AAED,QAAI,CAAC,IAAL,EAAW;AACP,aAAO,IAAI,MAAJ,CAAW,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAX,EAAkC,MAAlC,CAAP;AACH;;AAED,WAAO,IAAI,MAAJ,CAAW,OAAO,CAAC,IAAR,CAAa,IAAb,CAAX,EAA+B,MAA/B,CAAP;AAdqC,GAAA,CAAA;AAevC,CAfK;AAiBP;;;;AAGA,OAAO,IAAM,OAAO,GAAG,UAAC,EAAD,EAA4B;MAA1B,MAAA,GAAA,EAAA,CAAA,M;MAAQ,iBAAA,GAAA,EAAA,CAAA,iB;AAAuB,SAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AAC/D,QAAA,IAAA,GAAA,MAAA,CAAA,IAAA,GAAA,IAAA;;AAEN,QAAI,IAAI,KAAK,MAAb,EAAqB;AACjB,aAAO,IAAI,MAAJ,CAAW,iBAAX,EAA8B,MAA9B,CAAP;AACH;;AAED,WAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,MAAjB,CAAP;AACH,GARuD,CAAA;AAQtD,CARK;AAUP;;;;AAGA,OAAO,IAAM,UAAU,GAAG,UAAA,eAAA,EAAe;AAAI,SAAA,IAAI,MAAJ,CAAW,UAAA,MAAA,EAAM;AACpD,QAAA,IAAA,GAAA,MAAA,CAAA,IAAA,GAAA,IAAA;;AAEN,QAAI,eAAJ,EAAqB;AACjB,aAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,MAAjB,CAAP;AACH;;AAED,WAAO,IAAI,MAAJ,CAAW,EAAX,EAAe,MAAf,CAAP;AAPyC,GAAA,CAAA;AAQ3C,CARK","sourceRoot":"","sourcesContent":["import { Result, ResultType } from './result';\nimport { Stream } from './stream';\nvar toArray = function (value) { return (value || '').split(''); };\nvar ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nvar Parser = /** @class */ (function () {\n    function Parser(parse) {\n        this.parse = parse;\n    }\n    Parser.prototype.run = function (input, control) {\n        if (control === void 0) { control = ''; }\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    };\n    // map :: Functor f => f a ~> (a -> b) -> f b\n    Parser.prototype.map = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).map(f); });\n    };\n    // chain :: Chain m => m a ~> (a -> m b) -> m b\n    Parser.prototype.chain = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).chain(function (v, s) { return f(v).run(s); }); });\n    };\n    Parser.prototype.isLiteral = function (c) {\n        return this.run(c).type === ResultType.Literal;\n    };\n    return Parser;\n}());\nexport { Parser };\n/**\n * @hidden\n */\nexport var mask = function (_a) {\n    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;\n    return function (rule) { return new Parser(function (stream) {\n        while (!stream.eof()) {\n            var _a = stream.peek(), char = _a.char, control = _a.control;\n            if (char === control && control === prompt) {\n                stream.eat();\n                return new Result(prompt, stream, ResultType.Mask);\n            }\n            if (rule.test(char)) {\n                stream.eat();\n                return new Result(char, stream, ResultType.Mask);\n            }\n            if (char === promptPlaceholder) {\n                stream.eat();\n                return new Result(prompt, stream, ResultType.Mask);\n            }\n            stream.eat_input();\n        }\n        stream.eat();\n        return new Result(prompt, stream, ResultType.Mask);\n    }); };\n};\n/**\n * @hidden\n */\nexport var literal = function (_token) { return new Parser(function (stream) {\n    //    let {char, control} = stream.peek();\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n}); };\n/**\n * @hidden\n */\nexport var unmask = function (prompt) { return function (rule) { return new Parser(function (stream) {\n    while (!stream.eof()) {\n        var _a = stream.peek(), char = _a.char, control = _a.control;\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n}); }; };\n/**\n * @hidden\n */\nexport var unliteral = function (_token) { return new Parser(function (stream) {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n}); };\n/**\n * @hidden\n */\nexport var token = function (rules, creator) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    var rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n}); };\n/**\n * @hidden\n */\nexport var rawMask = function (_a) {\n    var prompt = _a.prompt, promptPlaceholder = _a.promptPlaceholder;\n    return new Parser(function (stream) {\n        var char = stream.next().char;\n        if (char === prompt) {\n            return new Result(promptPlaceholder, stream);\n        }\n        return new Result(char, stream);\n    });\n};\n/**\n * @hidden\n */\nexport var rawLiteral = function (includeLiterals) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n}); };\n//# sourceMappingURL=parsers.js.map"]},"metadata":{},"sourceType":"module"}