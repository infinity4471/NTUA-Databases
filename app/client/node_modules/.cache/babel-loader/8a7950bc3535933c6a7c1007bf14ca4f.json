{"ast":null,"code":"import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport { deg, rad, round } from '../util';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\n\nvar Arc = function (Class) {\n  function Arc(center, options) {\n    if (center === void 0) center = new Point();\n    if (options === void 0) options = {};\n    Class.call(this);\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n\n  if (Class) Arc.__proto__ = Class;\n  Arc.prototype = Object.create(Class && Class.prototype);\n  Arc.prototype.constructor = Arc;\n\n  Arc.prototype.clone = function clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  };\n\n  Arc.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Arc.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n\n  Arc.prototype.pointAt = function pointAt(angle) {\n    var center = this.center;\n    var radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  };\n\n  Arc.prototype.curvePoints = function curvePoints() {\n    var this$1 = this;\n    var startAngle = this.startAngle;\n    var dir = this.anticlockwise ? -1 : 1;\n    var curvePoints = [this.pointAt(startAngle)];\n\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    var subIntervalAngle = intervalAngle / subIntervalsCount;\n    var currentAngle = startAngle;\n    var transformation;\n\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n\n    for (var i = 1; i <= subIntervalsCount; i++) {\n      var nextAngle = currentAngle + dir * subIntervalAngle;\n\n      var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n\n    return curvePoints;\n  };\n\n  Arc.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n\n    var interval = this._arcInterval();\n\n    var startAngle = interval.startAngle;\n    var endAngle = interval.endAngle;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    var extremeX = deg(extremeAngles.x);\n    var extremeY = deg(extremeAngles.y);\n    var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    var currentAngleX = bboxStartAngle(extremeX, startAngle);\n    var currentAngleY = bboxStartAngle(extremeY, startAngle);\n    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    var minPoint = Point.min(currentPoint, endPoint);\n    var maxPoint = Point.max(currentPoint, endPoint);\n\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      var currentPointX = void 0;\n\n      if (currentAngleX < endAngle) {\n        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n\n      var currentPointY = void 0;\n\n      if (currentAngleY < endAngle) {\n        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n\n  Arc.prototype._arcInterval = function _arcInterval() {\n    var ref = this;\n    var startAngle = ref.startAngle;\n    var endAngle = ref.endAngle;\n    var anticlockwise = ref.anticlockwise;\n\n    if (anticlockwise) {\n      var oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  };\n\n  Arc.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {\n    var p1 = this.pointAt(startAngle);\n    var p2 = this.pointAt(endAngle);\n\n    var p1Derivative = this._derivativeAt(startAngle);\n\n    var p2Derivative = this._derivativeAt(endAngle);\n\n    var t = (rad(endAngle) - rad(startAngle)) / 3;\n    var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  };\n\n  Arc.prototype._derivativeAt = function _derivativeAt(angle) {\n    var radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  };\n\n  Arc.prototype.containsPoint = function containsPoint(point) {\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var ref = this;\n    var center = ref.center;\n    var radiusX = ref.radiusX;\n    var radiusY = ref.radiusY;\n    var distance = center.distanceTo(point);\n    var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    var containsPoint;\n\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n\n      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n\n    return containsPoint;\n  };\n\n  Arc.prototype._isOnPath = function _isOnPath(point, width) {\n    var interval = this._arcInterval();\n\n    var center = this.center;\n    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n\n    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  };\n\n  Arc.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    var arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  };\n\n  return Arc;\n}(Class);\n\ndefineAccessors(Arc.prototype, [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"]);\nObserversMixin.extend(Arc.prototype);\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  var cos = round((x - cx) / rx, 3);\n  var sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n  var x1 = parameters.x1;\n  var y1 = parameters.y1;\n  var x2 = parameters.x2;\n  var y2 = parameters.y2;\n  var rx = parameters.rx;\n  var ry = parameters.ry;\n  var largeArc = parameters.largeArc;\n  var swipe = parameters.swipe;\n  var rotation = parameters.rotation;\n  if (rotation === void 0) rotation = 0;\n  var radians = rad(rotation);\n  var cosine = Math.cos(radians);\n  var sine = Math.sin(radians);\n  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  var sign = largeArc !== swipe ? 1 : -1;\n  var xt2 = Math.pow(xT, 2);\n  var yt2 = Math.pow(yT, 2);\n  var rx2 = Math.pow(rx, 2);\n  var ry2 = Math.pow(ry, 2);\n  var delta = xt2 / rx2 + yt2 / ry2;\n\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n\n  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n\n  var cxT = constT * (rx * yT) / ry;\n  var cyT = -constT * (ry * xT) / rx;\n  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  var uX = (xT - cxT) / rx;\n  var uY = (yT - cyT) / ry;\n  var vX = -(xT + cxT) / rx;\n  var vY = -(yT + cyT) / ry;\n  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n\n  var endAngle = startAngle + angle;\n  var signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\n\nfunction bboxStartAngle(angle, start) {\n  var startAngle = angle;\n\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n\n  return startAngle;\n}\n\nexport default Arc;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js"],"names":["defineAccessors","ObserversMixin","Class","deg","rad","round","closeOrLess","lineIntersection","ellipseExtremeAngles","PRECISION","Point","Rect","transform","MAX_INTERVAL","pow","Math","Arc","center","options","call","setCenter","radiusX","radiusY","startAngle","endAngle","anticlockwise","xRotation","__proto__","prototype","Object","create","constructor","clone","value","_observerField","geometryChange","getCenter","pointAt","angle","radian","x","cos","y","sin","curvePoints","this$1","dir","interval","_arcInterval","intervalAngle","subIntervalsCount","ceil","subIntervalAngle","currentAngle","transformation","rotate","i","nextAngle","points","_intervalCurvePoints","push","cp1","cp2","p2","bbox","matrix","extremeAngles","extremeX","extremeY","endPoint","transformCopy","currentAngleX","bboxStartAngle","currentAngleY","currentPoint","minPoint","min","maxPoint","max","currentPointX","currentPointY","fromPoints","ref","oldStart","p1","p1Derivative","_derivativeAt","p2Derivative","t","containsPoint","point","distance","distanceTo","angleRad","atan2","pointRadius","sqrt","startPoint","intersection","calculateAngle","inAngleRange","equals","_isOnPath","width","start","end","rx","ry","largeArc","swipe","rotation","arcParameters","normalizeArcParameters","x1","y1","x2","y2","extend","cx","cy","parameters","radians","cosine","sine","xT","yT","sign","xt2","yt2","rx2","ry2","delta","constT","isNaN","cxT","cyT","uX","uY","vX","vY","acos","angleCosine","signEndAngle","abs"],"mappings":"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","sourcesContent":["import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport { deg, rad, round } from '../util';\n\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\n\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\n\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\n\nvar Arc = (function (Class) {\n    function Arc(center, options) {\n        if ( center === void 0 ) center = new Point();\n        if ( options === void 0 ) options = {};\n\n        Class.call(this);\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    if ( Class ) Arc.__proto__ = Class;\n    Arc.prototype = Object.create( Class && Class.prototype );\n    Arc.prototype.constructor = Arc;\n\n    Arc.prototype.clone = function clone () {\n        return new Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    };\n\n    Arc.prototype.setCenter = function setCenter (value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    };\n\n    Arc.prototype.getCenter = function getCenter () {\n        return this.center;\n    };\n\n    Arc.prototype.pointAt = function pointAt (angle) {\n        var center = this.center;\n        var radian = rad(angle);\n\n        return new Point(\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    };\n\n    Arc.prototype.curvePoints = function curvePoints () {\n        var this$1 = this;\n\n        var startAngle = this.startAngle;\n        var dir = this.anticlockwise ? -1 : 1;\n        var curvePoints = [ this.pointAt(startAngle) ];\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        var subIntervalAngle = intervalAngle / subIntervalsCount;\n        var currentAngle = startAngle;\n        var transformation;\n        if (this.xRotation) {\n            transformation = transform().rotate(this.xRotation, this.center);\n        }\n\n        for (var i = 1; i <= subIntervalsCount; i++) {\n            var nextAngle = currentAngle + dir * subIntervalAngle;\n            var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    };\n\n    Arc.prototype.bbox = function bbox (matrix) {\n        var this$1 = this;\n\n        var interval = this._arcInterval();\n        var startAngle = interval.startAngle;\n        var endAngle = interval.endAngle;\n        var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n        var extremeX = deg(extremeAngles.x);\n        var extremeY = deg(extremeAngles.y);\n        var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        var currentAngleX = bboxStartAngle(extremeX, startAngle);\n        var currentAngleY = bboxStartAngle(extremeY, startAngle);\n        var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        var minPoint = Point.min(currentPoint, endPoint);\n        var maxPoint = Point.max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            var currentPointX = (void 0);\n            if (currentAngleX < endAngle) {\n                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            var currentPointY = (void 0);\n            if (currentAngleY < endAngle) {\n                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new Point(currentPointX.x, currentPointY.y);\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    };\n\n    Arc.prototype._arcInterval = function _arcInterval () {\n        var ref = this;\n        var startAngle = ref.startAngle;\n        var endAngle = ref.endAngle;\n        var anticlockwise = ref.anticlockwise;\n\n        if (anticlockwise) {\n            var oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    };\n\n    Arc.prototype._intervalCurvePoints = function _intervalCurvePoints (startAngle, endAngle, transformation) {\n        var p1 = this.pointAt(startAngle);\n        var p2 = this.pointAt(endAngle);\n        var p1Derivative = this._derivativeAt(startAngle);\n        var p2Derivative = this._derivativeAt(endAngle);\n        var t = (rad(endAngle) - rad(startAngle)) / 3;\n        var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    };\n\n    Arc.prototype._derivativeAt = function _derivativeAt (angle) {\n        var radian = rad(angle);\n\n        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    };\n\n    Arc.prototype.containsPoint = function containsPoint (point) {\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var ref = this;\n        var center = ref.center;\n        var radiusX = ref.radiusX;\n        var radiusY = ref.radiusY;\n        var distance = center.distanceTo(point);\n        var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        var pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n        var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n        var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n        var containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    };\n\n    Arc.prototype._isOnPath = function _isOnPath (point, width) {\n        var interval = this._arcInterval();\n        var center = this.center;\n        var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    };\n\n    Arc.fromPoints = function fromPoints (start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        var arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    };\n\n    return Arc;\n}(Class));\n\ndefineAccessors(Arc.prototype, [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ]);\nObserversMixin.extend(Arc.prototype);\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    var cos = round((x - cx) / rx, 3);\n    var sin = round((y - cy) / ry, 3);\n\n    return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    var x1 = parameters.x1;\n    var y1 = parameters.y1;\n    var x2 = parameters.x2;\n    var y2 = parameters.y2;\n    var rx = parameters.rx;\n    var ry = parameters.ry;\n    var largeArc = parameters.largeArc;\n    var swipe = parameters.swipe;\n    var rotation = parameters.rotation; if ( rotation === void 0 ) rotation = 0;\n\n    var radians = rad(rotation);\n    var cosine = Math.cos(radians);\n    var sine = Math.sin(radians);\n\n    var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    var sign = largeArc !== swipe ? 1 : -1;\n\n    var xt2 = Math.pow(xT, 2);\n    var yt2 = Math.pow(yT, 2);\n    var rx2 = Math.pow(rx, 2);\n    var ry2 = Math.pow(ry, 2);\n\n    var delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    var cxT = constT * (rx * yT) / ry;\n    var cyT = - constT * (ry * xT) / rx;\n\n    var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    var uX = (xT - cxT) / rx;\n    var uY = (yT - cyT) / ry;\n    var vX = -(xT + cxT) / rx;\n    var vY = -(yT + cyT) / ry;\n\n    var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    var endAngle = startAngle + angle;\n    var signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new Point(cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    var startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\nexport default Arc;\n"]},"metadata":{},"sourceType":"module"}