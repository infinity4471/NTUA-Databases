{"ast":null,"code":"import Node from './node';\nimport { defined, isTransparent } from '../util';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport { NONE } from './constants';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nimport NODE_MAP from './node-map';\nvar ATTRIBUTE_MAP = {\n  \"fill.opacity\": \"fill-opacity\",\n  \"stroke.color\": \"stroke\",\n  \"stroke.width\": \"stroke-width\",\n  \"stroke.opacity\": \"stroke-opacity\"\n};\nvar SPACE = \" \";\n\nvar PathNode = function (Node) {\n  function PathNode() {\n    Node.apply(this, arguments);\n  }\n\n  if (Node) PathNode.__proto__ = Node;\n  PathNode.prototype = Object.create(Node && Node.prototype);\n  PathNode.prototype.constructor = PathNode;\n\n  PathNode.prototype.geometryChange = function geometryChange() {\n    this.attr(\"d\", this.renderData());\n    this.invalidate();\n  };\n\n  PathNode.prototype.optionsChange = function optionsChange(e) {\n    switch (e.field) {\n      case \"fill\":\n        if (e.value) {\n          this.allAttr(this.mapFill(e.value));\n        } else {\n          this.removeAttr(\"fill\");\n        }\n\n        break;\n\n      case \"fill.color\":\n        this.allAttr(this.mapFill({\n          color: e.value\n        }));\n        break;\n\n      case \"stroke\":\n        if (e.value) {\n          this.allAttr(this.mapStroke(e.value));\n        } else {\n          this.removeAttr(\"stroke\");\n        }\n\n        break;\n\n      case \"transform\":\n        this.transformChange(e.value);\n        break;\n\n      default:\n        var name = ATTRIBUTE_MAP[e.field];\n\n        if (name) {\n          this.attr(name, e.value);\n        }\n\n        break;\n    }\n\n    Node.prototype.optionsChange.call(this, e);\n  };\n\n  PathNode.prototype.content = function content() {\n    if (this.element) {\n      this.element.textContent = this.srcElement.content();\n    }\n  };\n\n  PathNode.prototype.renderData = function renderData() {\n    return this.printPath(this.srcElement);\n  };\n\n  PathNode.prototype.printPath = function printPath(path) {\n    var this$1 = this;\n    var segments = path.segments;\n    var length = segments.length;\n\n    if (length > 0) {\n      var parts = [];\n      var output, currentType;\n\n      for (var i = 1; i < length; i++) {\n        var segmentType = this$1.segmentType(segments[i - 1], segments[i]);\n\n        if (segmentType !== currentType) {\n          currentType = segmentType;\n          parts.push(segmentType);\n        }\n\n        if (segmentType === \"L\") {\n          parts.push(this$1.printPoints(segments[i].anchor()));\n        } else {\n          parts.push(this$1.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n        }\n      }\n\n      output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n\n      if (path.options.closed) {\n        output += \"Z\";\n      }\n\n      return output;\n    }\n  };\n\n  PathNode.prototype.printPoints = function printPoints() {\n    var points = arguments;\n    var length = points.length;\n    var result = [];\n\n    for (var i = 0; i < length; i++) {\n      result.push(points[i].toString(3));\n    }\n\n    return result.join(\" \");\n  };\n\n  PathNode.prototype.segmentType = function segmentType(segmentStart, segmentEnd) {\n    return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n  };\n\n  PathNode.prototype.mapStroke = function mapStroke(stroke) {\n    var attrs = [];\n\n    if (stroke && !isTransparent(stroke.color)) {\n      attrs.push([\"stroke\", stroke.color]);\n      attrs.push([\"stroke-width\", stroke.width]);\n      attrs.push([\"stroke-linecap\", this.renderLinecap(stroke)]);\n      attrs.push([\"stroke-linejoin\", stroke.lineJoin]);\n\n      if (defined(stroke.opacity)) {\n        attrs.push([\"stroke-opacity\", stroke.opacity]);\n      }\n\n      if (defined(stroke.dashType)) {\n        attrs.push([\"stroke-dasharray\", this.renderDashType(stroke)]);\n      }\n    } else {\n      attrs.push([\"stroke\", NONE]);\n    }\n\n    return attrs;\n  };\n\n  PathNode.prototype.renderStroke = function renderStroke() {\n    return renderAllAttr(this.mapStroke(this.srcElement.options.stroke));\n  };\n\n  PathNode.prototype.renderDashType = function renderDashType(stroke) {\n    var dashType = stroke.dashType;\n    var width = stroke.width;\n    if (width === void 0) width = 1;\n\n    if (dashType && dashType !== SOLID) {\n      var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n      var result = [];\n\n      for (var i = 0; i < dashArray.length; i++) {\n        result.push(dashArray[i] * width);\n      }\n\n      return result.join(\" \");\n    }\n  };\n\n  PathNode.prototype.renderLinecap = function renderLinecap(stroke) {\n    var dashType = stroke.dashType;\n    var lineCap = stroke.lineCap;\n    return dashType && dashType !== \"solid\" ? BUTT : lineCap;\n  };\n\n  PathNode.prototype.mapFill = function mapFill(fill) {\n    var attrs = [];\n\n    if (!(fill && fill.nodeType === \"Gradient\")) {\n      if (fill && !isTransparent(fill.color)) {\n        attrs.push([\"fill\", fill.color]);\n\n        if (defined(fill.opacity)) {\n          attrs.push([\"fill-opacity\", fill.opacity]);\n        }\n      } else {\n        attrs.push([\"fill\", NONE]);\n      }\n    }\n\n    return attrs;\n  };\n\n  PathNode.prototype.renderFill = function renderFill() {\n    return renderAllAttr(this.mapFill(this.srcElement.options.fill));\n  };\n\n  PathNode.prototype.template = function template() {\n    return \"<path \" + this.renderId() + \" \" + this.renderStyle() + \" \" + this.renderOpacity() + \" \" + renderAttr('d', this.renderData()) + \"\" + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + \"></path>\";\n  };\n\n  return PathNode;\n}(Node);\n\nNODE_MAP.Path = PathNode;\nexport default PathNode;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/svg/path-node.js"],"names":["Node","defined","isTransparent","DASH_ARRAYS","SOLID","BUTT","NONE","renderAllAttr","renderAttr","NODE_MAP","ATTRIBUTE_MAP","SPACE","PathNode","apply","arguments","__proto__","prototype","Object","create","constructor","geometryChange","attr","renderData","invalidate","optionsChange","e","field","value","allAttr","mapFill","removeAttr","color","mapStroke","transformChange","name","call","content","element","textContent","srcElement","printPath","path","this$1","segments","length","parts","output","currentType","i","segmentType","push","printPoints","anchor","controlOut","controlIn","join","options","closed","points","result","toString","segmentStart","segmentEnd","stroke","attrs","width","renderLinecap","lineJoin","opacity","dashType","renderDashType","renderStroke","dashArray","toLowerCase","lineCap","fill","nodeType","renderFill","template","renderId","renderStyle","renderOpacity","renderDefinitions","renderTransform","Path"],"mappings":"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","sourcesContent":["import Node from './node';\nimport { defined, isTransparent } from '../util';\nimport { DASH_ARRAYS, SOLID, BUTT } from '../core/constants';\nimport { NONE } from './constants';\nimport renderAllAttr from './utils/render-all-attributes';\nimport renderAttr from './utils/render-attribute';\nimport NODE_MAP from './node-map';\n\nvar ATTRIBUTE_MAP = {\n    \"fill.opacity\": \"fill-opacity\",\n    \"stroke.color\": \"stroke\",\n    \"stroke.width\": \"stroke-width\",\n    \"stroke.opacity\": \"stroke-opacity\"\n};\nvar SPACE = \" \";\n\nvar PathNode = (function (Node) {\n    function PathNode () {\n        Node.apply(this, arguments);\n    }\n\n    if ( Node ) PathNode.__proto__ = Node;\n    PathNode.prototype = Object.create( Node && Node.prototype );\n    PathNode.prototype.constructor = PathNode;\n\n    PathNode.prototype.geometryChange = function geometryChange () {\n        this.attr(\"d\", this.renderData());\n        this.invalidate();\n    };\n\n    PathNode.prototype.optionsChange = function optionsChange (e) {\n        switch (e.field) {\n            case \"fill\":\n                if (e.value) {\n                    this.allAttr(this.mapFill(e.value));\n                } else {\n                    this.removeAttr(\"fill\");\n                }\n                break;\n\n            case \"fill.color\":\n                this.allAttr(this.mapFill({ color: e.value }));\n                break;\n\n            case \"stroke\":\n                if (e.value) {\n                    this.allAttr(this.mapStroke(e.value));\n                } else {\n                    this.removeAttr(\"stroke\");\n                }\n                break;\n\n            case \"transform\":\n                this.transformChange(e.value);\n                break;\n\n            default:\n                var name = ATTRIBUTE_MAP[e.field];\n                if (name) {\n                    this.attr(name, e.value);\n                }\n                break;\n        }\n\n        Node.prototype.optionsChange.call(this, e);\n    };\n\n    PathNode.prototype.content = function content () {\n        if (this.element) {\n            this.element.textContent = this.srcElement.content();\n        }\n    };\n\n    PathNode.prototype.renderData = function renderData () {\n        return this.printPath(this.srcElement);\n    };\n\n    PathNode.prototype.printPath = function printPath (path) {\n        var this$1 = this;\n\n        var segments = path.segments;\n        var length = segments.length;\n        if (length > 0) {\n            var parts = [];\n            var output, currentType;\n\n            for (var i = 1; i < length; i++) {\n                var segmentType = this$1.segmentType(segments[i - 1], segments[i]);\n                if (segmentType !== currentType) {\n                    currentType = segmentType;\n                    parts.push(segmentType);\n                }\n\n                if (segmentType === \"L\") {\n                    parts.push(this$1.printPoints(segments[i].anchor()));\n                } else {\n                    parts.push(this$1.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n                }\n            }\n\n            output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n            if (path.options.closed) {\n                output += \"Z\";\n            }\n\n            return output;\n        }\n    };\n\n    PathNode.prototype.printPoints = function printPoints () {\n        var points = arguments;\n        var length = points.length;\n        var result = [];\n\n        for (var i = 0; i < length; i++) {\n            result.push(points[i].toString(3));\n        }\n\n        return result.join(\" \");\n    };\n\n    PathNode.prototype.segmentType = function segmentType (segmentStart, segmentEnd) {\n        return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n    };\n\n    PathNode.prototype.mapStroke = function mapStroke (stroke) {\n        var attrs = [];\n\n        if (stroke && !isTransparent(stroke.color)) {\n            attrs.push([ \"stroke\", stroke.color ]);\n            attrs.push([ \"stroke-width\", stroke.width ]);\n            attrs.push([ \"stroke-linecap\", this.renderLinecap(stroke) ]);\n            attrs.push([ \"stroke-linejoin\", stroke.lineJoin ]);\n\n            if (defined(stroke.opacity)) {\n                attrs.push([ \"stroke-opacity\", stroke.opacity ]);\n            }\n\n            if (defined(stroke.dashType)) {\n                attrs.push([ \"stroke-dasharray\", this.renderDashType(stroke) ]);\n            }\n        } else {\n            attrs.push([ \"stroke\", NONE ]);\n        }\n\n        return attrs;\n    };\n\n    PathNode.prototype.renderStroke = function renderStroke () {\n        return renderAllAttr(\n            this.mapStroke(this.srcElement.options.stroke)\n        );\n    };\n\n    PathNode.prototype.renderDashType = function renderDashType (stroke) {\n        var dashType = stroke.dashType;\n        var width = stroke.width; if ( width === void 0 ) width = 1;\n\n        if (dashType && dashType !== SOLID) {\n            var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\n            var result = [];\n\n            for (var i = 0; i < dashArray.length; i++) {\n                result.push(dashArray[i] * width);\n            }\n\n            return result.join(\" \");\n        }\n    };\n\n    PathNode.prototype.renderLinecap = function renderLinecap (stroke) {\n        var dashType = stroke.dashType;\n        var lineCap = stroke.lineCap;\n\n        return (dashType && dashType !== \"solid\") ? BUTT : lineCap;\n    };\n\n    PathNode.prototype.mapFill = function mapFill (fill) {\n        var attrs = [];\n        if (!(fill && fill.nodeType === \"Gradient\")) {\n            if (fill && !isTransparent(fill.color)) {\n                attrs.push([ \"fill\", fill.color ]);\n\n                if (defined(fill.opacity)) {\n                    attrs.push([ \"fill-opacity\", fill.opacity ]);\n                }\n            } else {\n                attrs.push([ \"fill\", NONE ]);\n            }\n        }\n\n        return attrs;\n    };\n\n    PathNode.prototype.renderFill = function renderFill () {\n        return renderAllAttr(\n            this.mapFill(this.srcElement.options.fill)\n        );\n    };\n\n    PathNode.prototype.template = function template () {\n        return \"<path \" + (this.renderId()) + \" \" + (this.renderStyle()) + \" \" + (this.renderOpacity()) + \" \" + (renderAttr('d', this.renderData())) +\n                    \"\" + (this.renderStroke()) + (this.renderFill()) + (this.renderDefinitions()) + (this.renderTransform()) + \"></path>\";\n    };\n\n    return PathNode;\n}(Node));\n\nNODE_MAP.Path = PathNode;\n\nexport default PathNode;"]},"metadata":{},"sourceType":"module"}