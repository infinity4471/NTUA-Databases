{"ast":null,"code":"import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts-no-run\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\n\nexport var orderBy = function (data, descriptors) {\n  if (descriptors.some(function (x) {\n    return isPresent(x.dir);\n  })) {\n    data = data.slice(0);\n    var comparer = composeSortDescriptors(descriptors);\n    sort(data, 0, data.length, comparer);\n  }\n\n  return data;\n};\n\nvar defaultComparer = function (a, b) {\n  return a === b;\n};\n\nvar normalizeComparer = function (comparer) {\n  if (isString(comparer)) {\n    var accessor_1 = getter(comparer);\n\n    comparer = function (a, b) {\n      return accessor_1(a) === accessor_1(b);\n    };\n  }\n\n  return comparer;\n};\n\nvar _distinct = function (data, comparer) {\n  return data.filter(function (x, idx, xs) {\n    return xs.findIndex(comparer.bind(null, x)) === idx;\n  });\n};\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts-no-run\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\n\n\nexport var distinct = function (data, comparer) {\n  if (comparer === void 0) {\n    comparer = defaultComparer;\n  }\n\n  return _distinct(data, normalizeComparer(comparer));\n};\n/**\n * @hidden\n */\n\nexport var count = function (data, predicate) {\n  var counter = 0;\n\n  for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n    if (predicate(data[idx])) {\n      counter++;\n    }\n  }\n\n  return counter;\n};\n/**\n * @hidden\n */\n\nexport var limit = function (data, predicate) {\n  if (predicate) {\n    return data.filter(predicate);\n  }\n\n  return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts-no-run\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\n\nexport var process = function (data, state) {\n  var skipCount = state.skip,\n      takeCount = state.take,\n      filterDescriptor = state.filter,\n      sort = state.sort,\n      group = state.group;\n  var sortDescriptors = normalizeGroups(group || []).concat(sort || []);\n\n  if (sortDescriptors.length) {\n    data = orderBy(data, sortDescriptors);\n  }\n\n  var hasFilters = isPresent(filterDescriptor) && filter.length;\n  var hasGroups = isPresent(group) && group.length;\n\n  if (!hasFilters && !hasGroups) {\n    return {\n      data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n      total: data.length\n    };\n  }\n\n  var total;\n  var transformers = [];\n  var predicate;\n\n  if (hasFilters) {\n    predicate = compileFilter(normalizeFilters(filterDescriptor));\n    total = count(data, predicate);\n    transformers.push(filter(predicate));\n  } else {\n    total = data.length;\n  }\n\n  if (isPresent(skipCount) && isPresent(takeCount)) {\n    transformers.push(skip(skipCount));\n    transformers.push(take(takeCount));\n  }\n\n  if (transformers.length) {\n    var transform = compose.apply(void 0, transformers);\n    var result = hasGroups ? groupBy(data, group, transform, limit(data, predicate)) : exec(transform(concat), [], data);\n    return {\n      data: result,\n      total: total\n    };\n  }\n\n  return {\n    data: hasGroups ? groupBy(data, group) : data,\n    total: total\n  };\n};","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-data-query/dist/es/array.operators.js"],"names":["isPresent","isString","composeSortDescriptors","groupBy","normalizeGroups","normalizeFilters","compileFilter","exec","skip","take","filter","concat","getter","compose","sort","orderBy","data","descriptors","some","x","dir","slice","comparer","length","defaultComparer","a","b","normalizeComparer","accessor_1","_distinct","idx","xs","findIndex","bind","distinct","count","predicate","counter","length_1","limit","process","state","skipCount","takeCount","filterDescriptor","group","sortDescriptors","hasFilters","hasGroups","total","transformers","push","transform","apply","result"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,SAApC;AACA,SAASC,sBAAT,QAAuC,+BAAvC;AACA,SAASC,OAAT,EAAkBC,eAAlB,QAAyC,4BAAzC;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,aAAT,QAA8B,uCAA9B;AACA,SAASC,IAAT,EAAeC,IAAf,EAAqBC,IAArB,EAA2BC,MAA3B,EAAmCC,MAAnC,QAAiD,eAAjD;AACA,SAASC,MAAT,QAAuB,YAAvB;AACA,SAASC,OAAT,QAAwB,SAAxB;AACA,SAASC,IAAT,QAAqB,gBAArB;AACA;;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,IAAIC,OAAO,GAAG,UAAUC,IAAV,EAAgBC,WAAhB,EAA6B;AAC9C,MAAIA,WAAW,CAACC,IAAZ,CAAiB,UAAUC,CAAV,EAAa;AAAE,WAAOnB,SAAS,CAACmB,CAAC,CAACC,GAAH,CAAhB;AAA0B,GAA1D,CAAJ,EAAiE;AAC7DJ,IAAAA,IAAI,GAAGA,IAAI,CAACK,KAAL,CAAW,CAAX,CAAP;AACA,QAAIC,QAAQ,GAAGpB,sBAAsB,CAACe,WAAD,CAArC;AACAH,IAAAA,IAAI,CAACE,IAAD,EAAO,CAAP,EAAUA,IAAI,CAACO,MAAf,EAAuBD,QAAvB,CAAJ;AACH;;AACD,SAAON,IAAP;AACH,CAPM;;AAQP,IAAIQ,eAAe,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAAE,SAAOD,CAAC,KAAKC,CAAb;AAAiB,CAAzD;;AACA,IAAIC,iBAAiB,GAAG,UAAUL,QAAV,EAAoB;AACxC,MAAIrB,QAAQ,CAACqB,QAAD,CAAZ,EAAwB;AACpB,QAAIM,UAAU,GAAGhB,MAAM,CAACU,QAAD,CAAvB;;AACAA,IAAAA,QAAQ,GAAG,UAAUG,CAAV,EAAaC,CAAb,EAAgB;AAAE,aAAOE,UAAU,CAACH,CAAD,CAAV,KAAkBG,UAAU,CAACF,CAAD,CAAnC;AAAyC,KAAtE;AACH;;AACD,SAAOJ,QAAP;AACH,CAND;;AAOA,IAAIO,SAAS,GAAG,UAAUb,IAAV,EAAgBM,QAAhB,EAA0B;AACtC,SAAON,IAAI,CAACN,MAAL,CAAY,UAAUS,CAAV,EAAaW,GAAb,EAAkBC,EAAlB,EAAsB;AAAE,WAAOA,EAAE,CAACC,SAAH,CAAaV,QAAQ,CAACW,IAAT,CAAc,IAAd,EAAoBd,CAApB,CAAb,MAAyCW,GAAhD;AAAsD,GAA1F,CAAP;AACH,CAFD;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAO,IAAII,QAAQ,GAAG,UAAUlB,IAAV,EAAgBM,QAAhB,EAA0B;AAC5C,MAAIA,QAAQ,KAAK,KAAK,CAAtB,EAAyB;AAAEA,IAAAA,QAAQ,GAAGE,eAAX;AAA6B;;AACxD,SAAOK,SAAS,CAACb,IAAD,EAAOW,iBAAiB,CAACL,QAAD,CAAxB,CAAhB;AACH,CAHM;AAIP;;;;AAGA,OAAO,IAAIa,KAAK,GAAG,UAAUnB,IAAV,EAAgBoB,SAAhB,EAA2B;AAC1C,MAAIC,OAAO,GAAG,CAAd;;AACA,OAAK,IAAIP,GAAG,GAAG,CAAV,EAAaQ,QAAQ,GAAGtB,IAAI,CAACO,MAAlC,EAA0CO,GAAG,GAAGQ,QAAhD,EAA0DR,GAAG,EAA7D,EAAiE;AAC7D,QAAIM,SAAS,CAACpB,IAAI,CAACc,GAAD,CAAL,CAAb,EAA0B;AACtBO,MAAAA,OAAO;AACV;AACJ;;AACD,SAAOA,OAAP;AACH,CARM;AASP;;;;AAGA,OAAO,IAAIE,KAAK,GAAG,UAAUvB,IAAV,EAAgBoB,SAAhB,EAA2B;AAC1C,MAAIA,SAAJ,EAAe;AACX,WAAOpB,IAAI,CAACN,MAAL,CAAY0B,SAAZ,CAAP;AACH;;AACD,SAAOpB,IAAP;AACH,CALM;AAMP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAO,IAAIwB,OAAO,GAAG,UAAUxB,IAAV,EAAgByB,KAAhB,EAAuB;AACxC,MAAIC,SAAS,GAAGD,KAAK,CAACjC,IAAtB;AAAA,MAA4BmC,SAAS,GAAGF,KAAK,CAAChC,IAA9C;AAAA,MAAoDmC,gBAAgB,GAAGH,KAAK,CAAC/B,MAA7E;AAAA,MAAqFI,IAAI,GAAG2B,KAAK,CAAC3B,IAAlG;AAAA,MAAwG+B,KAAK,GAAGJ,KAAK,CAACI,KAAtH;AACA,MAAIC,eAAe,GAAG1C,eAAe,CAACyC,KAAK,IAAI,EAAV,CAAf,CAA6BlC,MAA7B,CAAoCG,IAAI,IAAI,EAA5C,CAAtB;;AACA,MAAIgC,eAAe,CAACvB,MAApB,EAA4B;AACxBP,IAAAA,IAAI,GAAGD,OAAO,CAACC,IAAD,EAAO8B,eAAP,CAAd;AACH;;AACD,MAAIC,UAAU,GAAG/C,SAAS,CAAC4C,gBAAD,CAAT,IAA+BlC,MAAM,CAACa,MAAvD;AACA,MAAIyB,SAAS,GAAGhD,SAAS,CAAC6C,KAAD,CAAT,IAAoBA,KAAK,CAACtB,MAA1C;;AACA,MAAI,CAACwB,UAAD,IAAe,CAACC,SAApB,EAA+B;AAC3B,WAAO;AACHhC,MAAAA,IAAI,EAAE2B,SAAS,GAAG3B,IAAI,CAACK,KAAL,CAAWqB,SAAX,EAAsBA,SAAS,GAAGC,SAAlC,CAAH,GAAkD3B,IAD9D;AAEHiC,MAAAA,KAAK,EAAEjC,IAAI,CAACO;AAFT,KAAP;AAIH;;AACD,MAAI0B,KAAJ;AACA,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAId,SAAJ;;AACA,MAAIW,UAAJ,EAAgB;AACZX,IAAAA,SAAS,GAAG9B,aAAa,CAACD,gBAAgB,CAACuC,gBAAD,CAAjB,CAAzB;AACAK,IAAAA,KAAK,GAAGd,KAAK,CAACnB,IAAD,EAAOoB,SAAP,CAAb;AACAc,IAAAA,YAAY,CAACC,IAAb,CAAkBzC,MAAM,CAAC0B,SAAD,CAAxB;AACH,GAJD,MAKK;AACDa,IAAAA,KAAK,GAAGjC,IAAI,CAACO,MAAb;AACH;;AACD,MAAIvB,SAAS,CAAC0C,SAAD,CAAT,IAAwB1C,SAAS,CAAC2C,SAAD,CAArC,EAAkD;AAC9CO,IAAAA,YAAY,CAACC,IAAb,CAAkB3C,IAAI,CAACkC,SAAD,CAAtB;AACAQ,IAAAA,YAAY,CAACC,IAAb,CAAkB1C,IAAI,CAACkC,SAAD,CAAtB;AACH;;AACD,MAAIO,YAAY,CAAC3B,MAAjB,EAAyB;AACrB,QAAI6B,SAAS,GAAGvC,OAAO,CAACwC,KAAR,CAAc,KAAK,CAAnB,EAAsBH,YAAtB,CAAhB;AACA,QAAII,MAAM,GAAGN,SAAS,GAClB7C,OAAO,CAACa,IAAD,EAAO6B,KAAP,EAAcO,SAAd,EAAyBb,KAAK,CAACvB,IAAD,EAAOoB,SAAP,CAA9B,CADW,GAElB7B,IAAI,CAAC6C,SAAS,CAACzC,MAAD,CAAV,EAAoB,EAApB,EAAwBK,IAAxB,CAFR;AAGA,WAAO;AAAEA,MAAAA,IAAI,EAAEsC,MAAR;AAAgBL,MAAAA,KAAK,EAAEA;AAAvB,KAAP;AACH;;AACD,SAAO;AACHjC,IAAAA,IAAI,EAAEgC,SAAS,GAAG7C,OAAO,CAACa,IAAD,EAAO6B,KAAP,CAAV,GAA0B7B,IADtC;AAEHiC,IAAAA,KAAK,EAAEA;AAFJ,GAAP;AAIH,CAxCM","sourcesContent":["import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts-no-run\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport var orderBy = function (data, descriptors) {\n    if (descriptors.some(function (x) { return isPresent(x.dir); })) {\n        data = data.slice(0);\n        var comparer = composeSortDescriptors(descriptors);\n        sort(data, 0, data.length, comparer);\n    }\n    return data;\n};\nvar defaultComparer = function (a, b) { return a === b; };\nvar normalizeComparer = function (comparer) {\n    if (isString(comparer)) {\n        var accessor_1 = getter(comparer);\n        comparer = function (a, b) { return accessor_1(a) === accessor_1(b); };\n    }\n    return comparer;\n};\nvar _distinct = function (data, comparer) {\n    return data.filter(function (x, idx, xs) { return xs.findIndex(comparer.bind(null, x)) === idx; });\n};\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts-no-run\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport var distinct = function (data, comparer) {\n    if (comparer === void 0) { comparer = defaultComparer; }\n    return _distinct(data, normalizeComparer(comparer));\n};\n/**\n * @hidden\n */\nexport var count = function (data, predicate) {\n    var counter = 0;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport var limit = function (data, predicate) {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts-no-run\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport var process = function (data, state) {\n    var skipCount = state.skip, takeCount = state.take, filterDescriptor = state.filter, sort = state.sort, group = state.group;\n    var sortDescriptors = normalizeGroups(group || []).concat(sort || []);\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    var hasFilters = isPresent(filterDescriptor) && filter.length;\n    var hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    var total;\n    var transformers = [];\n    var predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        var transform = compose.apply(void 0, transformers);\n        var result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n"]},"metadata":{},"sourceType":"module"}