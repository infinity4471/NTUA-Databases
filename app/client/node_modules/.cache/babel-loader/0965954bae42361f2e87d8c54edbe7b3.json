{"ast":null,"code":"import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport Paintable from '../mixins/paintable';\nimport Measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport PathParser from '../parsing/path-parser';\n\nvar Path = function (Element) {\n  function Path(options) {\n    Element.call(this, options);\n    this.segments = new GeometryElementsArray();\n    this.segments.addObserver(this);\n\n    if (!defined(this.options.stroke)) {\n      this.stroke(\"#000\");\n\n      if (!defined(this.options.stroke.lineJoin)) {\n        this.options.set(\"stroke.lineJoin\", \"miter\");\n      }\n    }\n  }\n\n  if (Element) Path.__proto__ = Element;\n  Path.prototype = Object.create(Element && Element.prototype);\n  Path.prototype.constructor = Path;\n\n  Path.prototype.moveTo = function moveTo(x, y) {\n    this.suspend();\n    this.segments.elements([]);\n    this.resume();\n    this.lineTo(x, y);\n    return this;\n  };\n\n  Path.prototype.lineTo = function lineTo(x, y) {\n    var point = defined(y) ? new Point(x, y) : x;\n    var segment = new Segment(point);\n    this.segments.push(segment);\n    return this;\n  };\n\n  Path.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var segment = new Segment(point, controlIn);\n      this.suspend();\n      lastSegment.controlOut(controlOut);\n      this.resume();\n      this.segments.push(segment);\n    }\n\n    return this;\n  };\n\n  Path.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var start = rad(startAngle);\n      var center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n      var arc = new Arc(center, {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: radiusX,\n        radiusY: radiusY,\n        anticlockwise: anticlockwise\n      });\n\n      this._addArcSegments(arc);\n    }\n\n    return this;\n  };\n\n  Path.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var arc = Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n      this._addArcSegments(arc);\n    }\n\n    return this;\n  };\n\n  Path.prototype._addArcSegments = function _addArcSegments(arc) {\n    var this$1 = this;\n    this.suspend();\n    var curvePoints = arc.curvePoints();\n\n    for (var i = 1; i < curvePoints.length; i += 3) {\n      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n    }\n\n    this.resume();\n    this.geometryChange();\n  };\n\n  Path.prototype.close = function close() {\n    this.options.closed = true;\n    this.geometryChange();\n    return this;\n  };\n\n  Path.prototype.rawBBox = function rawBBox() {\n    return this._bbox();\n  };\n\n  Path.prototype._containsPoint = function _containsPoint(point) {\n    var segments = this.segments;\n    var length = segments.length;\n    var intersectionsCount = 0;\n    var previous, current;\n\n    for (var idx = 1; idx < length; idx++) {\n      previous = segments[idx - 1];\n      current = segments[idx];\n      intersectionsCount += previous._intersectionsTo(current, point);\n    }\n\n    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n    }\n\n    return intersectionsCount % 2 !== 0;\n  };\n\n  Path.prototype._isOnPath = function _isOnPath(point, width) {\n    var segments = this.segments;\n    var length = segments.length;\n    var pathWidth = width || this.options.stroke.width;\n\n    if (length > 1) {\n      if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n        return true;\n      }\n\n      for (var idx = 2; idx <= length - 2; idx++) {\n        if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n          return true;\n        }\n      }\n\n      if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Path.prototype._bbox = function _bbox(matrix) {\n    var segments = this.segments;\n    var length = segments.length;\n    var boundingBox;\n\n    if (length === 1) {\n      var anchor = segments[0].anchor().transformCopy(matrix);\n      boundingBox = new Rect(anchor, Size.ZERO);\n    } else if (length > 0) {\n      for (var i = 1; i < length; i++) {\n        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n\n        if (boundingBox) {\n          boundingBox = Rect.union(boundingBox, segmentBox);\n        } else {\n          boundingBox = segmentBox;\n        }\n      }\n    }\n\n    return boundingBox;\n  };\n\n  Path.fromRect = function fromRect(rect, options) {\n    return new Path(options).moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n  };\n\n  Path.fromPoints = function fromPoints(points, options) {\n    if (points) {\n      var path = new Path(options);\n\n      for (var i = 0; i < points.length; i++) {\n        var point = Point.create(points[i]);\n\n        if (point) {\n          if (i === 0) {\n            path.moveTo(point);\n          } else {\n            path.lineTo(point);\n          }\n        }\n      }\n\n      return path;\n    }\n  };\n\n  Path.fromArc = function fromArc(arc, options) {\n    var path = new Path(options);\n    var startAngle = arc.startAngle;\n    var start = arc.pointAt(startAngle);\n    path.moveTo(start.x, start.y);\n    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n    return path;\n  };\n\n  return Path;\n}(Element);\n\nPath.prototype.nodeType = \"Path\";\nPaintable.extend(Path.prototype);\nMeasurable.extend(Path.prototype);\n\nPath.parse = function (str, options) {\n  return PathParser.current.parse(str, options);\n};\n\nexport default Path;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/shapes/path.js"],"names":["GeometryElementsArray","Element","Paintable","Measurable","Arc","Rect","Segment","Point","Size","lineIntersectionsCount","defined","last","rad","PathParser","Path","options","call","segments","addObserver","stroke","lineJoin","set","__proto__","prototype","Object","create","constructor","moveTo","x","y","suspend","elements","resume","lineTo","point","segment","push","curveTo","controlOut","controlIn","length","lastSegment","arc","startAngle","endAngle","radiusX","radiusY","anticlockwise","anchor","start","center","Math","cos","sin","_addArcSegments","arcTo","end","rx","ry","largeArc","swipe","rotation","fromPoints","this$1","curvePoints","i","geometryChange","close","closed","rawBBox","_bbox","_containsPoint","intersectionsCount","previous","current","idx","_intersectionsTo","equals","_isOnPath","width","pathWidth","_isOnPathTo","matrix","boundingBox","transformCopy","ZERO","segmentBox","bboxTo","union","fromRect","rect","topLeft","topRight","bottomRight","bottomLeft","points","path","fromArc","pointAt","nodeType","extend","parse","str"],"mappings":"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","sourcesContent":["import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport Paintable from '../mixins/paintable';\nimport Measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport PathParser from '../parsing/path-parser';\n\nvar Path = (function (Element) {\n    function Path(options) {\n        Element.call(this, options);\n        this.segments = new GeometryElementsArray();\n        this.segments.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke(\"#000\");\n\n            if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set(\"stroke.lineJoin\", \"miter\");\n            }\n        }\n    }\n\n    if ( Element ) Path.__proto__ = Element;\n    Path.prototype = Object.create( Element && Element.prototype );\n    Path.prototype.constructor = Path;\n\n    Path.prototype.moveTo = function moveTo (x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    };\n\n    Path.prototype.lineTo = function lineTo (x, y) {\n        var point = defined(y) ? new Point(x, y) : x;\n        var segment = new Segment(point);\n\n        this.segments.push(segment);\n\n        return this;\n    };\n\n    Path.prototype.curveTo = function curveTo (controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var segment = new Segment(point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arc = function arc (startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var start = rad(startAngle);\n            var center = new Point(anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            var arc = new Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    };\n\n    Path.prototype.arcTo = function arcTo (end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            var lastSegment = last(this.segments);\n            var anchor = lastSegment.anchor();\n            var arc = Arc.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    };\n\n    Path.prototype._addArcSegments = function _addArcSegments (arc) {\n        var this$1 = this;\n\n        this.suspend();\n\n        var curvePoints = arc.curvePoints();\n\n        for (var i = 1; i < curvePoints.length; i += 3) {\n            this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    };\n\n    Path.prototype.close = function close () {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    };\n\n    Path.prototype.rawBBox = function rawBBox () {\n        return this._bbox();\n    };\n\n    Path.prototype._containsPoint = function _containsPoint (point) {\n        var segments = this.segments;\n        var length = segments.length;\n        var intersectionsCount = 0;\n        var previous, current;\n\n        for (var idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    };\n\n    Path.prototype._isOnPath = function _isOnPath (point, width) {\n        var segments = this.segments;\n        var length = segments.length;\n        var pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n                return true;\n            }\n\n            for (var idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    Path.prototype._bbox = function _bbox (matrix) {\n        var segments = this.segments;\n        var length = segments.length;\n        var boundingBox;\n\n        if (length === 1) {\n            var anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new Rect(anchor, Size.ZERO);\n        } else if (length > 0) {\n            for (var i = 1; i < length; i++) {\n                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    };\n\n    Path.fromRect = function fromRect (rect, options) {\n        return new Path(options)\n            .moveTo(rect.topLeft())\n            .lineTo(rect.topRight())\n            .lineTo(rect.bottomRight())\n            .lineTo(rect.bottomLeft())\n            .close();\n    };\n\n    Path.fromPoints = function fromPoints (points, options) {\n        if (points) {\n            var path = new Path(options);\n\n            for (var i = 0; i < points.length; i++) {\n                var point = Point.create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    };\n\n    Path.fromArc = function fromArc (arc, options) {\n        var path = new Path(options);\n        var startAngle = arc.startAngle;\n        var start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    };\n\n    return Path;\n}(Element));\n\nPath.prototype.nodeType = \"Path\";\n\nPaintable.extend(Path.prototype);\nMeasurable.extend(Path.prototype);\n\nPath.parse = function(str, options) {\n    return PathParser.current.parse(str, options);\n};\n\nexport default Path;\n"]},"metadata":{},"sourceType":"module"}