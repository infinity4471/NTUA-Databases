{"ast":null,"code":"/* pako 1.0.11 nodeca/pako */\n(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.pako = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';\n\n      function _has(obj, key) {\n        return Object.prototype.hasOwnProperty.call(obj, key);\n      }\n\n      exports.assign = function (obj\n      /*from1, from2, from3, ...*/\n      ) {\n        var sources = Array.prototype.slice.call(arguments, 1);\n\n        while (sources.length) {\n          var source = sources.shift();\n\n          if (!source) {\n            continue;\n          }\n\n          if (typeof source !== 'object') {\n            throw new TypeError(source + 'must be non-object');\n          }\n\n          for (var p in source) {\n            if (_has(source, p)) {\n              obj[p] = source[p];\n            }\n          }\n        }\n\n        return obj;\n      }; // reduce buffer size, avoiding mem copy\n\n\n      exports.shrinkBuf = function (buf, size) {\n        if (buf.length === size) {\n          return buf;\n        }\n\n        if (buf.subarray) {\n          return buf.subarray(0, size);\n        }\n\n        buf.length = size;\n        return buf;\n      };\n\n      var fnTyped = {\n        arraySet: function (dest, src, src_offs, len, dest_offs) {\n          if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n          } // Fallback to ordinary array\n\n\n          for (var i = 0; i < len; i++) {\n            dest[dest_offs + i] = src[src_offs + i];\n          }\n        },\n        // Join array of chunks to single array.\n        flattenChunks: function (chunks) {\n          var i, l, len, pos, chunk, result; // calculate data length\n\n          len = 0;\n\n          for (i = 0, l = chunks.length; i < l; i++) {\n            len += chunks[i].length;\n          } // join chunks\n\n\n          result = new Uint8Array(len);\n          pos = 0;\n\n          for (i = 0, l = chunks.length; i < l; i++) {\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n          }\n\n          return result;\n        }\n      };\n      var fnUntyped = {\n        arraySet: function (dest, src, src_offs, len, dest_offs) {\n          for (var i = 0; i < len; i++) {\n            dest[dest_offs + i] = src[src_offs + i];\n          }\n        },\n        // Join array of chunks to single array.\n        flattenChunks: function (chunks) {\n          return [].concat.apply([], chunks);\n        }\n      }; // Enable/Disable typed arrays use, for testing\n      //\n\n      exports.setTyped = function (on) {\n        if (on) {\n          exports.Buf8 = Uint8Array;\n          exports.Buf16 = Uint16Array;\n          exports.Buf32 = Int32Array;\n          exports.assign(exports, fnTyped);\n        } else {\n          exports.Buf8 = Array;\n          exports.Buf16 = Array;\n          exports.Buf32 = Array;\n          exports.assign(exports, fnUntyped);\n        }\n      };\n\n      exports.setTyped(TYPED_OK);\n    }, {}],\n    2: [function (require, module, exports) {\n      // String encode/decode helpers\n      'use strict';\n\n      var utils = require('./common'); // Quick check if we can use fast array to bin string conversion\n      //\n      // - apply(Array) can fail on Android 2.2\n      // - apply(Uint8Array) can fail on iOS 5.1 Safari\n      //\n\n\n      var STR_APPLY_OK = true;\n      var STR_APPLY_UIA_OK = true;\n\n      try {\n        String.fromCharCode.apply(null, [0]);\n      } catch (__) {\n        STR_APPLY_OK = false;\n      }\n\n      try {\n        String.fromCharCode.apply(null, new Uint8Array(1));\n      } catch (__) {\n        STR_APPLY_UIA_OK = false;\n      } // Table with utf8 lengths (calculated by first byte of sequence)\n      // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n      // because max possible codepoint is 0x10ffff\n\n\n      var _utf8len = new utils.Buf8(256);\n\n      for (var q = 0; q < 256; q++) {\n        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n      }\n\n      _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n      // convert string to array (typed, when possible)\n\n      exports.string2buf = function (str) {\n        var buf,\n            c,\n            c2,\n            m_pos,\n            i,\n            str_len = str.length,\n            buf_len = 0; // count binary size\n\n        for (m_pos = 0; m_pos < str_len; m_pos++) {\n          c = str.charCodeAt(m_pos);\n\n          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n\n            if ((c2 & 0xfc00) === 0xdc00) {\n              c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n              m_pos++;\n            }\n          }\n\n          buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n        } // allocate buffer\n\n\n        buf = new utils.Buf8(buf_len); // convert\n\n        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n          c = str.charCodeAt(m_pos);\n\n          if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n\n            if ((c2 & 0xfc00) === 0xdc00) {\n              c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n              m_pos++;\n            }\n          }\n\n          if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n          } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n          } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n          } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n          }\n        }\n\n        return buf;\n      }; // Helper (used in 2 places)\n\n\n      function buf2binstring(buf, len) {\n        // On Chrome, the arguments in a function call that are allowed is `65534`.\n        // If the length of the buffer is smaller than that, we can use this optimization,\n        // otherwise we will take a slower path.\n        if (len < 65534) {\n          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n          }\n        }\n\n        var result = '';\n\n        for (var i = 0; i < len; i++) {\n          result += String.fromCharCode(buf[i]);\n        }\n\n        return result;\n      } // Convert byte array to binary string\n\n\n      exports.buf2binstring = function (buf) {\n        return buf2binstring(buf, buf.length);\n      }; // Convert binary string (typed, when possible)\n\n\n      exports.binstring2buf = function (str) {\n        var buf = new utils.Buf8(str.length);\n\n        for (var i = 0, len = buf.length; i < len; i++) {\n          buf[i] = str.charCodeAt(i);\n        }\n\n        return buf;\n      }; // convert array to string\n\n\n      exports.buf2string = function (buf, max) {\n        var i, out, c, c_len;\n        var len = max || buf.length; // Reserve max possible length (2 words per char)\n        // NB: by unknown reasons, Array is significantly faster for\n        //     String.fromCharCode.apply than Uint16Array.\n\n        var utf16buf = new Array(len * 2);\n\n        for (out = 0, i = 0; i < len;) {\n          c = buf[i++]; // quick process ascii\n\n          if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n          }\n\n          c_len = _utf8len[c]; // skip 5 & 6 byte codes\n\n          if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n          } // apply mask on first byte\n\n\n          c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n          while (c_len > 1 && i < len) {\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n          } // terminated by end of string?\n\n\n          if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n          }\n\n          if (c < 0x10000) {\n            utf16buf[out++] = c;\n          } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n          }\n        }\n\n        return buf2binstring(utf16buf, out);\n      }; // Calculate max possible position in utf8 buffer,\n      // that will not break sequence. If that's not possible\n      // - (very small limits) return max size as is.\n      //\n      // buf[] - utf8 bytes array\n      // max   - length limit (mandatory);\n\n\n      exports.utf8border = function (buf, max) {\n        var pos;\n        max = max || buf.length;\n\n        if (max > buf.length) {\n          max = buf.length;\n        } // go back from last position, until start of sequence found\n\n\n        pos = max - 1;\n\n        while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n          pos--;\n        } // Very small and broken sequence,\n        // return max, because we should return something anyway.\n\n\n        if (pos < 0) {\n          return max;\n        } // If we came to start of buffer - that means buffer is too small,\n        // return max too.\n\n\n        if (pos === 0) {\n          return max;\n        }\n\n        return pos + _utf8len[buf[pos]] > max ? pos : max;\n      };\n    }, {\n      \"./common\": 1\n    }],\n    3: [function (require, module, exports) {\n      'use strict'; // Note: adler32 takes 12% for level 0 and 2% for level 6.\n      // It isn't worth it to make additional optimizations as in original.\n      // Small size is preferable.\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      function adler32(adler, buf, len, pos) {\n        var s1 = adler & 0xffff | 0,\n            s2 = adler >>> 16 & 0xffff | 0,\n            n = 0;\n\n        while (len !== 0) {\n          // Set limit ~ twice less than 5552, to keep\n          // s2 in 31-bits, because we force signed ints.\n          // in other case %= will fail.\n          n = len > 2000 ? 2000 : len;\n          len -= n;\n\n          do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n          } while (--n);\n\n          s1 %= 65521;\n          s2 %= 65521;\n        }\n\n        return s1 | s2 << 16 | 0;\n      }\n\n      module.exports = adler32;\n    }, {}],\n    4: [function (require, module, exports) {\n      'use strict'; // Note: we can't get significant speed boost here.\n      // So write code to minimize size - no pregenerated tables\n      // and array tools dependencies.\n      // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n      // Use ordinary array, since untyped makes no boost here\n\n      function makeTable() {\n        var c,\n            table = [];\n\n        for (var n = 0; n < 256; n++) {\n          c = n;\n\n          for (var k = 0; k < 8; k++) {\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n          }\n\n          table[n] = c;\n        }\n\n        return table;\n      } // Create table on load. Just 255 signed longs. Not a problem.\n\n\n      var crcTable = makeTable();\n\n      function crc32(crc, buf, len, pos) {\n        var t = crcTable,\n            end = pos + len;\n        crc ^= -1;\n\n        for (var i = pos; i < end; i++) {\n          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n        }\n\n        return crc ^ -1; // >>> 0;\n      }\n\n      module.exports = crc32;\n    }, {}],\n    5: [function (require, module, exports) {\n      'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      var utils = require('../utils/common');\n\n      var trees = require('./trees');\n\n      var adler32 = require('./adler32');\n\n      var crc32 = require('./crc32');\n\n      var msg = require('./messages');\n      /* Public constants ==========================================================*/\n\n      /* ===========================================================================*/\n\n      /* Allowed flush values; see deflate() and inflate() below for details */\n\n\n      var Z_NO_FLUSH = 0;\n      var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;\n\n      var Z_FULL_FLUSH = 3;\n      var Z_FINISH = 4;\n      var Z_BLOCK = 5; //var Z_TREES         = 6;\n\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n\n      var Z_OK = 0;\n      var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;\n      //var Z_ERRNO         = -1;\n\n      var Z_STREAM_ERROR = -2;\n      var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;\n\n      var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;\n\n      /* compression levels */\n      //var Z_NO_COMPRESSION      = 0;\n      //var Z_BEST_SPEED          = 1;\n      //var Z_BEST_COMPRESSION    = 9;\n\n      var Z_DEFAULT_COMPRESSION = -1;\n      var Z_FILTERED = 1;\n      var Z_HUFFMAN_ONLY = 2;\n      var Z_RLE = 3;\n      var Z_FIXED = 4;\n      var Z_DEFAULT_STRATEGY = 0;\n      /* Possible values of the data_type field (though see inflate()) */\n      //var Z_BINARY              = 0;\n      //var Z_TEXT                = 1;\n      //var Z_ASCII               = 1; // = Z_TEXT\n\n      var Z_UNKNOWN = 2;\n      /* The deflate compression method */\n\n      var Z_DEFLATED = 8;\n      /*============================================================================*/\n\n      var MAX_MEM_LEVEL = 9;\n      /* Maximum value for memLevel in deflateInit2 */\n\n      var MAX_WBITS = 15;\n      /* 32K LZ77 window */\n\n      var DEF_MEM_LEVEL = 8;\n      var LENGTH_CODES = 29;\n      /* number of length codes, not counting the special END_BLOCK code */\n\n      var LITERALS = 256;\n      /* number of literal bytes 0..255 */\n\n      var L_CODES = LITERALS + 1 + LENGTH_CODES;\n      /* number of Literal or Length codes, including the END_BLOCK code */\n\n      var D_CODES = 30;\n      /* number of distance codes */\n\n      var BL_CODES = 19;\n      /* number of codes used to transfer the bit lengths */\n\n      var HEAP_SIZE = 2 * L_CODES + 1;\n      /* maximum heap size */\n\n      var MAX_BITS = 15;\n      /* All codes must not exceed MAX_BITS bits */\n\n      var MIN_MATCH = 3;\n      var MAX_MATCH = 258;\n      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n      var PRESET_DICT = 0x20;\n      var INIT_STATE = 42;\n      var EXTRA_STATE = 69;\n      var NAME_STATE = 73;\n      var COMMENT_STATE = 91;\n      var HCRC_STATE = 103;\n      var BUSY_STATE = 113;\n      var FINISH_STATE = 666;\n      var BS_NEED_MORE = 1;\n      /* block not completed, need more input or more output */\n\n      var BS_BLOCK_DONE = 2;\n      /* block flush performed */\n\n      var BS_FINISH_STARTED = 3;\n      /* finish started, need only more output at next deflate */\n\n      var BS_FINISH_DONE = 4;\n      /* finish done, accept no more input or output */\n\n      var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\n      function err(strm, errorCode) {\n        strm.msg = msg[errorCode];\n        return errorCode;\n      }\n\n      function rank(f) {\n        return (f << 1) - (f > 4 ? 9 : 0);\n      }\n\n      function zero(buf) {\n        var len = buf.length;\n\n        while (--len >= 0) {\n          buf[len] = 0;\n        }\n      }\n      /* =========================================================================\n       * Flush as much pending output as possible. All deflate() output goes\n       * through this function so some applications may wish to modify it\n       * to avoid allocating a large strm->output buffer and copying into it.\n       * (See also read_buf()).\n       */\n\n\n      function flush_pending(strm) {\n        var s = strm.state; //_tr_flush_bits(s);\n\n        var len = s.pending;\n\n        if (len > strm.avail_out) {\n          len = strm.avail_out;\n        }\n\n        if (len === 0) {\n          return;\n        }\n\n        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n        strm.next_out += len;\n        s.pending_out += len;\n        strm.total_out += len;\n        strm.avail_out -= len;\n        s.pending -= len;\n\n        if (s.pending === 0) {\n          s.pending_out = 0;\n        }\n      }\n\n      function flush_block_only(s, last) {\n        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\n        s.block_start = s.strstart;\n        flush_pending(s.strm);\n      }\n\n      function put_byte(s, b) {\n        s.pending_buf[s.pending++] = b;\n      }\n      /* =========================================================================\n       * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n       * IN assertion: the stream state is correct and there is enough room in\n       * pending_buf.\n       */\n\n\n      function putShortMSB(s, b) {\n        //  put_byte(s, (Byte)(b >> 8));\n        //  put_byte(s, (Byte)(b & 0xff));\n        s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n        s.pending_buf[s.pending++] = b & 0xff;\n      }\n      /* ===========================================================================\n       * Read a new buffer from the current input stream, update the adler32\n       * and total number of bytes read.  All deflate() input goes through\n       * this function so some applications may wish to modify it to avoid\n       * allocating a large strm->input buffer and copying from it.\n       * (See also flush_pending()).\n       */\n\n\n      function read_buf(strm, buf, start, size) {\n        var len = strm.avail_in;\n\n        if (len > size) {\n          len = size;\n        }\n\n        if (len === 0) {\n          return 0;\n        }\n\n        strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);\n\n        utils.arraySet(buf, strm.input, strm.next_in, len, start);\n\n        if (strm.state.wrap === 1) {\n          strm.adler = adler32(strm.adler, buf, len, start);\n        } else if (strm.state.wrap === 2) {\n          strm.adler = crc32(strm.adler, buf, len, start);\n        }\n\n        strm.next_in += len;\n        strm.total_in += len;\n        return len;\n      }\n      /* ===========================================================================\n       * Set match_start to the longest match starting at the given string and\n       * return its length. Matches shorter or equal to prev_length are discarded,\n       * in which case the result is equal to prev_length and match_start is\n       * garbage.\n       * IN assertions: cur_match is the head of the hash chain for the current\n       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n       * OUT assertion: the match length is not greater than s->lookahead.\n       */\n\n\n      function longest_match(s, cur_match) {\n        var chain_length = s.max_chain_length;\n        /* max hash chain length */\n\n        var scan = s.strstart;\n        /* current string */\n\n        var match;\n        /* matched string */\n\n        var len;\n        /* length of current match */\n\n        var best_len = s.prev_length;\n        /* best match length so far */\n\n        var nice_match = s.nice_match;\n        /* stop if match long enough */\n\n        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n        /*NIL*/\n        ;\n        var _win = s.window; // shortcut\n\n        var wmask = s.w_mask;\n        var prev = s.prev;\n        /* Stop when cur_match becomes <= limit. To simplify the code,\n         * we prevent matches with the string of window index 0.\n         */\n\n        var strend = s.strstart + MAX_MATCH;\n        var scan_end1 = _win[scan + best_len - 1];\n        var scan_end = _win[scan + best_len];\n        /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n         * It is easy to get rid of this optimization if necessary.\n         */\n        // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n        /* Do not waste too much time if we already have a good match: */\n\n        if (s.prev_length >= s.good_match) {\n          chain_length >>= 2;\n        }\n        /* Do not look for matches beyond the end of the input. This is necessary\n         * to make deflate deterministic.\n         */\n\n\n        if (nice_match > s.lookahead) {\n          nice_match = s.lookahead;\n        } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n\n        do {\n          // Assert(cur_match < s->strstart, \"no future\");\n          match = cur_match;\n          /* Skip to next match if the match length cannot increase\n           * or if the match length is less than 2.  Note that the checks below\n           * for insufficient lookahead only occur occasionally for performance\n           * reasons.  Therefore uninitialized memory will be accessed, and\n           * conditional jumps will be made that depend on those values.\n           * However the length of the match is limited to the lookahead, so\n           * the output of deflate is not affected by the uninitialized values.\n           */\n\n          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n          }\n          /* The check at best_len-1 can be removed because it will be made\n           * again later. (This heuristic is not always a win.)\n           * It is not necessary to compare scan[2] and match[2] since they\n           * are always equal when the other bytes match, given that\n           * the hash keys are equal and that HASH_BITS >= 8.\n           */\n\n\n          scan += 2;\n          match++; // Assert(*scan == *match, \"match[2]?\");\n\n          /* We check for insufficient lookahead only every 8th comparison;\n           * the 256th check will be made at strstart+258.\n           */\n\n          do {\n            /*jshint noempty:false*/\n          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n\n          len = MAX_MATCH - (strend - scan);\n          scan = strend - MAX_MATCH;\n\n          if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n\n            if (len >= nice_match) {\n              break;\n            }\n\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n          }\n        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n        if (best_len <= s.lookahead) {\n          return best_len;\n        }\n\n        return s.lookahead;\n      }\n      /* ===========================================================================\n       * Fill the window when the lookahead becomes insufficient.\n       * Updates strstart and lookahead.\n       *\n       * IN assertion: lookahead < MIN_LOOKAHEAD\n       * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n       *    At least one byte has been read, or avail_in == 0; reads are\n       *    performed for at least two bytes (required for the zip translate_eol\n       *    option -- not supported here).\n       */\n\n\n      function fill_window(s) {\n        var _w_size = s.w_size;\n        var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n        do {\n          more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed\n\n          /* Deal with !@#$% 64K limit: */\n          //if (sizeof(int) <= 2) {\n          //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n          //        more = wsize;\n          //\n          //  } else if (more == (unsigned)(-1)) {\n          //        /* Very unlikely, but possible on 16 bit machine if\n          //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n          //         */\n          //        more--;\n          //    }\n          //}\n\n          /* If the window is almost full and there is insufficient lookahead,\n           * move the upper half to the lower one to make room in the upper half.\n           */\n\n          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */\n\n            s.block_start -= _w_size;\n            /* Slide the hash table (could be avoided with 32 bit values\n             at the expense of memory usage). We slide even when level == 0\n             to keep the hash table consistent if we switch back to level > 0\n             later. (Using level 0 permanently is not an optimal usage of\n             zlib, so we don't care about this pathological case.)\n             */\n\n            n = s.hash_size;\n            p = n;\n\n            do {\n              m = s.head[--p];\n              s.head[p] = m >= _w_size ? m - _w_size : 0;\n            } while (--n);\n\n            n = _w_size;\n            p = n;\n\n            do {\n              m = s.prev[--p];\n              s.prev[p] = m >= _w_size ? m - _w_size : 0;\n              /* If n is not on any hash chain, prev[n] is garbage but\n               * its value will never be used.\n               */\n            } while (--n);\n\n            more += _w_size;\n          }\n\n          if (s.strm.avail_in === 0) {\n            break;\n          }\n          /* If there was no sliding:\n           *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n           *    more == window_size - lookahead - strstart\n           * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n           * => more >= window_size - 2*WSIZE + 2\n           * In the BIG_MEM or MMAP case (not yet supported),\n           *   window_size == input_size + MIN_LOOKAHEAD  &&\n           *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n           * Otherwise, window_size == 2*WSIZE so more >= 2.\n           * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n           */\n          //Assert(more >= 2, \"more < 2\");\n\n\n          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n          s.lookahead += n;\n          /* Initialize the hash value now that we have some input: */\n\n          if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n\n            while (s.insert) {\n              /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n              s.prev[str & s.w_mask] = s.head[s.ins_h];\n              s.head[s.ins_h] = str;\n              str++;\n              s.insert--;\n\n              if (s.lookahead + s.insert < MIN_MATCH) {\n                break;\n              }\n            }\n          }\n          /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n           * but this is not important since only literal bytes will be emitted.\n           */\n\n        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n        /* If the WIN_INIT bytes after the end of the current data have never been\n         * written, then zero those bytes in order to avoid memory check reports of\n         * the use of uninitialized (or uninitialised as Julian writes) bytes by\n         * the longest match routines.  Update the high water mark for the next\n         * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n         * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n         */\n        //  if (s.high_water < s.window_size) {\n        //    var curr = s.strstart + s.lookahead;\n        //    var init = 0;\n        //\n        //    if (s.high_water < curr) {\n        //      /* Previous high water mark below current data -- zero WIN_INIT\n        //       * bytes or up to end of window, whichever is less.\n        //       */\n        //      init = s.window_size - curr;\n        //      if (init > WIN_INIT)\n        //        init = WIN_INIT;\n        //      zmemzero(s->window + curr, (unsigned)init);\n        //      s->high_water = curr + init;\n        //    }\n        //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n        //      /* High water mark at or above current data, but below current data\n        //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n        //       * to end of window, whichever is less.\n        //       */\n        //      init = (ulg)curr + WIN_INIT - s->high_water;\n        //      if (init > s->window_size - s->high_water)\n        //        init = s->window_size - s->high_water;\n        //      zmemzero(s->window + s->high_water, (unsigned)init);\n        //      s->high_water += init;\n        //    }\n        //  }\n        //\n        //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n        //    \"not enough room for search\");\n\n      }\n      /* ===========================================================================\n       * Copy without compression as much as possible from the input stream, return\n       * the current block state.\n       * This function does not insert new strings in the dictionary since\n       * uncompressible data is probably not useful. This function is used\n       * only for the level=0 compression option.\n       * NOTE: this function should be optimized to avoid extra copying from\n       * window to pending_buf.\n       */\n\n\n      function deflate_stored(s, flush) {\n        /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n         * to pending_buf_size, and each stored block has a 5 byte header:\n         */\n        var max_block_size = 0xffff;\n\n        if (max_block_size > s.pending_buf_size - 5) {\n          max_block_size = s.pending_buf_size - 5;\n        }\n        /* Copy as much as possible from input to output: */\n\n\n        for (;;) {\n          /* Fill the window as much as possible: */\n          if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n            fill_window(s);\n\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            if (s.lookahead === 0) {\n              break;\n            }\n            /* flush the current block */\n\n          } //Assert(s->block_start >= 0L, \"block gone\");\n          //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n\n          s.strstart += s.lookahead;\n          s.lookahead = 0;\n          /* Emit a stored block if pending_buf will be full: */\n\n          var max_start = s.block_start + max_block_size;\n\n          if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */\n            s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/\n\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n          /* Flush if we may have to slide, otherwise block_start may become\n           * negative and the data will be gone:\n           */\n\n\n          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        }\n\n        s.insert = 0;\n\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n\n\n          return BS_FINISH_DONE;\n        }\n\n        if (s.strstart > s.block_start) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n\n        return BS_NEED_MORE;\n      }\n      /* ===========================================================================\n       * Compress as much as possible from the input stream, return the current\n       * block state.\n       * This function does not perform lazy evaluation of matches and inserts\n       * new strings in the dictionary only for unmatched strings or for short\n       * matches. It is used only for the fast compression options.\n       */\n\n\n      function deflate_fast(s, flush) {\n        var hash_head;\n        /* head of the hash chain */\n\n        var bflush;\n        /* set if current block must be flushed */\n\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\n           * at the end of the input file. We need MAX_MATCH bytes\n           * for the next match, plus MIN_MATCH bytes to insert the\n           * string following the next match.\n           */\n          if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            if (s.lookahead === 0) {\n              break;\n              /* flush the current block */\n            }\n          }\n          /* Insert the string window[strstart .. strstart+2] in the\n           * dictionary, and set hash_head to the head of the hash chain:\n           */\n\n\n          hash_head = 0\n          /*NIL*/\n          ;\n\n          if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n          /* Find the longest match, discarding those <= prev_length.\n           * At this point we have always match_length < MIN_MATCH\n           */\n\n\n          if (hash_head !== 0\n          /*NIL*/\n          && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */\n          }\n\n          if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                           s.match_length - MIN_MATCH, bflush); ***/\n            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n\n            if (s.match_length <= s.max_lazy_match\n            /*max_insert_length*/\n            && s.lookahead >= MIN_MATCH) {\n              s.match_length--;\n              /* string at strstart already in table */\n\n              do {\n                s.strstart++;\n                /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\n                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n                /***/\n\n                /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                 * always MIN_MATCH bytes ahead.\n                 */\n              } while (--s.match_length !== 0);\n\n              s.strstart++;\n            } else {\n              s.strstart += s.match_length;\n              s.match_length = 0;\n              s.ins_h = s.window[s.strstart];\n              /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3\n              //                Call UPDATE_HASH() MIN_MATCH-3 more times\n              //#endif\n\n              /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n               * matter since it will be recomputed at next deflate call.\n               */\n            }\n          } else {\n            /* No match, output a literal byte */\n            //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n          }\n\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        }\n\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n\n\n          return BS_FINISH_DONE;\n        }\n\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n\n        return BS_BLOCK_DONE;\n      }\n      /* ===========================================================================\n       * Same as above, but achieves better compression. We use a lazy\n       * evaluation for matches: a match is finally adopted only if there is\n       * no better match at the next window position.\n       */\n\n\n      function deflate_slow(s, flush) {\n        var hash_head;\n        /* head of hash chain */\n\n        var bflush;\n        /* set if current block must be flushed */\n\n        var max_insert;\n        /* Process the input block. */\n\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\n           * at the end of the input file. We need MAX_MATCH bytes\n           * for the next match, plus MIN_MATCH bytes to insert the\n           * string following the next match.\n           */\n          if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            if (s.lookahead === 0) {\n              break;\n            }\n            /* flush the current block */\n\n          }\n          /* Insert the string window[strstart .. strstart+2] in the\n           * dictionary, and set hash_head to the head of the hash chain:\n           */\n\n\n          hash_head = 0\n          /*NIL*/\n          ;\n\n          if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n            /***/\n          }\n          /* Find the longest match, discarding those <= prev_length.\n           */\n\n\n          s.prev_length = s.match_length;\n          s.prev_match = s.match_start;\n          s.match_length = MIN_MATCH - 1;\n\n          if (hash_head !== 0\n          /*NIL*/\n          && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n          /*MAX_DIST(s)*/\n          ) {\n              /* To simplify the code, we prevent matches with the string\n               * of window index 0 (in particular we have to avoid a match\n               * of the string with itself at the start of the input file).\n               */\n              s.match_length = longest_match(s, hash_head);\n              /* longest_match() sets match_start */\n\n              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096\n              /*TOO_FAR*/\n              )) {\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s.match_length = MIN_MATCH - 1;\n              }\n            }\n          /* If there was a match at the previous step and the current\n           * match is not better, output the previous match:\n           */\n\n\n          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n            //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                           s.prev_length - MIN_MATCH, bflush);***/\n\n            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart-1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n\n            s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n\n            do {\n              if (++s.strstart <= max_insert) {\n                /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = s.strstart;\n                /***/\n              }\n            } while (--s.prev_length !== 0);\n\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n\n            if (bflush) {\n              /*** FLUSH_BLOCK(s, 0); ***/\n              flush_block_only(s, false);\n\n              if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n              }\n              /***/\n\n            }\n          } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n            if (bflush) {\n              /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n              flush_block_only(s, false);\n              /***/\n            }\n\n            s.strstart++;\n            s.lookahead--;\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n          } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n          }\n        } //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n\n        if (s.match_available) {\n          //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n          s.match_available = 0;\n        }\n\n        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n\n\n          return BS_FINISH_DONE;\n        }\n\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n\n        return BS_BLOCK_DONE;\n      }\n      /* ===========================================================================\n       * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n       * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n       * deflate switches away from Z_RLE.)\n       */\n\n\n      function deflate_rle(s, flush) {\n        var bflush;\n        /* set if current block must be flushed */\n\n        var prev;\n        /* byte at distance one to match */\n\n        var scan, strend;\n        /* scan goes up to strend for length of run */\n\n        var _win = s.window;\n\n        for (;;) {\n          /* Make sure that we always have enough lookahead, except\n           * at the end of the input file. We need MAX_MATCH bytes\n           * for the longest run, plus one for the unrolled loop.\n           */\n          if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE;\n            }\n\n            if (s.lookahead === 0) {\n              break;\n            }\n            /* flush the current block */\n\n          }\n          /* See how many times the previous byte repeats */\n\n\n          s.match_length = 0;\n\n          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n              strend = s.strstart + MAX_MATCH;\n\n              do {\n                /*jshint noempty:false*/\n              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\n              s.match_length = MAX_MATCH - (strend - scan);\n\n              if (s.match_length > s.lookahead) {\n                s.match_length = s.lookahead;\n              }\n            } //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\n          }\n          /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n\n          if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n          } else {\n            /* No match, output a literal byte */\n            //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n          }\n\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        }\n\n        s.insert = 0;\n\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n\n\n          return BS_FINISH_DONE;\n        }\n\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n\n        return BS_BLOCK_DONE;\n      }\n      /* ===========================================================================\n       * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n       * (It will be regenerated if this run of deflate switches away from Huffman.)\n       */\n\n\n      function deflate_huff(s, flush) {\n        var bflush;\n        /* set if current block must be flushed */\n\n        for (;;) {\n          /* Make sure that we have a literal to write. */\n          if (s.lookahead === 0) {\n            fill_window(s);\n\n            if (s.lookahead === 0) {\n              if (flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n              }\n\n              break;\n              /* flush the current block */\n            }\n          }\n          /* Output a literal byte */\n\n\n          s.match_length = 0; //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\n          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n          s.lookahead--;\n          s.strstart++;\n\n          if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/\n            flush_block_only(s, false);\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE;\n            }\n            /***/\n\n          }\n        }\n\n        s.insert = 0;\n\n        if (flush === Z_FINISH) {\n          /*** FLUSH_BLOCK(s, 1); ***/\n          flush_block_only(s, true);\n\n          if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n          }\n          /***/\n\n\n          return BS_FINISH_DONE;\n        }\n\n        if (s.last_lit) {\n          /*** FLUSH_BLOCK(s, 0); ***/\n          flush_block_only(s, false);\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n          }\n          /***/\n\n        }\n\n        return BS_BLOCK_DONE;\n      }\n      /* Values for max_lazy_match, good_match and max_chain_length, depending on\n       * the desired pack level (0..9). The values given below have been tuned to\n       * exclude worst case performance for pathological files. Better values may be\n       * found for specific files.\n       */\n\n\n      function Config(good_length, max_lazy, nice_length, max_chain, func) {\n        this.good_length = good_length;\n        this.max_lazy = max_lazy;\n        this.nice_length = nice_length;\n        this.max_chain = max_chain;\n        this.func = func;\n      }\n\n      var configuration_table;\n      configuration_table = [\n      /*      good lazy nice chain */\n      new Config(0, 0, 0, 0, deflate_stored),\n      /* 0 store only */\n      new Config(4, 4, 8, 4, deflate_fast),\n      /* 1 max speed, no lazy matches */\n      new Config(4, 5, 16, 8, deflate_fast),\n      /* 2 */\n      new Config(4, 6, 32, 32, deflate_fast),\n      /* 3 */\n      new Config(4, 4, 16, 16, deflate_slow),\n      /* 4 lazy matches */\n      new Config(8, 16, 32, 32, deflate_slow),\n      /* 5 */\n      new Config(8, 16, 128, 128, deflate_slow),\n      /* 6 */\n      new Config(8, 32, 128, 256, deflate_slow),\n      /* 7 */\n      new Config(32, 128, 258, 1024, deflate_slow),\n      /* 8 */\n      new Config(32, 258, 258, 4096, deflate_slow)\n      /* 9 max compression */\n      ];\n      /* ===========================================================================\n       * Initialize the \"longest match\" routines for a new zlib stream\n       */\n\n      function lm_init(s) {\n        s.window_size = 2 * s.w_size;\n        /*** CLEAR_HASH(s); ***/\n\n        zero(s.head); // Fill with NIL (= 0);\n\n        /* Set the default configuration parameters:\n         */\n\n        s.max_lazy_match = configuration_table[s.level].max_lazy;\n        s.good_match = configuration_table[s.level].good_length;\n        s.nice_match = configuration_table[s.level].nice_length;\n        s.max_chain_length = configuration_table[s.level].max_chain;\n        s.strstart = 0;\n        s.block_start = 0;\n        s.lookahead = 0;\n        s.insert = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        s.ins_h = 0;\n      }\n\n      function DeflateState() {\n        this.strm = null;\n        /* pointer back to this zlib stream */\n\n        this.status = 0;\n        /* as the name implies */\n\n        this.pending_buf = null;\n        /* output still pending */\n\n        this.pending_buf_size = 0;\n        /* size of pending_buf */\n\n        this.pending_out = 0;\n        /* next pending byte to output to the stream */\n\n        this.pending = 0;\n        /* nb of bytes in the pending buffer */\n\n        this.wrap = 0;\n        /* bit 0 true for zlib, bit 1 true for gzip */\n\n        this.gzhead = null;\n        /* gzip header information to write */\n\n        this.gzindex = 0;\n        /* where in extra, name, or comment */\n\n        this.method = Z_DEFLATED;\n        /* can only be DEFLATED */\n\n        this.last_flush = -1;\n        /* value of flush param for previous deflate call */\n\n        this.w_size = 0;\n        /* LZ77 window size (32K by default) */\n\n        this.w_bits = 0;\n        /* log2(w_size)  (8..16) */\n\n        this.w_mask = 0;\n        /* w_size - 1 */\n\n        this.window = null;\n        /* Sliding window. Input bytes are read into the second half of the window,\n         * and move to the first half later to keep a dictionary of at least wSize\n         * bytes. With this organization, matches are limited to a distance of\n         * wSize-MAX_MATCH bytes, but this ensures that IO is always\n         * performed with a length multiple of the block size.\n         */\n\n        this.window_size = 0;\n        /* Actual size of window: 2*wSize, except when the user input buffer\n         * is directly used as sliding window.\n         */\n\n        this.prev = null;\n        /* Link to older string with same hash index. To limit the size of this\n         * array to 64K, this link is maintained only for the last 32K strings.\n         * An index in this array is thus a window index modulo 32K.\n         */\n\n        this.head = null;\n        /* Heads of the hash chains or NIL. */\n\n        this.ins_h = 0;\n        /* hash index of string to be inserted */\n\n        this.hash_size = 0;\n        /* number of elements in hash table */\n\n        this.hash_bits = 0;\n        /* log2(hash_size) */\n\n        this.hash_mask = 0;\n        /* hash_size-1 */\n\n        this.hash_shift = 0;\n        /* Number of bits by which ins_h must be shifted at each input\n         * step. It must be such that after MIN_MATCH steps, the oldest\n         * byte no longer takes part in the hash key, that is:\n         *   hash_shift * MIN_MATCH >= hash_bits\n         */\n\n        this.block_start = 0;\n        /* Window position at the beginning of the current output block. Gets\n         * negative when the window is moved backwards.\n         */\n\n        this.match_length = 0;\n        /* length of best match */\n\n        this.prev_match = 0;\n        /* previous match */\n\n        this.match_available = 0;\n        /* set if previous match exists */\n\n        this.strstart = 0;\n        /* start of string to insert */\n\n        this.match_start = 0;\n        /* start of matching string */\n\n        this.lookahead = 0;\n        /* number of valid bytes ahead in window */\n\n        this.prev_length = 0;\n        /* Length of the best match at previous step. Matches not greater than this\n         * are discarded. This is used in the lazy match evaluation.\n         */\n\n        this.max_chain_length = 0;\n        /* To speed up deflation, hash chains are never searched beyond this\n         * length.  A higher limit improves compression ratio but degrades the\n         * speed.\n         */\n\n        this.max_lazy_match = 0;\n        /* Attempt to find a better match only when the current match is strictly\n         * smaller than this value. This mechanism is used only for compression\n         * levels >= 4.\n         */\n        // That's alias to max_lazy_match, don't use directly\n        //this.max_insert_length = 0;\n\n        /* Insert new strings in the hash table only if the match length is not\n         * greater than this length. This saves time but degrades compression.\n         * max_insert_length is used only for compression levels <= 3.\n         */\n\n        this.level = 0;\n        /* compression level (1..9) */\n\n        this.strategy = 0;\n        /* favor or force Huffman coding*/\n\n        this.good_match = 0;\n        /* Use a faster search when the previous match is longer than this */\n\n        this.nice_match = 0;\n        /* Stop searching when current match exceeds this */\n\n        /* used by trees.c: */\n\n        /* Didn't use ct_data typedef below to suppress compiler warning */\n        // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n        // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n        // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n        // Use flat array of DOUBLE size, with interleaved fata,\n        // because JS does not support effective\n\n        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n        zero(this.dyn_ltree);\n        zero(this.dyn_dtree);\n        zero(this.bl_tree);\n        this.l_desc = null;\n        /* desc. for literal tree */\n\n        this.d_desc = null;\n        /* desc. for distance tree */\n\n        this.bl_desc = null;\n        /* desc. for bit length tree */\n        //ush bl_count[MAX_BITS+1];\n\n        this.bl_count = new utils.Buf16(MAX_BITS + 1);\n        /* number of codes at each bit length for an optimal tree */\n        //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n        this.heap = new utils.Buf16(2 * L_CODES + 1);\n        /* heap used to build the Huffman trees */\n\n        zero(this.heap);\n        this.heap_len = 0;\n        /* number of elements in the heap */\n\n        this.heap_max = 0;\n        /* element of largest frequency */\n\n        /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n         * The same heap array is used to build all trees.\n         */\n\n        this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\n        zero(this.depth);\n        /* Depth of each subtree used as tie breaker for trees of equal frequency\n         */\n\n        this.l_buf = 0;\n        /* buffer index for literals or lengths */\n\n        this.lit_bufsize = 0;\n        /* Size of match buffer for literals/lengths.  There are 4 reasons for\n         * limiting lit_bufsize to 64K:\n         *   - frequencies can be kept in 16 bit counters\n         *   - if compression is not successful for the first block, all input\n         *     data is still in the window so we can still emit a stored block even\n         *     when input comes from standard input.  (This can also be done for\n         *     all blocks if lit_bufsize is not greater than 32K.)\n         *   - if compression is not successful for a file smaller than 64K, we can\n         *     even emit a stored file instead of a stored block (saving 5 bytes).\n         *     This is applicable only for zip (not gzip or zlib).\n         *   - creating new Huffman trees less frequently may not provide fast\n         *     adaptation to changes in the input data statistics. (Take for\n         *     example a binary file with poorly compressible code followed by\n         *     a highly compressible string table.) Smaller buffer sizes give\n         *     fast adaptation but have of course the overhead of transmitting\n         *     trees more frequently.\n         *   - I can't count above 4\n         */\n\n        this.last_lit = 0;\n        /* running index in l_buf */\n\n        this.d_buf = 0;\n        /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n         * the same number of elements. To use different lengths, an extra flag\n         * array would be necessary.\n         */\n\n        this.opt_len = 0;\n        /* bit length of current block with optimal trees */\n\n        this.static_len = 0;\n        /* bit length of current block with static trees */\n\n        this.matches = 0;\n        /* number of string matches in current block */\n\n        this.insert = 0;\n        /* bytes at end of window left to insert */\n\n        this.bi_buf = 0;\n        /* Output buffer. bits are inserted starting at the bottom (least\n         * significant bits).\n         */\n\n        this.bi_valid = 0;\n        /* Number of valid bits in bi_buf.  All bits above the last valid bit\n         * are always zero.\n         */\n        // Used for window memory init. We safely ignore it for JS. That makes\n        // sense only for pointers and memory check tools.\n        //this.high_water = 0;\n\n        /* High water mark offset in window for initialized bytes -- bytes above\n         * this are set to zero in order to avoid memory check warnings when\n         * longest match routines access bytes past the input.  This is then\n         * updated to the new high water mark.\n         */\n      }\n\n      function deflateResetKeep(strm) {\n        var s;\n\n        if (!strm || !strm.state) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n\n        strm.total_in = strm.total_out = 0;\n        strm.data_type = Z_UNKNOWN;\n        s = strm.state;\n        s.pending = 0;\n        s.pending_out = 0;\n\n        if (s.wrap < 0) {\n          s.wrap = -s.wrap;\n          /* was made negative by deflate(..., Z_FINISH); */\n        }\n\n        s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n        strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n        : 1; // adler32(0, Z_NULL, 0)\n\n        s.last_flush = Z_NO_FLUSH;\n\n        trees._tr_init(s);\n\n        return Z_OK;\n      }\n\n      function deflateReset(strm) {\n        var ret = deflateResetKeep(strm);\n\n        if (ret === Z_OK) {\n          lm_init(strm.state);\n        }\n\n        return ret;\n      }\n\n      function deflateSetHeader(strm, head) {\n        if (!strm || !strm.state) {\n          return Z_STREAM_ERROR;\n        }\n\n        if (strm.state.wrap !== 2) {\n          return Z_STREAM_ERROR;\n        }\n\n        strm.state.gzhead = head;\n        return Z_OK;\n      }\n\n      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n        if (!strm) {\n          // === Z_NULL\n          return Z_STREAM_ERROR;\n        }\n\n        var wrap = 1;\n\n        if (level === Z_DEFAULT_COMPRESSION) {\n          level = 6;\n        }\n\n        if (windowBits < 0) {\n          /* suppress zlib wrapper */\n          wrap = 0;\n          windowBits = -windowBits;\n        } else if (windowBits > 15) {\n          wrap = 2;\n          /* write gzip wrapper instead */\n\n          windowBits -= 16;\n        }\n\n        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n\n        if (windowBits === 8) {\n          windowBits = 9;\n        }\n        /* until 256-byte window bug fixed */\n\n\n        var s = new DeflateState();\n        strm.state = s;\n        s.strm = strm;\n        s.wrap = wrap;\n        s.gzhead = null;\n        s.w_bits = windowBits;\n        s.w_size = 1 << s.w_bits;\n        s.w_mask = s.w_size - 1;\n        s.hash_bits = memLevel + 7;\n        s.hash_size = 1 << s.hash_bits;\n        s.hash_mask = s.hash_size - 1;\n        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n        s.window = new utils.Buf8(s.w_size * 2);\n        s.head = new utils.Buf16(s.hash_size);\n        s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.\n        //s.high_water = 0;  /* nothing written to s->window yet */\n\n        s.lit_bufsize = 1 << memLevel + 6;\n        /* 16K elements by default */\n\n        s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n        //s->pending_buf = (uchf *) overlay;\n\n        s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n        //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n        s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n        s.l_buf = (1 + 2) * s.lit_bufsize;\n        s.level = level;\n        s.strategy = strategy;\n        s.method = method;\n        return deflateReset(strm);\n      }\n\n      function deflateInit(strm, level) {\n        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n      }\n\n      function deflate(strm, flush) {\n        var old_flush, s;\n        var beg, val; // for gzip header write only\n\n        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n        }\n\n        s = strm.state;\n\n        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n        }\n\n        s.strm = strm;\n        /* just in case */\n\n        old_flush = s.last_flush;\n        s.last_flush = flush;\n        /* Write the header */\n\n        if (s.status === INIT_STATE) {\n          if (s.wrap === 2) {\n            // GZIP header\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n\n            if (!s.gzhead) {\n              // s->gzhead == Z_NULL\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, 0);\n              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n              put_byte(s, OS_CODE);\n              s.status = BUSY_STATE;\n            } else {\n              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n              put_byte(s, s.gzhead.time & 0xff);\n              put_byte(s, s.gzhead.time >> 8 & 0xff);\n              put_byte(s, s.gzhead.time >> 16 & 0xff);\n              put_byte(s, s.gzhead.time >> 24 & 0xff);\n              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n              put_byte(s, s.gzhead.os & 0xff);\n\n              if (s.gzhead.extra && s.gzhead.extra.length) {\n                put_byte(s, s.gzhead.extra.length & 0xff);\n                put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n              }\n\n              if (s.gzhead.hcrc) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n              }\n\n              s.gzindex = 0;\n              s.status = EXTRA_STATE;\n            }\n          } else // DEFLATE header\n            {\n              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n              var level_flags = -1;\n\n              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n              } else if (s.level < 6) {\n                level_flags = 1;\n              } else if (s.level === 6) {\n                level_flags = 2;\n              } else {\n                level_flags = 3;\n              }\n\n              header |= level_flags << 6;\n\n              if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n              }\n\n              header += 31 - header % 31;\n              s.status = BUSY_STATE;\n              putShortMSB(s, header);\n              /* Save the adler32 of the preset dictionary: */\n\n              if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n              }\n\n              strm.adler = 1; // adler32(0L, Z_NULL, 0);\n            }\n        } //#ifdef GZIP\n\n\n        if (s.status === EXTRA_STATE) {\n          if (s.gzhead.extra\n          /* != Z_NULL*/\n          ) {\n              beg = s.pending;\n              /* start of bytes to update crc */\n\n              while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n                if (s.pending === s.pending_buf_size) {\n                  if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                  }\n\n                  flush_pending(strm);\n                  beg = s.pending;\n\n                  if (s.pending === s.pending_buf_size) {\n                    break;\n                  }\n                }\n\n                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                s.gzindex++;\n              }\n\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              if (s.gzindex === s.gzhead.extra.length) {\n                s.gzindex = 0;\n                s.status = NAME_STATE;\n              }\n            } else {\n            s.status = NAME_STATE;\n          }\n        }\n\n        if (s.status === NAME_STATE) {\n          if (s.gzhead.name\n          /* != Z_NULL*/\n          ) {\n              beg = s.pending;\n              /* start of bytes to update crc */\n              //int val;\n\n              do {\n                if (s.pending === s.pending_buf_size) {\n                  if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                  }\n\n                  flush_pending(strm);\n                  beg = s.pending;\n\n                  if (s.pending === s.pending_buf_size) {\n                    val = 1;\n                    break;\n                  }\n                } // JS specific: little magic to add zero terminator to end of string\n\n\n                if (s.gzindex < s.gzhead.name.length) {\n                  val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                  val = 0;\n                }\n\n                put_byte(s, val);\n              } while (val !== 0);\n\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              if (val === 0) {\n                s.gzindex = 0;\n                s.status = COMMENT_STATE;\n              }\n            } else {\n            s.status = COMMENT_STATE;\n          }\n        }\n\n        if (s.status === COMMENT_STATE) {\n          if (s.gzhead.comment\n          /* != Z_NULL*/\n          ) {\n              beg = s.pending;\n              /* start of bytes to update crc */\n              //int val;\n\n              do {\n                if (s.pending === s.pending_buf_size) {\n                  if (s.gzhead.hcrc && s.pending > beg) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                  }\n\n                  flush_pending(strm);\n                  beg = s.pending;\n\n                  if (s.pending === s.pending_buf_size) {\n                    val = 1;\n                    break;\n                  }\n                } // JS specific: little magic to add zero terminator to end of string\n\n\n                if (s.gzindex < s.gzhead.comment.length) {\n                  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                  val = 0;\n                }\n\n                put_byte(s, val);\n              } while (val !== 0);\n\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n              }\n\n              if (val === 0) {\n                s.status = HCRC_STATE;\n              }\n            } else {\n            s.status = HCRC_STATE;\n          }\n        }\n\n        if (s.status === HCRC_STATE) {\n          if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n              flush_pending(strm);\n            }\n\n            if (s.pending + 2 <= s.pending_buf_size) {\n              put_byte(s, strm.adler & 0xff);\n              put_byte(s, strm.adler >> 8 & 0xff);\n              strm.adler = 0; //crc32(0L, Z_NULL, 0);\n\n              s.status = BUSY_STATE;\n            }\n          } else {\n            s.status = BUSY_STATE;\n          }\n        } //#endif\n\n        /* Flush as much pending output as possible */\n\n\n        if (s.pending !== 0) {\n          flush_pending(strm);\n\n          if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\n             * more output space, but possibly with both pending and\n             * avail_in equal to zero. There won't be anything to do,\n             * but this is not an error situation so make sure we\n             * return OK instead of BUF_ERROR at next call of deflate:\n             */\n            s.last_flush = -1;\n            return Z_OK;\n          }\n          /* Make sure there is something to do and avoid duplicate consecutive\n           * flushes. For repeated and useless calls with Z_FINISH, we keep\n           * returning Z_STREAM_END instead of Z_BUF_ERROR.\n           */\n\n        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n          return err(strm, Z_BUF_ERROR);\n        }\n        /* User must not provide more input after the first FINISH: */\n\n\n        if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n          return err(strm, Z_BUF_ERROR);\n        }\n        /* Start a new block or continue the current one.\n         */\n\n\n        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\n          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n          }\n\n          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n              s.last_flush = -1;\n              /* avoid BUF_ERROR next call, see above */\n            }\n\n            return Z_OK;\n            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n             * of deflate should use the same flush parameter to make sure\n             * that the flush is complete. So we don't have to output an\n             * empty block here, this will be done at next call. This also\n             * ensures that for a very small output buffer, we emit at most\n             * one empty block.\n             */\n          }\n\n          if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n              trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n              /* FULL_FLUSH or SYNC_FLUSH */\n              trees._tr_stored_block(s, 0, 0, false);\n              /* For a full flush, this empty block will be recognized\n               * as a special marker by inflate_sync().\n               */\n\n\n              if (flush === Z_FULL_FLUSH) {\n                /*** CLEAR_HASH(s); ***/\n\n                /* forget history */\n                zero(s.head); // Fill with NIL (= 0);\n\n                if (s.lookahead === 0) {\n                  s.strstart = 0;\n                  s.block_start = 0;\n                  s.insert = 0;\n                }\n              }\n            }\n\n            flush_pending(strm);\n\n            if (strm.avail_out === 0) {\n              s.last_flush = -1;\n              /* avoid BUF_ERROR at next call, see above */\n\n              return Z_OK;\n            }\n          }\n        } //Assert(strm->avail_out > 0, \"bug2\");\n        //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n\n        if (flush !== Z_FINISH) {\n          return Z_OK;\n        }\n\n        if (s.wrap <= 0) {\n          return Z_STREAM_END;\n        }\n        /* Write the trailer */\n\n\n        if (s.wrap === 2) {\n          put_byte(s, strm.adler & 0xff);\n          put_byte(s, strm.adler >> 8 & 0xff);\n          put_byte(s, strm.adler >> 16 & 0xff);\n          put_byte(s, strm.adler >> 24 & 0xff);\n          put_byte(s, strm.total_in & 0xff);\n          put_byte(s, strm.total_in >> 8 & 0xff);\n          put_byte(s, strm.total_in >> 16 & 0xff);\n          put_byte(s, strm.total_in >> 24 & 0xff);\n        } else {\n          putShortMSB(s, strm.adler >>> 16);\n          putShortMSB(s, strm.adler & 0xffff);\n        }\n\n        flush_pending(strm);\n        /* If avail_out is zero, the application will call deflate again\n         * to flush the rest.\n         */\n\n        if (s.wrap > 0) {\n          s.wrap = -s.wrap;\n        }\n        /* write the trailer only once! */\n\n\n        return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n      }\n\n      function deflateEnd(strm) {\n        var status;\n\n        if (!strm\n        /*== Z_NULL*/\n        || !strm.state\n        /*== Z_NULL*/\n        ) {\n            return Z_STREAM_ERROR;\n          }\n\n        status = strm.state.status;\n\n        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n          return err(strm, Z_STREAM_ERROR);\n        }\n\n        strm.state = null;\n        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n      }\n      /* =========================================================================\n       * Initializes the compression dictionary from the given byte\n       * sequence without producing any compressed output.\n       */\n\n\n      function deflateSetDictionary(strm, dictionary) {\n        var dictLength = dictionary.length;\n        var s;\n        var str, n;\n        var wrap;\n        var avail;\n        var next;\n        var input;\n        var tmpDict;\n\n        if (!strm\n        /*== Z_NULL*/\n        || !strm.state\n        /*== Z_NULL*/\n        ) {\n            return Z_STREAM_ERROR;\n          }\n\n        s = strm.state;\n        wrap = s.wrap;\n\n        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n          return Z_STREAM_ERROR;\n        }\n        /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n\n        if (wrap === 1) {\n          /* adler32(strm->adler, dictionary, dictLength); */\n          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n        }\n\n        s.wrap = 0;\n        /* avoid computing Adler-32 in read_buf */\n\n        /* if dictionary would fill window, just replace the history */\n\n        if (dictLength >= s.w_size) {\n          if (wrap === 0) {\n            /* already empty otherwise */\n\n            /*** CLEAR_HASH(s); ***/\n            zero(s.head); // Fill with NIL (= 0);\n\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n          /* use the tail */\n          // dictionary = dictionary.slice(dictLength - s.w_size);\n\n\n          tmpDict = new utils.Buf8(s.w_size);\n          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n          dictionary = tmpDict;\n          dictLength = s.w_size;\n        }\n        /* insert dictionary into window and hash */\n\n\n        avail = strm.avail_in;\n        next = strm.next_in;\n        input = strm.input;\n        strm.avail_in = dictLength;\n        strm.next_in = 0;\n        strm.input = dictionary;\n        fill_window(s);\n\n        while (s.lookahead >= MIN_MATCH) {\n          str = s.strstart;\n          n = s.lookahead - (MIN_MATCH - 1);\n\n          do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n          } while (--n);\n\n          s.strstart = str;\n          s.lookahead = MIN_MATCH - 1;\n          fill_window(s);\n        }\n\n        s.strstart += s.lookahead;\n        s.block_start = s.strstart;\n        s.insert = s.lookahead;\n        s.lookahead = 0;\n        s.match_length = s.prev_length = MIN_MATCH - 1;\n        s.match_available = 0;\n        strm.next_in = next;\n        strm.input = input;\n        strm.avail_in = avail;\n        s.wrap = wrap;\n        return Z_OK;\n      }\n\n      exports.deflateInit = deflateInit;\n      exports.deflateInit2 = deflateInit2;\n      exports.deflateReset = deflateReset;\n      exports.deflateResetKeep = deflateResetKeep;\n      exports.deflateSetHeader = deflateSetHeader;\n      exports.deflate = deflate;\n      exports.deflateEnd = deflateEnd;\n      exports.deflateSetDictionary = deflateSetDictionary;\n      exports.deflateInfo = 'pako deflate (from Nodeca project)';\n      /* Not implemented\n      exports.deflateBound = deflateBound;\n      exports.deflateCopy = deflateCopy;\n      exports.deflateParams = deflateParams;\n      exports.deflatePending = deflatePending;\n      exports.deflatePrime = deflatePrime;\n      exports.deflateTune = deflateTune;\n      */\n    }, {\n      \"../utils/common\": 1,\n      \"./adler32\": 3,\n      \"./crc32\": 4,\n      \"./messages\": 6,\n      \"./trees\": 7\n    }],\n    6: [function (require, module, exports) {\n      'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      module.exports = {\n        2: 'need dictionary',\n\n        /* Z_NEED_DICT       2  */\n        1: 'stream end',\n\n        /* Z_STREAM_END      1  */\n        0: '',\n\n        /* Z_OK              0  */\n        '-1': 'file error',\n\n        /* Z_ERRNO         (-1) */\n        '-2': 'stream error',\n\n        /* Z_STREAM_ERROR  (-2) */\n        '-3': 'data error',\n\n        /* Z_DATA_ERROR    (-3) */\n        '-4': 'insufficient memory',\n\n        /* Z_MEM_ERROR     (-4) */\n        '-5': 'buffer error',\n\n        /* Z_BUF_ERROR     (-5) */\n        '-6': 'incompatible version'\n        /* Z_VERSION_ERROR (-6) */\n\n      };\n    }, {}],\n    7: [function (require, module, exports) {\n      'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      /* eslint-disable space-unary-ops */\n\n      var utils = require('../utils/common');\n      /* Public constants ==========================================================*/\n\n      /* ===========================================================================*/\n      //var Z_FILTERED          = 1;\n      //var Z_HUFFMAN_ONLY      = 2;\n      //var Z_RLE               = 3;\n\n\n      var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;\n\n      /* Possible values of the data_type field (though see inflate()) */\n\n      var Z_BINARY = 0;\n      var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT\n\n      var Z_UNKNOWN = 2;\n      /*============================================================================*/\n\n      function zero(buf) {\n        var len = buf.length;\n\n        while (--len >= 0) {\n          buf[len] = 0;\n        }\n      } // From zutil.h\n\n\n      var STORED_BLOCK = 0;\n      var STATIC_TREES = 1;\n      var DYN_TREES = 2;\n      /* The three kinds of block type */\n\n      var MIN_MATCH = 3;\n      var MAX_MATCH = 258;\n      /* The minimum and maximum match lengths */\n      // From deflate.h\n\n      /* ===========================================================================\n       * Internal compression state.\n       */\n\n      var LENGTH_CODES = 29;\n      /* number of length codes, not counting the special END_BLOCK code */\n\n      var LITERALS = 256;\n      /* number of literal bytes 0..255 */\n\n      var L_CODES = LITERALS + 1 + LENGTH_CODES;\n      /* number of Literal or Length codes, including the END_BLOCK code */\n\n      var D_CODES = 30;\n      /* number of distance codes */\n\n      var BL_CODES = 19;\n      /* number of codes used to transfer the bit lengths */\n\n      var HEAP_SIZE = 2 * L_CODES + 1;\n      /* maximum heap size */\n\n      var MAX_BITS = 15;\n      /* All codes must not exceed MAX_BITS bits */\n\n      var Buf_size = 16;\n      /* size of bit buffer in bi_buf */\n\n      /* ===========================================================================\n       * Constants\n       */\n\n      var MAX_BL_BITS = 7;\n      /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n      var END_BLOCK = 256;\n      /* end of block literal code */\n\n      var REP_3_6 = 16;\n      /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n      var REPZ_3_10 = 17;\n      /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n      var REPZ_11_138 = 18;\n      /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n      /* eslint-disable comma-spacing,array-bracket-spacing */\n\n      var extra_lbits =\n      /* extra bits for each length code */\n      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n      var extra_dbits =\n      /* extra bits for each distance code */\n      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n      var extra_blbits =\n      /* extra bits for each bit length code */\n      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n      /* eslint-enable comma-spacing,array-bracket-spacing */\n\n      /* The lengths of the bit length codes are sent in order of decreasing\n       * probability, to avoid transmitting the lengths for unused bit length codes.\n       */\n\n      /* ===========================================================================\n       * Local data. These are initialized only once.\n       */\n      // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n      var DIST_CODE_LEN = 512;\n      /* see definition of array dist_code below */\n      // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\n      var static_ltree = new Array((L_CODES + 2) * 2);\n      zero(static_ltree);\n      /* The static literal tree. Since the bit lengths are imposed, there is no\n       * need for the L_CODES extra codes used during heap construction. However\n       * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n       * below).\n       */\n\n      var static_dtree = new Array(D_CODES * 2);\n      zero(static_dtree);\n      /* The static distance tree. (Actually a trivial tree since all codes use\n       * 5 bits.)\n       */\n\n      var _dist_code = new Array(DIST_CODE_LEN);\n\n      zero(_dist_code);\n      /* Distance codes. The first 256 values correspond to the distances\n       * 3 .. 258, the last 256 values correspond to the top 8 bits of\n       * the 15 bit distances.\n       */\n\n      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\n      zero(_length_code);\n      /* length code for each normalized match length (0 == MIN_MATCH) */\n\n      var base_length = new Array(LENGTH_CODES);\n      zero(base_length);\n      /* First normalized length for each code (0 = MIN_MATCH) */\n\n      var base_dist = new Array(D_CODES);\n      zero(base_dist);\n      /* First normalized distance for each code (0 = distance of 1) */\n\n      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n        this.static_tree = static_tree;\n        /* static tree or NULL */\n\n        this.extra_bits = extra_bits;\n        /* extra bits for each code or NULL */\n\n        this.extra_base = extra_base;\n        /* base index for extra_bits */\n\n        this.elems = elems;\n        /* max number of elements in the tree */\n\n        this.max_length = max_length;\n        /* max bit length for the codes */\n        // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n        this.has_stree = static_tree && static_tree.length;\n      }\n\n      var static_l_desc;\n      var static_d_desc;\n      var static_bl_desc;\n\n      function TreeDesc(dyn_tree, stat_desc) {\n        this.dyn_tree = dyn_tree;\n        /* the dynamic tree */\n\n        this.max_code = 0;\n        /* largest code with non zero frequency */\n\n        this.stat_desc = stat_desc;\n        /* the corresponding static tree */\n      }\n\n      function d_code(dist) {\n        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n      }\n      /* ===========================================================================\n       * Output a short LSB first on the stream.\n       * IN assertion: there is enough room in pendingBuf.\n       */\n\n\n      function put_short(s, w) {\n        //    put_byte(s, (uch)((w) & 0xff));\n        //    put_byte(s, (uch)((ush)(w) >> 8));\n        s.pending_buf[s.pending++] = w & 0xff;\n        s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n      }\n      /* ===========================================================================\n       * Send a value on a given number of bits.\n       * IN assertion: length <= 16 and value fits in length bits.\n       */\n\n\n      function send_bits(s, value, length) {\n        if (s.bi_valid > Buf_size - length) {\n          s.bi_buf |= value << s.bi_valid & 0xffff;\n          put_short(s, s.bi_buf);\n          s.bi_buf = value >> Buf_size - s.bi_valid;\n          s.bi_valid += length - Buf_size;\n        } else {\n          s.bi_buf |= value << s.bi_valid & 0xffff;\n          s.bi_valid += length;\n        }\n      }\n\n      function send_code(s, c, tree) {\n        send_bits(s, tree[c * 2]\n        /*.Code*/\n        , tree[c * 2 + 1]\n        /*.Len*/\n        );\n      }\n      /* ===========================================================================\n       * Reverse the first len bits of a code, using straightforward code (a faster\n       * method would use a table)\n       * IN assertion: 1 <= len <= 15\n       */\n\n\n      function bi_reverse(code, len) {\n        var res = 0;\n\n        do {\n          res |= code & 1;\n          code >>>= 1;\n          res <<= 1;\n        } while (--len > 0);\n\n        return res >>> 1;\n      }\n      /* ===========================================================================\n       * Flush the bit buffer, keeping at most 7 bits in it.\n       */\n\n\n      function bi_flush(s) {\n        if (s.bi_valid === 16) {\n          put_short(s, s.bi_buf);\n          s.bi_buf = 0;\n          s.bi_valid = 0;\n        } else if (s.bi_valid >= 8) {\n          s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n          s.bi_buf >>= 8;\n          s.bi_valid -= 8;\n        }\n      }\n      /* ===========================================================================\n       * Compute the optimal bit lengths for a tree and update the total bit length\n       * for the current block.\n       * IN assertion: the fields freq and dad are set, heap[heap_max] and\n       *    above are the tree nodes sorted by increasing frequency.\n       * OUT assertions: the field len is set to the optimal bit length, the\n       *     array bl_count contains the frequencies for each bit length.\n       *     The length opt_len is updated; static_len is also updated if stree is\n       *     not null.\n       */\n\n\n      function gen_bitlen(s, desc) //    deflate_state *s;\n      //    tree_desc *desc;    /* the tree descriptor */\n      {\n        var tree = desc.dyn_tree;\n        var max_code = desc.max_code;\n        var stree = desc.stat_desc.static_tree;\n        var has_stree = desc.stat_desc.has_stree;\n        var extra = desc.stat_desc.extra_bits;\n        var base = desc.stat_desc.extra_base;\n        var max_length = desc.stat_desc.max_length;\n        var h;\n        /* heap index */\n\n        var n, m;\n        /* iterate over the tree elements */\n\n        var bits;\n        /* bit length */\n\n        var xbits;\n        /* extra bits */\n\n        var f;\n        /* frequency */\n\n        var overflow = 0;\n        /* number of elements with bit length too large */\n\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n          s.bl_count[bits] = 0;\n        }\n        /* In a first pass, compute the optimal bit lengths (which may\n         * overflow in the case of the bit length tree).\n         */\n\n\n        tree[s.heap[s.heap_max] * 2 + 1]\n        /*.Len*/\n        = 0;\n        /* root of the heap */\n\n        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n          n = s.heap[h];\n          bits = tree[tree[n * 2 + 1]\n          /*.Dad*/\n          * 2 + 1]\n          /*.Len*/\n          + 1;\n\n          if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n          }\n\n          tree[n * 2 + 1]\n          /*.Len*/\n          = bits;\n          /* We overwrite tree[n].Dad which is no longer needed */\n\n          if (n > max_code) {\n            continue;\n          }\n          /* not a leaf node */\n\n\n          s.bl_count[bits]++;\n          xbits = 0;\n\n          if (n >= base) {\n            xbits = extra[n - base];\n          }\n\n          f = tree[n * 2]\n          /*.Freq*/\n          ;\n          s.opt_len += f * (bits + xbits);\n\n          if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1]\n            /*.Len*/\n            + xbits);\n          }\n        }\n\n        if (overflow === 0) {\n          return;\n        } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n        /* This happens for example on obj2 and pic of the Calgary corpus */\n\n        /* Find the first bit length which could increase: */\n\n\n        do {\n          bits = max_length - 1;\n\n          while (s.bl_count[bits] === 0) {\n            bits--;\n          }\n\n          s.bl_count[bits]--;\n          /* move one leaf down the tree */\n\n          s.bl_count[bits + 1] += 2;\n          /* move one overflow item as its brother */\n\n          s.bl_count[max_length]--;\n          /* The brother of the overflow item also moves one step up,\n           * but this does not affect bl_count[max_length]\n           */\n\n          overflow -= 2;\n        } while (overflow > 0);\n        /* Now recompute all bit lengths, scanning in increasing frequency.\n         * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n         * lengths instead of fixing only the wrong ones. This idea is taken\n         * from 'ar' written by Haruhiko Okumura.)\n         */\n\n\n        for (bits = max_length; bits !== 0; bits--) {\n          n = s.bl_count[bits];\n\n          while (n !== 0) {\n            m = s.heap[--h];\n\n            if (m > max_code) {\n              continue;\n            }\n\n            if (tree[m * 2 + 1]\n            /*.Len*/\n            !== bits) {\n              // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n              s.opt_len += (bits - tree[m * 2 + 1]\n              /*.Len*/\n              ) * tree[m * 2]\n              /*.Freq*/\n              ;\n              tree[m * 2 + 1]\n              /*.Len*/\n              = bits;\n            }\n\n            n--;\n          }\n        }\n      }\n      /* ===========================================================================\n       * Generate the codes for a given tree and bit counts (which need not be\n       * optimal).\n       * IN assertion: the array bl_count contains the bit length statistics for\n       * the given tree and the field len is set for all tree elements.\n       * OUT assertion: the field code is set for all tree elements of non\n       *     zero code length.\n       */\n\n\n      function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n      //    int max_code;              /* largest code with non zero frequency */\n      //    ushf *bl_count;            /* number of codes at each bit length */\n      {\n        var next_code = new Array(MAX_BITS + 1);\n        /* next code value for each bit length */\n\n        var code = 0;\n        /* running code value */\n\n        var bits;\n        /* bit index */\n\n        var n;\n        /* code index */\n\n        /* The distribution counts are first used to generate the code values\n         * without bit reversal.\n         */\n\n        for (bits = 1; bits <= MAX_BITS; bits++) {\n          next_code[bits] = code = code + bl_count[bits - 1] << 1;\n        }\n        /* Check that the bit counts in bl_count are consistent. The last code\n         * must be all ones.\n         */\n        //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n        //        \"inconsistent bit counts\");\n        //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n\n        for (n = 0; n <= max_code; n++) {\n          var len = tree[n * 2 + 1]\n          /*.Len*/\n          ;\n\n          if (len === 0) {\n            continue;\n          }\n          /* Now reverse the bits */\n\n\n          tree[n * 2]\n          /*.Code*/\n          = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n          //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n        }\n      }\n      /* ===========================================================================\n       * Initialize the various 'constant' tables.\n       */\n\n\n      function tr_static_init() {\n        var n;\n        /* iterates over tree elements */\n\n        var bits;\n        /* bit counter */\n\n        var length;\n        /* length value */\n\n        var code;\n        /* code value */\n\n        var dist;\n        /* distance index */\n\n        var bl_count = new Array(MAX_BITS + 1);\n        /* number of codes at each bit length for an optimal tree */\n        // do check in _tr_init()\n        //if (static_init_done) return;\n\n        /* For some embedded targets, global variables are not initialized: */\n\n        /*#ifdef NO_INIT_GLOBAL_POINTERS\n          static_l_desc.static_tree = static_ltree;\n          static_l_desc.extra_bits = extra_lbits;\n          static_d_desc.static_tree = static_dtree;\n          static_d_desc.extra_bits = extra_dbits;\n          static_bl_desc.extra_bits = extra_blbits;\n        #endif*/\n\n        /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n        length = 0;\n\n        for (code = 0; code < LENGTH_CODES - 1; code++) {\n          base_length[code] = length;\n\n          for (n = 0; n < 1 << extra_lbits[code]; n++) {\n            _length_code[length++] = code;\n          }\n        } //Assert (length == 256, \"tr_static_init: length != 256\");\n\n        /* Note that the length 255 (match length 258) can be represented\n         * in two different ways: code 284 + 5 bits or code 285, so we\n         * overwrite length_code[255] to use the best encoding:\n         */\n\n\n        _length_code[length - 1] = code;\n        /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n        dist = 0;\n\n        for (code = 0; code < 16; code++) {\n          base_dist[code] = dist;\n\n          for (n = 0; n < 1 << extra_dbits[code]; n++) {\n            _dist_code[dist++] = code;\n          }\n        } //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n\n        dist >>= 7;\n        /* from now on, all distances are divided by 128 */\n\n        for (; code < D_CODES; code++) {\n          base_dist[code] = dist << 7;\n\n          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n            _dist_code[256 + dist++] = code;\n          }\n        } //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n        /* Construct the codes of the static literal tree */\n\n\n        for (bits = 0; bits <= MAX_BITS; bits++) {\n          bl_count[bits] = 0;\n        }\n\n        n = 0;\n\n        while (n <= 143) {\n          static_ltree[n * 2 + 1]\n          /*.Len*/\n          = 8;\n          n++;\n          bl_count[8]++;\n        }\n\n        while (n <= 255) {\n          static_ltree[n * 2 + 1]\n          /*.Len*/\n          = 9;\n          n++;\n          bl_count[9]++;\n        }\n\n        while (n <= 279) {\n          static_ltree[n * 2 + 1]\n          /*.Len*/\n          = 7;\n          n++;\n          bl_count[7]++;\n        }\n\n        while (n <= 287) {\n          static_ltree[n * 2 + 1]\n          /*.Len*/\n          = 8;\n          n++;\n          bl_count[8]++;\n        }\n        /* Codes 286 and 287 do not exist, but we must include them in the\n         * tree construction to get a canonical Huffman tree (longest code\n         * all ones)\n         */\n\n\n        gen_codes(static_ltree, L_CODES + 1, bl_count);\n        /* The static distance tree is trivial: */\n\n        for (n = 0; n < D_CODES; n++) {\n          static_dtree[n * 2 + 1]\n          /*.Len*/\n          = 5;\n          static_dtree[n * 2]\n          /*.Code*/\n          = bi_reverse(n, 5);\n        } // Now data ready and we can init static trees\n\n\n        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;\n      }\n      /* ===========================================================================\n       * Initialize a new block.\n       */\n\n\n      function init_block(s) {\n        var n;\n        /* iterates over tree elements */\n\n        /* Initialize the trees. */\n\n        for (n = 0; n < L_CODES; n++) {\n          s.dyn_ltree[n * 2]\n          /*.Freq*/\n          = 0;\n        }\n\n        for (n = 0; n < D_CODES; n++) {\n          s.dyn_dtree[n * 2]\n          /*.Freq*/\n          = 0;\n        }\n\n        for (n = 0; n < BL_CODES; n++) {\n          s.bl_tree[n * 2]\n          /*.Freq*/\n          = 0;\n        }\n\n        s.dyn_ltree[END_BLOCK * 2]\n        /*.Freq*/\n        = 1;\n        s.opt_len = s.static_len = 0;\n        s.last_lit = s.matches = 0;\n      }\n      /* ===========================================================================\n       * Flush the bit buffer and align the output on a byte boundary\n       */\n\n\n      function bi_windup(s) {\n        if (s.bi_valid > 8) {\n          put_short(s, s.bi_buf);\n        } else if (s.bi_valid > 0) {\n          //put_byte(s, (Byte)s->bi_buf);\n          s.pending_buf[s.pending++] = s.bi_buf;\n        }\n\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n      }\n      /* ===========================================================================\n       * Copy a stored block, storing first the length and its\n       * one's complement if requested.\n       */\n\n\n      function copy_block(s, buf, len, header) //DeflateState *s;\n      //charf    *buf;    /* the input data */\n      //unsigned len;     /* its length */\n      //int      header;  /* true if block header must be written */\n      {\n        bi_windup(s);\n        /* align on byte boundary */\n\n        if (header) {\n          put_short(s, len);\n          put_short(s, ~len);\n        } //  while (len--) {\n        //    put_byte(s, *buf++);\n        //  }\n\n\n        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n        s.pending += len;\n      }\n      /* ===========================================================================\n       * Compares to subtrees, using the tree depth as tie breaker when\n       * the subtrees have equal frequency. This minimizes the worst case length.\n       */\n\n\n      function smaller(tree, n, m, depth) {\n        var _n2 = n * 2;\n\n        var _m2 = m * 2;\n\n        return tree[_n2]\n        /*.Freq*/\n        < tree[_m2]\n        /*.Freq*/\n        || tree[_n2]\n        /*.Freq*/\n        === tree[_m2]\n        /*.Freq*/\n        && depth[n] <= depth[m];\n      }\n      /* ===========================================================================\n       * Restore the heap property by moving down the tree starting at node k,\n       * exchanging a node with the smallest of its two sons if necessary, stopping\n       * when the heap property is re-established (each father smaller than its\n       * two sons).\n       */\n\n\n      function pqdownheap(s, tree, k) //    deflate_state *s;\n      //    ct_data *tree;  /* the tree to restore */\n      //    int k;               /* node to move down */\n      {\n        var v = s.heap[k];\n        var j = k << 1;\n        /* left son of k */\n\n        while (j <= s.heap_len) {\n          /* Set j to the smallest of the two sons: */\n          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n          }\n          /* Exit if v is smaller than both sons */\n\n\n          if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n          }\n          /* Exchange v with the smallest son */\n\n\n          s.heap[k] = s.heap[j];\n          k = j;\n          /* And continue down the tree, setting j to the left son of k */\n\n          j <<= 1;\n        }\n\n        s.heap[k] = v;\n      } // inlined manually\n      // var SMALLEST = 1;\n\n      /* ===========================================================================\n       * Send the block data compressed using the given Huffman trees\n       */\n\n\n      function compress_block(s, ltree, dtree) //    deflate_state *s;\n      //    const ct_data *ltree; /* literal tree */\n      //    const ct_data *dtree; /* distance tree */\n      {\n        var dist;\n        /* distance of matched string */\n\n        var lc;\n        /* match length or unmatched char (if dist == 0) */\n\n        var lx = 0;\n        /* running index in l_buf */\n\n        var code;\n        /* the code to send */\n\n        var extra;\n        /* number of extra bits to send */\n\n        if (s.last_lit !== 0) {\n          do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n\n            if (dist === 0) {\n              send_code(s, lc, ltree);\n              /* send a literal byte */\n              //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n              /* Here, lc is the match length - MIN_MATCH */\n              code = _length_code[lc];\n              send_code(s, code + LITERALS + 1, ltree);\n              /* send the length code */\n\n              extra = extra_lbits[code];\n\n              if (extra !== 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra);\n                /* send the extra length bits */\n              }\n\n              dist--;\n              /* dist is now the match distance - 1 */\n\n              code = d_code(dist); //Assert (code < D_CODES, \"bad d_code\");\n\n              send_code(s, code, dtree);\n              /* send the distance code */\n\n              extra = extra_dbits[code];\n\n              if (extra !== 0) {\n                dist -= base_dist[code];\n                send_bits(s, dist, extra);\n                /* send the extra distance bits */\n              }\n            }\n            /* literal or match pair ? */\n\n            /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n            //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n            //       \"pendingBuf overflow\");\n\n          } while (lx < s.last_lit);\n        }\n\n        send_code(s, END_BLOCK, ltree);\n      }\n      /* ===========================================================================\n       * Construct one Huffman tree and assigns the code bit strings and lengths.\n       * Update the total bit length for the current block.\n       * IN assertion: the field freq is set for all tree elements.\n       * OUT assertions: the fields len and code are set to the optimal bit length\n       *     and corresponding code. The length opt_len is updated; static_len is\n       *     also updated if stree is not null. The field max_code is set.\n       */\n\n\n      function build_tree(s, desc) //    deflate_state *s;\n      //    tree_desc *desc; /* the tree descriptor */\n      {\n        var tree = desc.dyn_tree;\n        var stree = desc.stat_desc.static_tree;\n        var has_stree = desc.stat_desc.has_stree;\n        var elems = desc.stat_desc.elems;\n        var n, m;\n        /* iterate over heap elements */\n\n        var max_code = -1;\n        /* largest code with non zero frequency */\n\n        var node;\n        /* new node being created */\n\n        /* Construct the initial heap, with least frequent element in\n         * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n         * heap[0] is not used.\n         */\n\n        s.heap_len = 0;\n        s.heap_max = HEAP_SIZE;\n\n        for (n = 0; n < elems; n++) {\n          if (tree[n * 2]\n          /*.Freq*/\n          !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n          } else {\n            tree[n * 2 + 1]\n            /*.Len*/\n            = 0;\n          }\n        }\n        /* The pkzip format requires that at least one distance code exists,\n         * and that at least one bit should be sent even if there is only one\n         * possible code. So to avoid special checks later on we force at least\n         * two codes of non zero frequency.\n         */\n\n\n        while (s.heap_len < 2) {\n          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n          tree[node * 2]\n          /*.Freq*/\n          = 1;\n          s.depth[node] = 0;\n          s.opt_len--;\n\n          if (has_stree) {\n            s.static_len -= stree[node * 2 + 1]\n            /*.Len*/\n            ;\n          }\n          /* node is 0 or 1 so it does not have extra bits */\n\n        }\n\n        desc.max_code = max_code;\n        /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n         * establish sub-heaps of increasing lengths:\n         */\n\n        for (n = s.heap_len >> 1\n        /*int /2*/\n        ; n >= 1; n--) {\n          pqdownheap(s, tree, n);\n        }\n        /* Construct the Huffman tree by repeatedly combining the least two\n         * frequent nodes.\n         */\n\n\n        node = elems;\n        /* next internal node of the tree */\n\n        do {\n          //pqremove(s, tree, n);  /* n = node of least frequency */\n\n          /*** pqremove ***/\n          n = s.heap[1\n          /*SMALLEST*/\n          ];\n          s.heap[1\n          /*SMALLEST*/\n          ] = s.heap[s.heap_len--];\n          pqdownheap(s, tree, 1\n          /*SMALLEST*/\n          );\n          /***/\n\n          m = s.heap[1\n          /*SMALLEST*/\n          ];\n          /* m = node of next least frequency */\n\n          s.heap[--s.heap_max] = n;\n          /* keep the nodes sorted by frequency */\n\n          s.heap[--s.heap_max] = m;\n          /* Create a new node father of n and m */\n\n          tree[node * 2]\n          /*.Freq*/\n          = tree[n * 2]\n          /*.Freq*/\n          + tree[m * 2]\n          /*.Freq*/\n          ;\n          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n          tree[n * 2 + 1]\n          /*.Dad*/\n          = tree[m * 2 + 1]\n          /*.Dad*/\n          = node;\n          /* and insert the new node in the heap */\n\n          s.heap[1\n          /*SMALLEST*/\n          ] = node++;\n          pqdownheap(s, tree, 1\n          /*SMALLEST*/\n          );\n        } while (s.heap_len >= 2);\n\n        s.heap[--s.heap_max] = s.heap[1\n        /*SMALLEST*/\n        ];\n        /* At this point, the fields freq and dad are set. We can now\n         * generate the bit lengths.\n         */\n\n        gen_bitlen(s, desc);\n        /* The field len is now set, we can generate the bit codes */\n\n        gen_codes(tree, max_code, s.bl_count);\n      }\n      /* ===========================================================================\n       * Scan a literal or distance tree to determine the frequencies of the codes\n       * in the bit length tree.\n       */\n\n\n      function scan_tree(s, tree, max_code) //    deflate_state *s;\n      //    ct_data *tree;   /* the tree to be scanned */\n      //    int max_code;    /* and its largest code of non zero frequency */\n      {\n        var n;\n        /* iterates over all tree elements */\n\n        var prevlen = -1;\n        /* last emitted length */\n\n        var curlen;\n        /* length of current code */\n\n        var nextlen = tree[0 * 2 + 1]\n        /*.Len*/\n        ;\n        /* length of next code */\n\n        var count = 0;\n        /* repeat count of the current code */\n\n        var max_count = 7;\n        /* max repeat count */\n\n        var min_count = 4;\n        /* min repeat count */\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        }\n\n        tree[(max_code + 1) * 2 + 1]\n        /*.Len*/\n        = 0xffff;\n        /* guard */\n\n        for (n = 0; n <= max_code; n++) {\n          curlen = nextlen;\n          nextlen = tree[(n + 1) * 2 + 1]\n          /*.Len*/\n          ;\n\n          if (++count < max_count && curlen === nextlen) {\n            continue;\n          } else if (count < min_count) {\n            s.bl_tree[curlen * 2]\n            /*.Freq*/\n            += count;\n          } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n              s.bl_tree[curlen * 2] /*.Freq*/++;\n            }\n\n            s.bl_tree[REP_3_6 * 2] /*.Freq*/++;\n          } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;\n          } else {\n            s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;\n          }\n\n          count = 0;\n          prevlen = curlen;\n\n          if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n          } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n          } else {\n            max_count = 7;\n            min_count = 4;\n          }\n        }\n      }\n      /* ===========================================================================\n       * Send a literal or distance tree in compressed form, using the codes in\n       * bl_tree.\n       */\n\n\n      function send_tree(s, tree, max_code) //    deflate_state *s;\n      //    ct_data *tree; /* the tree to be scanned */\n      //    int max_code;       /* and its largest code of non zero frequency */\n      {\n        var n;\n        /* iterates over all tree elements */\n\n        var prevlen = -1;\n        /* last emitted length */\n\n        var curlen;\n        /* length of current code */\n\n        var nextlen = tree[0 * 2 + 1]\n        /*.Len*/\n        ;\n        /* length of next code */\n\n        var count = 0;\n        /* repeat count of the current code */\n\n        var max_count = 7;\n        /* max repeat count */\n\n        var min_count = 4;\n        /* min repeat count */\n\n        /* tree[max_code+1].Len = -1; */\n\n        /* guard already set */\n\n        if (nextlen === 0) {\n          max_count = 138;\n          min_count = 3;\n        }\n\n        for (n = 0; n <= max_code; n++) {\n          curlen = nextlen;\n          nextlen = tree[(n + 1) * 2 + 1]\n          /*.Len*/\n          ;\n\n          if (++count < max_count && curlen === nextlen) {\n            continue;\n          } else if (count < min_count) {\n            do {\n              send_code(s, curlen, s.bl_tree);\n            } while (--count !== 0);\n          } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n              send_code(s, curlen, s.bl_tree);\n              count--;\n            } //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n          } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n          } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n          }\n\n          count = 0;\n          prevlen = curlen;\n\n          if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n          } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n          } else {\n            max_count = 7;\n            min_count = 4;\n          }\n        }\n      }\n      /* ===========================================================================\n       * Construct the Huffman tree for the bit lengths and return the index in\n       * bl_order of the last bit length code to send.\n       */\n\n\n      function build_bl_tree(s) {\n        var max_blindex;\n        /* index of last bit length code of non zero freq */\n\n        /* Determine the bit length frequencies for literal and distance trees */\n\n        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n        /* Build the bit length tree: */\n\n        build_tree(s, s.bl_desc);\n        /* opt_len now includes the length of the tree representations, except\n         * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n         */\n\n        /* Determine the number of bit length codes to send. The pkzip format\n         * requires that at least 4 bit length codes be sent. (appnote.txt says\n         * 3 but the actual value used is 4.)\n         */\n\n        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n          if (s.bl_tree[bl_order[max_blindex] * 2 + 1]\n          /*.Len*/\n          !== 0) {\n            break;\n          }\n        }\n        /* Update opt_len to include the bit length tree and counts */\n\n\n        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n        //        s->opt_len, s->static_len));\n\n        return max_blindex;\n      }\n      /* ===========================================================================\n       * Send the header for a block using dynamic Huffman trees: the counts, the\n       * lengths of the bit length codes, the literal tree and the distance tree.\n       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n       */\n\n\n      function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n      //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n      {\n        var rank;\n        /* index in bl_order */\n        //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n        //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n        //        \"too many codes\");\n        //Tracev((stderr, \"\\nbl counts: \"));\n\n        send_bits(s, lcodes - 257, 5);\n        /* not +255 as stated in appnote.txt */\n\n        send_bits(s, dcodes - 1, 5);\n        send_bits(s, blcodes - 4, 4);\n        /* not -3 as stated in appnote.txt */\n\n        for (rank = 0; rank < blcodes; rank++) {\n          //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]\n          /*.Len*/\n          , 3);\n        } //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n\n        send_tree(s, s.dyn_ltree, lcodes - 1);\n        /* literal tree */\n        //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n        send_tree(s, s.dyn_dtree, dcodes - 1);\n        /* distance tree */\n        //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n      }\n      /* ===========================================================================\n       * Check if the data type is TEXT or BINARY, using the following algorithm:\n       * - TEXT if the two conditions below are satisfied:\n       *    a) There are no non-portable control characters belonging to the\n       *       \"black list\" (0..6, 14..25, 28..31).\n       *    b) There is at least one printable character belonging to the\n       *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n       * - BINARY otherwise.\n       * - The following partially-portable control characters form a\n       *   \"gray list\" that is ignored in this detection algorithm:\n       *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n       * IN assertion: the fields Freq of dyn_ltree are set.\n       */\n\n\n      function detect_data_type(s) {\n        /* black_mask is the bit mask of black-listed bytes\n         * set bits 0..6, 14..25, and 28..31\n         * 0xf3ffc07f = binary 11110011111111111100000001111111\n         */\n        var black_mask = 0xf3ffc07f;\n        var n;\n        /* Check for non-textual (\"black-listed\") bytes. */\n\n        for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n          if (black_mask & 1 && s.dyn_ltree[n * 2]\n          /*.Freq*/\n          !== 0) {\n            return Z_BINARY;\n          }\n        }\n        /* Check for textual (\"white-listed\") bytes. */\n\n\n        if (s.dyn_ltree[9 * 2]\n        /*.Freq*/\n        !== 0 || s.dyn_ltree[10 * 2]\n        /*.Freq*/\n        !== 0 || s.dyn_ltree[13 * 2]\n        /*.Freq*/\n        !== 0) {\n          return Z_TEXT;\n        }\n\n        for (n = 32; n < LITERALS; n++) {\n          if (s.dyn_ltree[n * 2]\n          /*.Freq*/\n          !== 0) {\n            return Z_TEXT;\n          }\n        }\n        /* There are no \"black-listed\" or \"white-listed\" bytes:\n         * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n         */\n\n\n        return Z_BINARY;\n      }\n\n      var static_init_done = false;\n      /* ===========================================================================\n       * Initialize the tree data structures for a new zlib stream.\n       */\n\n      function _tr_init(s) {\n        if (!static_init_done) {\n          tr_static_init();\n          static_init_done = true;\n        }\n\n        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n        /* Initialize the first block of the first file: */\n\n        init_block(s);\n      }\n      /* ===========================================================================\n       * Send a stored block\n       */\n\n\n      function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n      //charf *buf;       /* input block */\n      //ulg stored_len;   /* length of input block */\n      //int last;         /* one if this is the last block for a file */\n      {\n        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n        /* send block type */\n\n        copy_block(s, buf, stored_len, true);\n        /* with header */\n      }\n      /* ===========================================================================\n       * Send one empty static block to give enough lookahead for inflate.\n       * This takes 10 bits, of which 7 may remain in the bit buffer.\n       */\n\n\n      function _tr_align(s) {\n        send_bits(s, STATIC_TREES << 1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n        bi_flush(s);\n      }\n      /* ===========================================================================\n       * Determine the best encoding for the current block: dynamic trees, static\n       * trees or store, and output the encoded block to the zip file.\n       */\n\n\n      function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n      //charf *buf;       /* input block, or NULL if too old */\n      //ulg stored_len;   /* length of input block */\n      //int last;         /* one if this is the last block for a file */\n      {\n        var opt_lenb, static_lenb;\n        /* opt_len and static_len in bytes */\n\n        var max_blindex = 0;\n        /* index of last bit length code of non zero freq */\n\n        /* Build the Huffman trees unless a stored block is forced */\n\n        if (s.level > 0) {\n          /* Check if the file is binary or text */\n          if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n          }\n          /* Construct the literal and distance trees */\n\n\n          build_tree(s, s.l_desc); // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n          //        s->static_len));\n\n          build_tree(s, s.d_desc); // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n          //        s->static_len));\n\n          /* At this point, opt_len and static_len are the total bit lengths of\n           * the compressed block data, excluding the tree representations.\n           */\n\n          /* Build the bit length tree for the above two trees, and get the index\n           * in bl_order of the last bit length code to send.\n           */\n\n          max_blindex = build_bl_tree(s);\n          /* Determine the best encoding. Compute the block lengths in bytes. */\n\n          opt_lenb = s.opt_len + 3 + 7 >>> 3;\n          static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n          //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n          //        s->last_lit));\n\n          if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n          }\n        } else {\n          // Assert(buf != (char*)0, \"lost buf\");\n          opt_lenb = static_lenb = stored_len + 5;\n          /* force a stored block */\n        }\n\n        if (stored_len + 4 <= opt_lenb && buf !== -1) {\n          /* 4: two words for the lengths */\n\n          /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n           * Otherwise we can't have processed more than WSIZE input bytes since\n           * the last block flush, because compression would have been\n           * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n           * transform a block into a stored block.\n           */\n          _tr_stored_block(s, buf, stored_len, last);\n        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n          compress_block(s, static_ltree, static_dtree);\n        } else {\n          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n          compress_block(s, s.dyn_ltree, s.dyn_dtree);\n        } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n        /* The above check is made mod 2^32, for files larger than 512 MB\n         * and uLong implemented on 32 bits.\n         */\n\n\n        init_block(s);\n\n        if (last) {\n          bi_windup(s);\n        } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n        //       s->compressed_len-7*last));\n\n      }\n      /* ===========================================================================\n       * Save the match info and tally the frequency counts. Return true if\n       * the current block must be flushed.\n       */\n\n\n      function _tr_tally(s, dist, lc) //    deflate_state *s;\n      //    unsigned dist;  /* distance of matched string */\n      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n      {\n        //var out_length, in_length, dcode;\n        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n        s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n        s.last_lit++;\n\n        if (dist === 0) {\n          /* lc is the unmatched char */\n          s.dyn_ltree[lc * 2] /*.Freq*/++;\n        } else {\n          s.matches++;\n          /* Here, lc is the match length - MIN_MATCH */\n\n          dist--;\n          /* dist = match distance - 1 */\n          //Assert((ush)dist < (ush)MAX_DIST(s) &&\n          //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n          //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;\n          s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;\n        } // (!) This block is disabled in zlib defaults,\n        // don't enable it for binary compatibility\n        //#ifdef TRUNCATE_BLOCK\n        //  /* Try to guess if it is profitable to stop the current block here */\n        //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n        //    /* Compute an upper bound for the compressed length */\n        //    out_length = s.last_lit*8;\n        //    in_length = s.strstart - s.block_start;\n        //\n        //    for (dcode = 0; dcode < D_CODES; dcode++) {\n        //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n        //    }\n        //    out_length >>>= 3;\n        //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n        //    //       s->last_lit, in_length, out_length,\n        //    //       100L - out_length*100L/in_length));\n        //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n        //      return true;\n        //    }\n        //  }\n        //#endif\n\n\n        return s.last_lit === s.lit_bufsize - 1;\n        /* We avoid equality with lit_bufsize because of wraparound at 64K\n         * on 16 bit machines and because stored blocks are restricted to\n         * 64K-1 bytes.\n         */\n      }\n\n      exports._tr_init = _tr_init;\n      exports._tr_stored_block = _tr_stored_block;\n      exports._tr_flush_block = _tr_flush_block;\n      exports._tr_tally = _tr_tally;\n      exports._tr_align = _tr_align;\n    }, {\n      \"../utils/common\": 1\n    }],\n    8: [function (require, module, exports) {\n      'use strict'; // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n      // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n      //\n      // This software is provided 'as-is', without any express or implied\n      // warranty. In no event will the authors be held liable for any damages\n      // arising from the use of this software.\n      //\n      // Permission is granted to anyone to use this software for any purpose,\n      // including commercial applications, and to alter it and redistribute it\n      // freely, subject to the following restrictions:\n      //\n      // 1. The origin of this software must not be misrepresented; you must not\n      //   claim that you wrote the original software. If you use this software\n      //   in a product, an acknowledgment in the product documentation would be\n      //   appreciated but is not required.\n      // 2. Altered source versions must be plainly marked as such, and must not be\n      //   misrepresented as being the original software.\n      // 3. This notice may not be removed or altered from any source distribution.\n\n      function ZStream() {\n        /* next input byte */\n        this.input = null; // JS specific, because we have no pointers\n\n        this.next_in = 0;\n        /* number of bytes available at input */\n\n        this.avail_in = 0;\n        /* total number of input bytes read so far */\n\n        this.total_in = 0;\n        /* next output byte should be put there */\n\n        this.output = null; // JS specific, because we have no pointers\n\n        this.next_out = 0;\n        /* remaining free space at output */\n\n        this.avail_out = 0;\n        /* total number of bytes output so far */\n\n        this.total_out = 0;\n        /* last error message, NULL if no error */\n\n        this.msg = ''\n        /*Z_NULL*/\n        ;\n        /* not visible by applications */\n\n        this.state = null;\n        /* best guess about the data type: binary or text */\n\n        this.data_type = 2\n        /*Z_UNKNOWN*/\n        ;\n        /* adler32 value of the uncompressed data */\n\n        this.adler = 0;\n      }\n\n      module.exports = ZStream;\n    }, {}],\n    \"/lib/deflate.js\": [function (require, module, exports) {\n      'use strict';\n\n      var zlib_deflate = require('./zlib/deflate');\n\n      var utils = require('./utils/common');\n\n      var strings = require('./utils/strings');\n\n      var msg = require('./zlib/messages');\n\n      var ZStream = require('./zlib/zstream');\n\n      var toString = Object.prototype.toString;\n      /* Public constants ==========================================================*/\n\n      /* ===========================================================================*/\n\n      var Z_NO_FLUSH = 0;\n      var Z_FINISH = 4;\n      var Z_OK = 0;\n      var Z_STREAM_END = 1;\n      var Z_SYNC_FLUSH = 2;\n      var Z_DEFAULT_COMPRESSION = -1;\n      var Z_DEFAULT_STRATEGY = 0;\n      var Z_DEFLATED = 8;\n      /* ===========================================================================*/\n\n      /**\n       * class Deflate\n       *\n       * Generic JS-style wrapper for zlib calls. If you don't need\n       * streaming behaviour - use more simple functions: [[deflate]],\n       * [[deflateRaw]] and [[gzip]].\n       **/\n\n      /* internal\n       * Deflate.chunks -> Array\n       *\n       * Chunks of output data, if [[Deflate#onData]] not overridden.\n       **/\n\n      /**\n       * Deflate.result -> Uint8Array|Array\n       *\n       * Compressed result, generated by default [[Deflate#onData]]\n       * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n       * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n       * push a chunk with explicit flush (call [[Deflate#push]] with\n       * `Z_SYNC_FLUSH` param).\n       **/\n\n      /**\n       * Deflate.err -> Number\n       *\n       * Error code after deflate finished. 0 (Z_OK) on success.\n       * You will not need it in real life, because deflate errors\n       * are possible only on wrong options or bad `onData` / `onEnd`\n       * custom handlers.\n       **/\n\n      /**\n       * Deflate.msg -> String\n       *\n       * Error message, if [[Deflate.err]] != 0\n       **/\n\n      /**\n       * new Deflate(options)\n       * - options (Object): zlib deflate options.\n       *\n       * Creates new deflator instance with specified params. Throws exception\n       * on bad params. Supported options:\n       *\n       * - `level`\n       * - `windowBits`\n       * - `memLevel`\n       * - `strategy`\n       * - `dictionary`\n       *\n       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n       * for more information on these.\n       *\n       * Additional options, for internal needs:\n       *\n       * - `chunkSize` - size of generated data chunks (16K by default)\n       * - `raw` (Boolean) - do raw deflate\n       * - `gzip` (Boolean) - create gzip wrapper\n       * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n       *    (each char code [0..255])\n       * - `header` (Object) - custom header for gzip\n       *   - `text` (Boolean) - true if compressed data believed to be text\n       *   - `time` (Number) - modification time, unix timestamp\n       *   - `os` (Number) - operation system code\n       *   - `extra` (Array) - array of bytes with extra data (max 65536)\n       *   - `name` (String) - file name (binary string)\n       *   - `comment` (String) - comment (binary string)\n       *   - `hcrc` (Boolean) - true if header crc should be added\n       *\n       * ##### Example:\n       *\n       * ```javascript\n       * var pako = require('pako')\n       *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n       *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n       *\n       * var deflate = new pako.Deflate({ level: 3});\n       *\n       * deflate.push(chunk1, false);\n       * deflate.push(chunk2, true);  // true -> last chunk\n       *\n       * if (deflate.err) { throw new Error(deflate.err); }\n       *\n       * console.log(deflate.result);\n       * ```\n       **/\n\n      function Deflate(options) {\n        if (!(this instanceof Deflate)) return new Deflate(options);\n        this.options = utils.assign({\n          level: Z_DEFAULT_COMPRESSION,\n          method: Z_DEFLATED,\n          chunkSize: 16384,\n          windowBits: 15,\n          memLevel: 8,\n          strategy: Z_DEFAULT_STRATEGY,\n          to: ''\n        }, options || {});\n        var opt = this.options;\n\n        if (opt.raw && opt.windowBits > 0) {\n          opt.windowBits = -opt.windowBits;\n        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n          opt.windowBits += 16;\n        }\n\n        this.err = 0; // error code, if happens (0 = Z_OK)\n\n        this.msg = ''; // error message\n\n        this.ended = false; // used to avoid multiple onEnd() calls\n\n        this.chunks = []; // chunks of compressed data\n\n        this.strm = new ZStream();\n        this.strm.avail_out = 0;\n        var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\n        if (status !== Z_OK) {\n          throw new Error(msg[status]);\n        }\n\n        if (opt.header) {\n          zlib_deflate.deflateSetHeader(this.strm, opt.header);\n        }\n\n        if (opt.dictionary) {\n          var dict; // Convert data if needed\n\n          if (typeof opt.dictionary === 'string') {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n          } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n            dict = new Uint8Array(opt.dictionary);\n          } else {\n            dict = opt.dictionary;\n          }\n\n          status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n          if (status !== Z_OK) {\n            throw new Error(msg[status]);\n          }\n\n          this._dict_set = true;\n        }\n      }\n      /**\n       * Deflate#push(data[, mode]) -> Boolean\n       * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n       *   converted to utf8 byte sequence.\n       * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n       *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n       *\n       * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n       * new compressed chunks. Returns `true` on success. The last data block must have\n       * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n       * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n       * can use mode Z_SYNC_FLUSH, keeping the compression context.\n       *\n       * On fail call [[Deflate#onEnd]] with error code and return false.\n       *\n       * We strongly recommend to use `Uint8Array` on input for best speed (output\n       * array format is detected automatically). Also, don't skip last param and always\n       * use the same type in your code (boolean or number). That will improve JS speed.\n       *\n       * For regular `Array`-s make sure all elements are [0..255].\n       *\n       * ##### Example\n       *\n       * ```javascript\n       * push(chunk, false); // push one of data chunks\n       * ...\n       * push(chunk, true);  // push last chunk\n       * ```\n       **/\n\n\n      Deflate.prototype.push = function (data, mode) {\n        var strm = this.strm;\n        var chunkSize = this.options.chunkSize;\n\n        var status, _mode;\n\n        if (this.ended) {\n          return false;\n        }\n\n        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH; // Convert data if needed\n\n        if (typeof data === 'string') {\n          // If we need to compress text, change encoding to utf8.\n          strm.input = strings.string2buf(data);\n        } else if (toString.call(data) === '[object ArrayBuffer]') {\n          strm.input = new Uint8Array(data);\n        } else {\n          strm.input = data;\n        }\n\n        strm.next_in = 0;\n        strm.avail_in = strm.input.length;\n\n        do {\n          if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n          }\n\n          status = zlib_deflate.deflate(strm, _mode);\n          /* no bad return value */\n\n          if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n          }\n\n          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === 'string') {\n              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n              this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n          }\n        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END); // Finalize on the last chunk.\n\n\n        if (_mode === Z_FINISH) {\n          status = zlib_deflate.deflateEnd(this.strm);\n          this.onEnd(status);\n          this.ended = true;\n          return status === Z_OK;\n        } // callback interim results if Z_SYNC_FLUSH.\n\n\n        if (_mode === Z_SYNC_FLUSH) {\n          this.onEnd(Z_OK);\n          strm.avail_out = 0;\n          return true;\n        }\n\n        return true;\n      };\n      /**\n       * Deflate#onData(chunk) -> Void\n       * - chunk (Uint8Array|Array|String): output data. Type of array depends\n       *   on js engine support. When string output requested, each chunk\n       *   will be string.\n       *\n       * By default, stores data blocks in `chunks[]` property and glue\n       * those in `onEnd`. Override this handler, if you need another behaviour.\n       **/\n\n\n      Deflate.prototype.onData = function (chunk) {\n        this.chunks.push(chunk);\n      };\n      /**\n       * Deflate#onEnd(status) -> Void\n       * - status (Number): deflate status. 0 (Z_OK) on success,\n       *   other if not.\n       *\n       * Called once after you tell deflate that the input stream is\n       * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n       * or if an error happened. By default - join collected chunks,\n       * free memory and fill `results` / `err` properties.\n       **/\n\n\n      Deflate.prototype.onEnd = function (status) {\n        // On success - join\n        if (status === Z_OK) {\n          if (this.options.to === 'string') {\n            this.result = this.chunks.join('');\n          } else {\n            this.result = utils.flattenChunks(this.chunks);\n          }\n        }\n\n        this.chunks = [];\n        this.err = status;\n        this.msg = this.strm.msg;\n      };\n      /**\n       * deflate(data[, options]) -> Uint8Array|Array|String\n       * - data (Uint8Array|Array|String): input data to compress.\n       * - options (Object): zlib deflate options.\n       *\n       * Compress `data` with deflate algorithm and `options`.\n       *\n       * Supported options are:\n       *\n       * - level\n       * - windowBits\n       * - memLevel\n       * - strategy\n       * - dictionary\n       *\n       * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n       * for more information on these.\n       *\n       * Sugar (options):\n       *\n       * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n       *   negative windowBits implicitly.\n       * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n       *    (each char code [0..255])\n       *\n       * ##### Example:\n       *\n       * ```javascript\n       * var pako = require('pako')\n       *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n       *\n       * console.log(pako.deflate(data));\n       * ```\n       **/\n\n\n      function deflate(input, options) {\n        var deflator = new Deflate(options);\n        deflator.push(input, true); // That will never happens, if you don't cheat with options :)\n\n        if (deflator.err) {\n          throw deflator.msg || msg[deflator.err];\n        }\n\n        return deflator.result;\n      }\n      /**\n       * deflateRaw(data[, options]) -> Uint8Array|Array|String\n       * - data (Uint8Array|Array|String): input data to compress.\n       * - options (Object): zlib deflate options.\n       *\n       * The same as [[deflate]], but creates raw data, without wrapper\n       * (header and adler32 crc).\n       **/\n\n\n      function deflateRaw(input, options) {\n        options = options || {};\n        options.raw = true;\n        return deflate(input, options);\n      }\n      /**\n       * gzip(data[, options]) -> Uint8Array|Array|String\n       * - data (Uint8Array|Array|String): input data to compress.\n       * - options (Object): zlib deflate options.\n       *\n       * The same as [[deflate]], but create gzip wrapper instead of\n       * deflate one.\n       **/\n\n\n      function gzip(input, options) {\n        options = options || {};\n        options.gzip = true;\n        return deflate(input, options);\n      }\n\n      exports.Deflate = Deflate;\n      exports.deflate = deflate;\n      exports.deflateRaw = deflateRaw;\n      exports.gzip = gzip;\n    }, {\n      \"./utils/common\": 1,\n      \"./utils/strings\": 2,\n      \"./zlib/deflate\": 5,\n      \"./zlib/messages\": 6,\n      \"./zlib/zstream\": 8\n    }]\n  }, {}, [])(\"/lib/deflate.js\");\n});","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/pako/dist/pako_deflate.js"],"names":["f","exports","module","define","amd","g","window","global","self","pako","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","TYPED_OK","Uint8Array","Uint16Array","Int32Array","_has","obj","key","Object","prototype","hasOwnProperty","assign","sources","Array","slice","arguments","source","shift","TypeError","shrinkBuf","buf","size","subarray","fnTyped","arraySet","dest","src","src_offs","len","dest_offs","set","flattenChunks","chunks","l","pos","chunk","result","fnUntyped","concat","apply","setTyped","on","Buf8","Buf16","Buf32","utils","STR_APPLY_OK","STR_APPLY_UIA_OK","String","fromCharCode","__","_utf8len","q","string2buf","str","c2","m_pos","str_len","buf_len","charCodeAt","buf2binstring","binstring2buf","buf2string","max","out","c_len","utf16buf","utf8border","adler32","adler","s1","s2","makeTable","table","k","crcTable","crc32","crc","end","trees","msg","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","rank","zero","flush_pending","s","state","pending","avail_out","output","pending_buf","pending_out","next_out","total_out","flush_block_only","last","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","m","more","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","_tr_init","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","deflateInit","deflate","old_flush","beg","val","text","hcrc","extra","name","comment","time","os","header","level_flags","bstate","_tr_align","_tr_stored_block","deflateEnd","deflateSetDictionary","dictionary","dictLength","avail","next","tmpDict","deflateInfo","Z_BINARY","Z_TEXT","STORED_BLOCK","STATIC_TREES","DYN_TREES","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","w","send_bits","value","send_code","tree","bi_reverse","res","bi_flush","gen_bitlen","desc","stree","base","h","bits","xbits","overflow","gen_codes","next_code","tr_static_init","init_block","bi_windup","copy_block","smaller","_n2","_m2","pqdownheap","v","j","compress_block","ltree","dtree","lc","lx","build_tree","node","scan_tree","prevlen","curlen","nextlen","count","max_count","min_count","send_tree","build_bl_tree","max_blindex","send_all_trees","lcodes","dcodes","blcodes","detect_data_type","black_mask","static_init_done","stored_len","opt_lenb","static_lenb","ZStream","zlib_deflate","strings","toString","Z_SYNC_FLUSH","Deflate","options","chunkSize","to","opt","raw","gzip","ended","dict","_dict_set","push","data","mode","_mode","onEnd","onData","join","deflator","deflateRaw"],"mappings":"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","sourcesContent":["/* pako 1.0.11 nodeca/pako */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n},{}],2:[function(require,module,exports){\n// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n},{\"./common\":1}],3:[function(require,module,exports){\n'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n},{\"../utils/common\":1,\"./adler32\":3,\"./crc32\":4,\"./messages\":6,\"./trees\":7}],6:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n},{\"../utils/common\":1}],8:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n},{}],\"/lib/deflate.js\":[function(require,module,exports){\n'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n},{\"./utils/common\":1,\"./utils/strings\":2,\"./zlib/deflate\":5,\"./zlib/messages\":6,\"./zlib/zstream\":8}]},{},[])(\"/lib/deflate.js\")\n});\n"]},"metadata":{},"sourceType":"script"}