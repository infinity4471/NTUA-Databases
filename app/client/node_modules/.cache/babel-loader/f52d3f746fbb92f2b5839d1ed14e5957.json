{"ast":null,"code":"import * as React from 'react';\n/**\n * @hidden\n */\n\nexport function useDir(elementRef, initialDir, args) {\n  // Dir prop is read only on initial rendering due to specifics of getComputedStyles - see below\n  var _a = React.useState(initialDir),\n      dir = _a[0],\n      setDir = _a[1];\n\n  React.useEffect(function () {\n    if (!dir && window && elementRef.current) {\n      // Note: getComputedStyle forces reflow\n      var rtlCandidate = window.getComputedStyle(elementRef.current).direction;\n\n      if (rtlCandidate) {\n        // rerender is needed as DOM is read after first render\n        setDir(rtlCandidate);\n      }\n    }\n  }, args);\n  return dir;\n}\n/**\n * An utility function for asynchronous focus/blur handling.\n *\n * By default, the `onFocus` and `onBlur` callbacks are called every time a child components receives/loses focus.\n * Use this utility hook for scenarios where you need to know if the parent has received focus for the first time, or completely lost focus.\n */\n\nexport function useAsyncFocusBlur(_a) {\n  var onFocus = _a.onFocus,\n      onBlur = _a.onBlur;\n  var tick = React.useRef(0);\n  var nextTick = React.useCallback(function (f) {\n    clearTimeout(tick.current);\n    tick.current = setTimeout(function () {\n      return f();\n    });\n  }, [tick]);\n  var handleFocus = React.useCallback(function () {\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    clearTimeout(tick.current);\n\n    if (onFocus) {\n      onFocus.call.apply(onFocus, [undefined].concat(event));\n    }\n  }, [onFocus, tick]);\n  var handleBlur = React.useCallback(function () {\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    nextTick(function () {\n      if (onBlur) {\n        onBlur.call.apply(onBlur, [undefined].concat(event));\n      }\n    });\n  }, [nextTick]);\n  return {\n    onFocus: handleFocus,\n    onBlur: handleBlur\n  };\n}","map":{"version":3,"sources":["../../../src/hooks/useDir.tsx"],"names":[],"mappings":"AACA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAEA;;;;AAGA,OAAM,SAAU,MAAV,CACF,UADE,EAEF,UAFE,EAGF,IAHE,EAGQ;AAGV;AACM,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,CAAA,UAAA,CAAA;AAAA,MAAC,GAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAM,MAAA,GAAA,EAAA,CAAA,CAAA,CAAN;;AAEN,EAAA,KAAK,CAAC,SAAN,CACI,YAAA;AACI,QAAI,CAAC,GAAD,IAAQ,MAAR,IAAkB,UAAU,CAAC,OAAjC,EAA0C;AACtC;AACA,UAAM,YAAY,GAAG,MAAM,CAAC,gBAAP,CAAwB,UAAU,CAAC,OAAnC,EAA6C,SAAlE;;AAEA,UAAI,YAAJ,EAAkB;AACd;AACA,QAAA,MAAM,CAAC,YAAD,CAAN;AACH;AACJ;AACJ,GAXL,EAYI,IAZJ;AAeA,SAAO,GAAP;AACH;AAED;;;;;;;AAMA,OAAM,SAAU,iBAAV,CAA6C,EAA7C,EAGL;MAHoD,OAAA,GAAA,EAAA,CAAA,O;MAAS,MAAA,GAAA,EAAA,CAAA,M;AAO1D,MAAM,IAAI,GAAG,KAAK,CAAC,MAAN,CAAa,CAAb,CAAb;AAEA,MAAM,QAAQ,GAAG,KAAK,CAAC,WAAN,CACb,UAAC,CAAD,EAAa;AACT,IAAA,YAAY,CAAC,IAAI,CAAC,OAAN,CAAZ;AACA,IAAA,IAAI,CAAC,OAAL,GAAe,UAAU,CAAC,YAAA;AAAM,aAAA,CAAA,EAAA;AAAG,KAAV,CAAzB;AACH,GAJY,EAKb,CAAC,IAAD,CALa,CAAjB;AAOA,MAAM,WAAW,GAAG,KAAK,CAAC,WAAN,CAChB,YAAA;AAAC,QAAA,KAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAW;AAAX,MAAA,KAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACG,IAAA,YAAY,CAAC,IAAI,CAAC,OAAN,CAAZ;;AACA,QAAI,OAAJ,EAAa;AACT,MAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,CAAM,SAAN,EAAe,MAAf,CAAoB,KAApB,CAAP;AACH;AACJ,GANe,EAOhB,CAAC,OAAD,EAAU,IAAV,CAPgB,CAApB;AAUA,MAAM,UAAU,GAAG,KAAK,CAAC,WAAN,CACf,YAAA;AAAC,QAAA,KAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAW;AAAX,MAAA,KAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACG,IAAA,QAAQ,CAAC,YAAA;AAAQ,UAAI,MAAJ,EAAY;AAAE,QAAA,MAAM,CAAC,IAAP,CAAW,KAAX,CAAA,MAAA,EAAM,CAAM,SAAN,EAAe,MAAf,CAAoB,KAApB,CAAN;AAAmC;AAAE,KAA5D,CAAR;AACH,GAHc,EAIf,CAAC,QAAD,CAJe,CAAnB;AAOA,SAAO;AACH,IAAA,OAAO,EAAE,WADN;AAEH,IAAA,MAAM,EAAE;AAFL,GAAP;AAIH","sourceRoot":"","sourcesContent":["import * as React from 'react';\n/**\n * @hidden\n */\nexport function useDir(elementRef, initialDir, args) {\n    // Dir prop is read only on initial rendering due to specifics of getComputedStyles - see below\n    var _a = React.useState(initialDir), dir = _a[0], setDir = _a[1];\n    React.useEffect(function () {\n        if (!dir && window && elementRef.current) {\n            // Note: getComputedStyle forces reflow\n            var rtlCandidate = window.getComputedStyle(elementRef.current).direction;\n            if (rtlCandidate) {\n                // rerender is needed as DOM is read after first render\n                setDir(rtlCandidate);\n            }\n        }\n    }, args);\n    return dir;\n}\n/**\n * An utility function for asynchronous focus/blur handling.\n *\n * By default, the `onFocus` and `onBlur` callbacks are called every time a child components receives/loses focus.\n * Use this utility hook for scenarios where you need to know if the parent has received focus for the first time, or completely lost focus.\n */\nexport function useAsyncFocusBlur(_a) {\n    var onFocus = _a.onFocus, onBlur = _a.onBlur;\n    var tick = React.useRef(0);\n    var nextTick = React.useCallback(function (f) {\n        clearTimeout(tick.current);\n        tick.current = setTimeout(function () { return f(); });\n    }, [tick]);\n    var handleFocus = React.useCallback(function () {\n        var event = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            event[_i] = arguments[_i];\n        }\n        clearTimeout(tick.current);\n        if (onFocus) {\n            onFocus.call.apply(onFocus, [undefined].concat(event));\n        }\n    }, [onFocus, tick]);\n    var handleBlur = React.useCallback(function () {\n        var event = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            event[_i] = arguments[_i];\n        }\n        nextTick(function () { if (onBlur) {\n            onBlur.call.apply(onBlur, [undefined].concat(event));\n        } });\n    }, [nextTick]);\n    return {\n        onFocus: handleFocus,\n        onBlur: handleBlur\n    };\n}\n//# sourceMappingURL=useDir.js.map"]},"metadata":{},"sourceType":"module"}