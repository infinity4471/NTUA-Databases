{"ast":null,"code":"import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\nvar DEFAULT_DECIMAL_ROUNDING = 3;\nvar DEFAULT_PERCENT_ROUNDING = 0;\nvar trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n  var minimumFractionDigits = options.minimumFractionDigits;\n  var maximumFractionDigits = options.maximumFractionDigits;\n  var style = options.style;\n  var isCurrency = isCurrencyStyle(style);\n  var currencyFractions;\n\n  if (isCurrency) {\n    currencyFractions = currencyFractionOptions(options.currency);\n  }\n\n  if (minimumFractionDigits === undefined) {\n    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n  }\n\n  if (maximumFractionDigits === undefined) {\n    if (style === PERCENT) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n    } else if (isCurrency) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n    } else {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n    }\n  }\n\n  return {\n    minimumFractionDigits: minimumFractionDigits,\n    maximumFractionDigits: maximumFractionDigits\n  };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n  var result = EMPTY;\n\n  for (var idx = 0, length = pattern.length; idx < length; idx++) {\n    var ch = pattern.charAt(idx);\n\n    if (ch === NUMBER_PLACEHOLDER) {\n      result += value;\n    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n      result += symbol;\n    } else {\n      result += ch;\n    }\n  }\n\n  return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n  var currencyInfo = info.numbers.currency;\n  var pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n\n  if (value < 0) {\n    pattern = pattern.replace(NUMBER_PLACEHOLDER, \"-\" + NUMBER_PLACEHOLDER);\n  }\n\n  return pattern;\n}\n\nexport default function standardNumberFormat(number, options, info) {\n  var symbols = info.numbers.symbols;\n  var style = options.style;\n  var isCurrency = isCurrencyStyle(style); //return number in exponential format\n\n  if (style === SCIENTIFIC) {\n    var exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n    return exponential.replace(POINT, symbols.decimal);\n  }\n\n  var value = number;\n  var symbol;\n\n  if (isCurrency) {\n    options.value = value;\n    symbol = formatCurrencySymbol(info, options);\n  }\n\n  if (style === PERCENT) {\n    value *= 100;\n    symbol = symbols.percentSign;\n  }\n\n  var ref = fractionOptions(options);\n  var minimumFractionDigits = ref.minimumFractionDigits;\n  var maximumFractionDigits = ref.maximumFractionDigits;\n  value = round(value, maximumFractionDigits);\n  var negative = value < 0;\n  var negativeZero = isNegativeZero(number);\n  var parts = value.split(POINT);\n  var integer = parts[0];\n  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true); //exclude \"-\" if number is negative.\n\n  if (negative) {\n    integer = integer.substring(1);\n  }\n\n  if (options.minimumIntegerDigits) {\n    integer = pad(integer, options.minimumIntegerDigits);\n  }\n\n  var formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n  if (fraction) {\n    formattedValue += symbols.decimal + fraction;\n  }\n\n  var pattern;\n\n  if (isCurrency && options.currencyDisplay === \"name\") {\n    pattern = currencyUnitPattern(info, number);\n  } else {\n    var patterns = options.patterns;\n    pattern = negative || negativeZero ? patterns[1] || \"-\" + patterns[0] : patterns[0];\n  }\n\n  if (pattern === NUMBER_PLACEHOLDER && !negative) {\n    return formattedValue;\n  }\n\n  var result = applyPattern(formattedValue, pattern, symbol);\n  return result;\n}","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@telerik/kendo-intl/dist/es/numbers/standard-number-format.js"],"names":["PERCENT","SCIENTIFIC","NUMBER_PLACEHOLDER","CURRENCY_PLACEHOLDER","PERCENT_PLACEHOLDER","EMPTY","POINT","isNegativeZero","formatCurrencySymbol","groupInteger","isCurrencyStyle","pad","round","currencyFractionOptions","DEFAULT_DECIMAL_ROUNDING","DEFAULT_PERCENT_ROUNDING","trailingZeroRegex","fractionOptions","options","minimumFractionDigits","maximumFractionDigits","style","isCurrency","currencyFractions","currency","undefined","Math","max","applyPattern","value","pattern","symbol","result","idx","length","ch","charAt","currencyUnitPattern","info","currencyInfo","numbers","replace","standardNumberFormat","number","symbols","exponential","toExponential","decimal","percentSign","ref","negative","negativeZero","parts","split","integer","fraction","substring","minimumIntegerDigits","formattedValue","useGrouping","currencyDisplay","patterns"],"mappings":"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","sourcesContent":["import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\n\nvar DEFAULT_DECIMAL_ROUNDING = 3;\nvar DEFAULT_PERCENT_ROUNDING = 0;\n\nvar trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n    var minimumFractionDigits = options.minimumFractionDigits;\n    var maximumFractionDigits = options.maximumFractionDigits;\n    var style = options.style;\n    var isCurrency = isCurrencyStyle(style);\n    var currencyFractions;\n    if (isCurrency) {\n        currencyFractions = currencyFractionOptions(options.currency);\n    }\n\n    if (minimumFractionDigits === undefined) {\n        minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n    }\n\n    if (maximumFractionDigits === undefined) {\n        if (style === PERCENT) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n        } else if (isCurrency) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n        } else {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n        }\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n    var result = EMPTY;\n    for (var idx = 0, length = pattern.length; idx < length; idx++) {\n        var ch = pattern.charAt(idx);\n\n        if (ch === NUMBER_PLACEHOLDER) {\n            result += value;\n        } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n            result += symbol;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n    var currencyInfo = info.numbers.currency;\n    var pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n    if (value < 0) {\n        pattern = pattern.replace(NUMBER_PLACEHOLDER, (\"-\" + NUMBER_PLACEHOLDER));\n    }\n\n    return pattern;\n}\n\n\nexport default function standardNumberFormat(number, options, info) {\n    var symbols = info.numbers.symbols;\n    var style = options.style;\n    var isCurrency = isCurrencyStyle(style);\n\n    //return number in exponential format\n    if (style === SCIENTIFIC) {\n        var exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n        return exponential.replace(POINT, symbols.decimal);\n    }\n\n    var value = number;\n    var symbol;\n\n    if (isCurrency) {\n        options.value = value;\n        symbol = formatCurrencySymbol(info, options);\n    }\n\n    if (style === PERCENT) {\n        value *= 100;\n        symbol = symbols.percentSign;\n    }\n\n    var ref = fractionOptions(options);\n    var minimumFractionDigits = ref.minimumFractionDigits;\n    var maximumFractionDigits = ref.maximumFractionDigits;\n\n    value = round(value, maximumFractionDigits);\n\n    var negative = value < 0;\n    var negativeZero = isNegativeZero(number);\n\n    var parts = value.split(POINT);\n\n    var integer = parts[0];\n    var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);\n\n    //exclude \"-\" if number is negative.\n    if (negative) {\n        integer = integer.substring(1);\n    }\n\n    if (options.minimumIntegerDigits) {\n        integer = pad(integer, options.minimumIntegerDigits);\n    }\n\n    var formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n    if (fraction) {\n        formattedValue += symbols.decimal + fraction;\n    }\n\n    var pattern;\n\n    if (isCurrency && options.currencyDisplay === \"name\") {\n        pattern = currencyUnitPattern(info, number);\n    } else {\n        var patterns = options.patterns;\n        pattern = (negative || negativeZero) ? patterns[1] || (\"-\" + patterns[0]) : patterns[0];\n    }\n\n    if (pattern === NUMBER_PLACEHOLDER && !negative) {\n        return formattedValue;\n    }\n\n    var result = applyPattern(formattedValue, pattern, symbol);\n\n    return result;\n}"]},"metadata":{},"sourceType":"module"}