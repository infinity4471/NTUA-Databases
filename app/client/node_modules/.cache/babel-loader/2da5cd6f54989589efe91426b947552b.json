{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\n\nvar toQueryString = function (values) {\n  return values.reduce(function (acc, _a) {\n    var key = _a[0],\n        value = _a[1];\n    return acc.concat([key + \"=\" + value]);\n  }, []);\n};\n\nvar toObject = function (values) {\n  return values.reduce(function (acc, _a) {\n    var key = _a[0],\n        value = _a[1];\n\n    var _b;\n\n    return tslib_1.__assign({}, acc, (_b = {}, _b[key] = value, _b));\n  }, {});\n};\n\nvar pairwise = function (key) {\n  return function (value) {\n    return [key, value];\n  };\n};\n\nvar empty = function () {\n  return null;\n};\n\nvar isNotEmptyArray = function (value) {\n  return isPresent(value) && isArray(value) && value.length > 0;\n};\n\nvar has = function (accessor) {\n  return function (value) {\n    return isPresent(accessor(value));\n  };\n};\n\nvar isNotEmpty = function (accessor) {\n  return function (value) {\n    return isNotEmptyArray(accessor(value));\n  };\n};\n\nvar runOrEmpty = function (predicate, fn) {\n  return ifElse(predicate, fn, empty);\n};\n\nvar calcPage = function (_a) {\n  var skip = _a.skip,\n      take = _a.take;\n  return Math.floor((skip || 0) / take) + 1;\n};\n\nvar formatDescriptors = function (accessor, formatter) {\n  return function (state) {\n    return accessor(state).map(formatter).join(\"~\");\n  };\n};\n\nvar removeAfter = function (what) {\n  return function (str) {\n    return str.slice(0, str.indexOf(what));\n  };\n};\n\nvar replace = function (patterns) {\n  return compose.apply(void 0, patterns.map(function (_a) {\n    var left = _a[0],\n        right = _a[1];\n    return function (s) {\n      return s.replace(new RegExp(left, \"g\"), right);\n    };\n  }));\n};\n\nvar sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nvar removeAfterDot = removeAfter(\".\");\n\nvar directionFormatter = function (_a) {\n  var field = _a.field,\n      _b = _a.dir,\n      dir = _b === void 0 ? \"asc\" : _b;\n  return field + \"-\" + dir;\n};\n\nvar aggregateFormatter = function (_a) {\n  var field = _a.field,\n      aggregate = _a.aggregate;\n  return field + \"-\" + aggregate;\n};\n\nvar take = getter(\"take\");\nvar aggregates = getter(\"aggregates\");\nvar skip = getter(\"skip\");\nvar group = getter(\"group\");\nvar sort = getter(\"sort\", true);\nvar formatSort = formatDescriptors(sort, directionFormatter);\nvar formatGroup = formatDescriptors(group, directionFormatter);\nvar formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\n\nvar prefixDateValue = function (value) {\n  return \"datetime'\" + value + \"'\";\n};\n\nvar formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\n\nvar formatDate = function (_a) {\n  var field = _a.field,\n      value = _a.value,\n      ignoreCase = _a.ignoreCase,\n      operator = _a.operator;\n  return {\n    value: formatDateValue(value),\n    field: field,\n    ignoreCase: ignoreCase,\n    operator: operator\n  };\n};\n\nvar normalizeSort = function (state) {\n  return Object.assign({}, state, {\n    sort: (sort(state) || []).filter(function (_a) {\n      var dir = _a.dir;\n      return isNotNullOrEmptyString(dir);\n    })\n  });\n};\n\nvar transformSkip = compose(pairwise('page'), calcPage);\nvar transformTake = compose(pairwise('pageSize'), take);\nvar transformGroup = compose(pairwise('group'), formatGroup);\nvar transformSort = compose(pairwise('sort'), formatSort);\nvar transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nvar serializePage = runOrEmpty(has(skip), transformSkip);\nvar serializePageSize = runOrEmpty(has(take), transformTake);\nvar serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nvar serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nvar serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\n\nvar hasField = function (_a) {\n  var field = _a.field;\n  return isNotNullOrEmptyString(field);\n};\n\nvar filterFormatter = function (_a) {\n  var field = _a.field,\n      operator = _a.operator,\n      value = _a.value;\n  return field + \"~\" + operator + \"~\" + value;\n};\n\nvar dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\n\nvar typedFormatter = function (encode) {\n  return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter));\n};\n\nvar join = function (_a) {\n  var logic = _a.logic;\n  return \"~\" + logic + \"~\";\n};\n\nvar serialize = function (encode) {\n  return serializeFilters(function (filter) {\n    return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter);\n  }, join);\n};\n\nvar serializeFilter = function (_a, encode) {\n  var filter = _a.filter;\n\n  if (filter && filter.filters) {\n    var filters = serialize(encode)(filter);\n\n    if (filters.length) {\n      return ['filter', filters];\n    }\n  }\n\n  return null;\n};\n\nvar rules = function (state, encode) {\n  if (encode === void 0) {\n    encode = true;\n  }\n\n  return function (key) {\n    return {\n      \"aggregates\": serializeAggregates(state),\n      \"filter\": serializeFilter(state, encode),\n      \"group\": serializeGroup(state),\n      \"skip\": serializePage(state),\n      \"sort\": serializeSort(state),\n      \"take\": serializePageSize(state)\n    }[key];\n  };\n};\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts-no-run\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx-no-run\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\n\n\nexport var toDataSourceRequestString = function (state) {\n  return toQueryString(Object.keys(state).map(rules(state)).filter(isPresent)).join('&');\n};\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\n\nexport var toDataSourceRequest = function (state) {\n  return toObject(Object.keys(state).map(rules(state, false)).filter(isPresent));\n};","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js"],"names":["tslib_1","isCompositeFilterDescriptor","isPresent","isNotNullOrEmptyString","isArray","getter","compose","ifElse","identity","isStringValue","isDateValue","quote","serializeFilters","toUTC","encodeValue","toQueryString","values","reduce","acc","_a","key","value","concat","toObject","_b","__assign","pairwise","empty","isNotEmptyArray","length","has","accessor","isNotEmpty","runOrEmpty","predicate","fn","calcPage","skip","take","Math","floor","formatDescriptors","formatter","state","map","join","removeAfter","what","str","slice","indexOf","replace","patterns","apply","left","right","s","RegExp","sanitizeDateLiterals","removeAfterDot","directionFormatter","field","dir","aggregateFormatter","aggregate","aggregates","group","sort","formatSort","formatGroup","formatAggregates","prefixDateValue","formatDateValue","JSON","stringify","formatDate","ignoreCase","operator","normalizeSort","Object","assign","filter","transformSkip","transformTake","transformGroup","transformSort","transformAggregates","serializePage","serializePageSize","serializeGroup","serializeAggregates","serializeSort","hasField","filterFormatter","dateFormatter","typedFormatter","encode","logic","serialize","serializeFilter","filters","rules","toDataSourceRequestString","keys","toDataSourceRequest"],"mappings":"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","sourcesContent":["import * as tslib_1 from \"tslib\";\nimport { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\nvar toQueryString = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    return acc.concat([key + \"=\" + value]);\n}, []); };\nvar toObject = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    var _b;\n    return (tslib_1.__assign({}, acc, (_b = {}, _b[key] = value, _b)));\n}, {}); };\nvar pairwise = function (key) { return function (value) { return [key, value]; }; };\nvar empty = function () { return null; };\nvar isNotEmptyArray = function (value) { return isPresent(value) && isArray(value) && value.length > 0; };\nvar has = function (accessor) { return function (value) { return isPresent(accessor(value)); }; };\nvar isNotEmpty = function (accessor) { return function (value) { return isNotEmptyArray(accessor(value)); }; };\nvar runOrEmpty = function (predicate, fn) { return ifElse(predicate, fn, empty); };\nvar calcPage = function (_a) {\n    var skip = _a.skip, take = _a.take;\n    return Math.floor((skip || 0) / take) + 1;\n};\nvar formatDescriptors = function (accessor, formatter) { return function (state) { return (accessor(state).map(formatter).join(\"~\")); }; };\nvar removeAfter = function (what) { return function (str) { return str.slice(0, str.indexOf(what)); }; };\nvar replace = function (patterns) {\n    return compose.apply(void 0, patterns.map(function (_a) {\n        var left = _a[0], right = _a[1];\n        return function (s) { return s.replace(new RegExp(left, \"g\"), right); };\n    }));\n};\nvar sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nvar removeAfterDot = removeAfter(\".\");\nvar directionFormatter = function (_a) {\n    var field = _a.field, _b = _a.dir, dir = _b === void 0 ? \"asc\" : _b;\n    return field + \"-\" + dir;\n};\nvar aggregateFormatter = function (_a) {\n    var field = _a.field, aggregate = _a.aggregate;\n    return field + \"-\" + aggregate;\n};\nvar take = getter(\"take\");\nvar aggregates = getter(\"aggregates\");\nvar skip = getter(\"skip\");\nvar group = getter(\"group\");\nvar sort = getter(\"sort\", true);\nvar formatSort = formatDescriptors(sort, directionFormatter);\nvar formatGroup = formatDescriptors(group, directionFormatter);\nvar formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\nvar prefixDateValue = function (value) { return \"datetime'\" + value + \"'\"; };\nvar formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\nvar formatDate = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: formatDateValue(value),\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\nvar normalizeSort = function (state) { return Object.assign({}, state, {\n    sort: (sort(state) || []).filter(function (_a) {\n        var dir = _a.dir;\n        return isNotNullOrEmptyString(dir);\n    })\n}); };\nvar transformSkip = compose(pairwise('page'), calcPage);\nvar transformTake = compose(pairwise('pageSize'), take);\nvar transformGroup = compose(pairwise('group'), formatGroup);\nvar transformSort = compose(pairwise('sort'), formatSort);\nvar transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nvar serializePage = runOrEmpty(has(skip), transformSkip);\nvar serializePageSize = runOrEmpty(has(take), transformTake);\nvar serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nvar serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nvar serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\nvar hasField = function (_a) {\n    var field = _a.field;\n    return isNotNullOrEmptyString(field);\n};\nvar filterFormatter = function (_a) {\n    var field = _a.field, operator = _a.operator, value = _a.value;\n    return field + \"~\" + operator + \"~\" + value;\n};\nvar dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\nvar typedFormatter = function (encode) { return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter)); };\nvar join = function (_a) {\n    var logic = _a.logic;\n    return \"~\" + logic + \"~\";\n};\nvar serialize = function (encode) { return serializeFilters(function (filter) { return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter); }, join); };\nvar serializeFilter = function (_a, encode) {\n    var filter = _a.filter;\n    if (filter && filter.filters) {\n        var filters = serialize(encode)(filter);\n        if (filters.length) {\n            return ['filter', filters];\n        }\n    }\n    return null;\n};\nvar rules = function (state, encode) {\n    if (encode === void 0) { encode = true; }\n    return function (key) { return ({\n        \"aggregates\": serializeAggregates(state),\n        \"filter\": serializeFilter(state, encode),\n        \"group\": serializeGroup(state),\n        \"skip\": serializePage(state),\n        \"sort\": serializeSort(state),\n        \"take\": serializePageSize(state)\n    }[key]); };\n};\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts-no-run\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx-no-run\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport var toDataSourceRequestString = function (state) { return (toQueryString(Object.keys(state)\n    .map(rules(state))\n    .filter(isPresent)).join('&')); };\n/**\n * Converts a [`DataSourceRequestState`]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\nexport var toDataSourceRequest = function (state) { return (toObject(Object.keys(state)\n    .map(rules(state, false))\n    .filter(isPresent))); };\n"]},"metadata":{},"sourceType":"module"}