{"ast":null,"code":"import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { Class } from '../common';\nimport { rad } from '../util';\nvar PI_DIV_2 = Math.PI / 2;\n\nvar Circle = function (Class) {\n  function Circle(center, radius) {\n    if (center === void 0) center = new Point();\n    if (radius === void 0) radius = 0;\n    Class.call(this);\n    this.setCenter(center);\n    this.setRadius(radius);\n  }\n\n  if (Class) Circle.__proto__ = Class;\n  Circle.prototype = Object.create(Class && Class.prototype);\n  Circle.prototype.constructor = Circle;\n\n  Circle.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Circle.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n\n  Circle.prototype.equals = function equals(other) {\n    return other && other.center.equals(this.center) && other.radius === this.radius;\n  };\n\n  Circle.prototype.clone = function clone() {\n    return new Circle(this.center.clone(), this.radius);\n  };\n\n  Circle.prototype.pointAt = function pointAt(angle) {\n    return this._pointAt(rad(angle));\n  };\n\n  Circle.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n    var minPoint = Point.maxPoint();\n    var maxPoint = Point.minPoint();\n\n    for (var i = 0; i < 4; i++) {\n      var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n\n      var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n\n      var currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n\n  Circle.prototype._pointAt = function _pointAt(angle) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    return new Point(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n  };\n\n  Circle.prototype.containsPoint = function containsPoint(point) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    var inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n    return inCircle;\n  };\n\n  Circle.prototype._isOnPath = function _isOnPath(point, width) {\n    var ref = this;\n    var center = ref.center;\n    var radius = ref.radius;\n    var pointDistance = center.distanceTo(point);\n    return radius - width <= pointDistance && pointDistance <= radius + width;\n  };\n\n  return Circle;\n}(Class);\n\ndefineAccessors(Circle.prototype, [\"radius\"]);\nObserversMixin.extend(Circle.prototype);\nexport default Circle;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/geometry/circle.js"],"names":["defineAccessors","ObserversMixin","Point","Rect","ellipseExtremeAngles","Class","rad","PI_DIV_2","Math","PI","Circle","center","radius","call","setCenter","setRadius","__proto__","prototype","Object","create","constructor","value","_observerField","geometryChange","getCenter","equals","other","clone","pointAt","angle","_pointAt","bbox","matrix","this$1","extremeAngles","minPoint","maxPoint","i","currentPointX","x","transformCopy","currentPointY","y","currentPoint","min","max","fromPoints","ref","cos","sin","containsPoint","point","inCircle","pow","_isOnPath","width","pointDistance","distanceTo","extend"],"mappings":"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","sourcesContent":["import defineAccessors from '../accessors/define-accessors';\nimport ObserversMixin from '../mixins/observers-mixin';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { Class } from '../common';\nimport { rad } from '../util';\n\nvar PI_DIV_2 = Math.PI / 2;\n\nvar Circle = (function (Class) {\n    function Circle(center, radius) {\n        if ( center === void 0 ) center = new Point();\n        if ( radius === void 0 ) radius = 0;\n\n        Class.call(this);\n\n        this.setCenter(center);\n        this.setRadius(radius);\n    }\n\n    if ( Class ) Circle.__proto__ = Class;\n    Circle.prototype = Object.create( Class && Class.prototype );\n    Circle.prototype.constructor = Circle;\n\n    Circle.prototype.setCenter = function setCenter (value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    };\n\n    Circle.prototype.getCenter = function getCenter () {\n        return this.center;\n    };\n\n    Circle.prototype.equals = function equals (other) {\n        return other &&\n               other.center.equals(this.center) &&\n               other.radius === this.radius;\n    };\n\n    Circle.prototype.clone = function clone () {\n        return new Circle(this.center.clone(), this.radius);\n    };\n\n    Circle.prototype.pointAt = function pointAt (angle) {\n        return this._pointAt(rad(angle));\n    };\n\n    Circle.prototype.bbox = function bbox (matrix) {\n        var this$1 = this;\n\n        var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n        var minPoint = Point.maxPoint();\n        var maxPoint = Point.minPoint();\n\n        for (var i = 0; i < 4; i++) {\n            var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n            var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n            var currentPoint = new Point(currentPointX.x, currentPointY.y);\n\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    };\n\n    Circle.prototype._pointAt = function _pointAt (angle) {\n        var ref = this;\n        var center = ref.center;\n        var radius = ref.radius;\n\n        return new Point(\n            center.x + radius * Math.cos(angle),\n            center.y + radius * Math.sin(angle)\n        );\n    };\n\n    Circle.prototype.containsPoint = function containsPoint (point) {\n        var ref = this;\n        var center = ref.center;\n        var radius = ref.radius;\n        var inCircle = Math.pow(point.x - center.x, 2) +\n            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n        return inCircle;\n    };\n\n    Circle.prototype._isOnPath = function _isOnPath (point, width) {\n        var ref = this;\n        var center = ref.center;\n        var radius = ref.radius;\n        var pointDistance = center.distanceTo(point);\n\n        return radius - width <= pointDistance && pointDistance <= radius + width;\n    };\n\n    return Circle;\n}(Class));\n\ndefineAccessors(Circle.prototype, [ \"radius\" ]);\nObserversMixin.extend(Circle.prototype);\n\nexport default Circle;"]},"metadata":{},"sourceType":"module"}