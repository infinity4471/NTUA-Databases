{"ast":null,"code":"import { isPresent } from './misc';\nimport { parseColor } from '@progress/kendo-drawing';\n/**\n * @hidden\n */\n\nvar ColorPaletteService =\n/** @class */\nfunction () {\n  function ColorPaletteService() {\n    this.colorRows = [];\n  }\n\n  ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {\n    this.colorRows = [];\n\n    if (!(isPresent(palette) && palette.length)) {\n      return;\n    }\n\n    columns = columns || palette.length;\n\n    for (var start = 0; start < palette.length; start += columns) {\n      var row = palette.slice(start, columns + start);\n      this.colorRows.push(row);\n    }\n  };\n\n  ColorPaletteService.prototype.getCellCoordsFor = function (color) {\n    var _this = this;\n\n    if (!isPresent(color)) {\n      return;\n    }\n\n    var parsedColor = color ? parseColor(color, true) : color;\n    var colors = [color];\n\n    if (isPresent(parsedColor)) {\n      colors.push(parsedColor.toCss(), parsedColor.toCssRgba());\n    }\n\n    var _loop_1 = function (row) {\n      var _loop_2 = function (col) {\n        if (colors.some(function (c) {\n          return c === _this.colorRows[row][col];\n        })) {\n          return {\n            value: {\n              row: row,\n              col: col\n            }\n          };\n        }\n      };\n\n      for (var col = 0; col < this_1.colorRows[row].length; col++) {\n        var state_2 = _loop_2(col);\n\n        if (typeof state_2 === \"object\") return state_2;\n      }\n    };\n\n    var this_1 = this;\n\n    for (var row = 0; row < this.colorRows.length; row++) {\n      var state_1 = _loop_1(row);\n\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n  };\n\n  ColorPaletteService.prototype.getColorAt = function (cellCoords) {\n    if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n      return;\n    }\n\n    return this.colorRows[cellCoords.row][cellCoords.col];\n  };\n\n  ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {\n    if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n      return {\n        row: 0,\n        col: 0\n      };\n    }\n\n    var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n    var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n    return {\n      row: row,\n      col: col\n    };\n  };\n\n  ColorPaletteService.prototype.clampIndex = function (index, max) {\n    var minArrayIndex = 0;\n\n    if (index < minArrayIndex) {\n      return minArrayIndex;\n    }\n\n    if (index > max) {\n      return max;\n    }\n\n    return index;\n  };\n\n  return ColorPaletteService;\n}();\n\nexport { ColorPaletteService };","map":{"version":3,"sources":["../../../../src/colors/utils/color-palette.service.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isPresent } from './misc';\nimport { parseColor } from '@progress/kendo-drawing';\n/**\n * @hidden\n */\nvar ColorPaletteService = /** @class */ (function () {\n    function ColorPaletteService() {\n        this.colorRows = [];\n    }\n    ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {\n        this.colorRows = [];\n        if (!(isPresent(palette) && palette.length)) {\n            return;\n        }\n        columns = columns || palette.length;\n        for (var start = 0; start < palette.length; start += columns) {\n            var row = palette.slice(start, columns + start);\n            this.colorRows.push(row);\n        }\n    };\n    ColorPaletteService.prototype.getCellCoordsFor = function (color) {\n        var _this = this;\n        if (!isPresent(color)) {\n            return;\n        }\n        var parsedColor = color ? parseColor(color, true) : color;\n        var colors = [color];\n        if (isPresent(parsedColor)) {\n            colors.push(parsedColor.toCss(), parsedColor.toCssRgba());\n        }\n        var _loop_1 = function (row) {\n            var _loop_2 = function (col) {\n                if (colors.some(function (c) { return c === _this.colorRows[row][col]; })) {\n                    return { value: { row: row, col: col } };\n                }\n            };\n            for (var col = 0; col < this_1.colorRows[row].length; col++) {\n                var state_2 = _loop_2(col);\n                if (typeof state_2 === \"object\")\n                    return state_2;\n            }\n        };\n        var this_1 = this;\n        for (var row = 0; row < this.colorRows.length; row++) {\n            var state_1 = _loop_1(row);\n            if (typeof state_1 === \"object\")\n                return state_1.value;\n        }\n    };\n    ColorPaletteService.prototype.getColorAt = function (cellCoords) {\n        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {\n            return;\n        }\n        return this.colorRows[cellCoords.row][cellCoords.col];\n    };\n    ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {\n        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {\n            return { row: 0, col: 0 };\n        }\n        var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);\n        var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);\n        return { row: row, col: col };\n    };\n    ColorPaletteService.prototype.clampIndex = function (index, max) {\n        var minArrayIndex = 0;\n        if (index < minArrayIndex) {\n            return minArrayIndex;\n        }\n        if (index > max) {\n            return max;\n        }\n        return index;\n    };\n    return ColorPaletteService;\n}());\nexport { ColorPaletteService };\n//# sourceMappingURL=color-palette.service.js.map"]},"metadata":{},"sourceType":"module"}