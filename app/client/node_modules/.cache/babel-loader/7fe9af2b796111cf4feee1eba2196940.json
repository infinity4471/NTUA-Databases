{"ast":null,"code":"import ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport definePointAccessors from '../accessors/define-point-accessors';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\n\nvar Segment = function (Class) {\n  function Segment(anchor, controlIn, controlOut) {\n    Class.call(this);\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n\n  if (Class) Segment.__proto__ = Class;\n  Segment.prototype = Object.create(Class && Class.prototype);\n  Segment.prototype.constructor = Segment;\n\n  Segment.prototype.bboxTo = function bboxTo(toSegment, matrix) {\n    var segmentAnchor = this.anchor().transformCopy(matrix);\n    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    var rect;\n\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n\n    return rect;\n  };\n\n  Segment.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  };\n\n  Segment.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {\n    var points = [p1, cp1, cp2, p2];\n\n    var extremesX = this._curveExtremesFor(points, \"x\");\n\n    var extremesY = this._curveExtremesFor(points, \"y\");\n\n    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  };\n\n  Segment.prototype._curveExtremesFor = function _curveExtremesFor(points, field) {\n    var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  };\n\n  Segment.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {\n    var a = x1 - 3 * x2 + 3 * x3 - x4;\n    var b = -2 * (x1 - 2 * x2 + x3);\n    var c = x1 - x2;\n    var sqrt = Math.sqrt(b * b - 4 * a * c);\n    var t1 = 0;\n    var t2 = 1;\n\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n\n    var min = Math.max(Math.min(t1, t2), 0);\n\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n\n    var max = Math.min(Math.max(t1, t2), 1);\n\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  Segment.prototype._intersectionsTo = function _intersectionsTo(segment, point) {\n    var intersectionsCount;\n\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n\n    return intersectionsCount;\n  };\n\n  Segment.prototype._isOnCurveTo = function _isOnCurveTo(segment, point, width, endSegment) {\n    var bbox = this.bboxTo(segment).expand(width, width);\n\n    if (bbox.containsPoint(point)) {\n      var p1 = this.anchor();\n      var p2 = this.controlOut();\n      var p3 = segment.controlIn();\n      var p4 = segment.anchor();\n\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n      var points = [p1, p2, p3, p4];\n\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n\n      var rotation = transform().rotate(45, point);\n      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  };\n\n  Segment.prototype._isOnLineTo = function _isOnLineTo(segment, point, width) {\n    var p1 = this.anchor();\n    var p2 = segment.anchor();\n    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  };\n\n  Segment.prototype._isOnPathTo = function _isOnPathTo(segment, point, width, endSegment) {\n    var isOnPath;\n\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n\n    return isOnPath;\n  };\n\n  return Segment;\n}(Class);\n\ndefinePointAccessors(Segment.prototype, [\"anchor\", \"controlIn\", \"controlOut\"]);\nObserversMixin.extend(Segment.prototype);\n\nfunction arrayLimits(arr) {\n  var length = arr.length;\n  var min = MAX_NUM;\n  var max = MIN_NUM;\n\n  for (var i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nexport default Segment;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js"],"names":["ObserversMixin","Class","definePointAccessors","Rect","Point","transform","deg","MIN_NUM","MAX_NUM","isOutOfEndPoint","calculateCurveAt","hasRootsInRange","curveIntersectionsCount","lineIntersectionsCount","Segment","anchor","controlIn","controlOut","call","__proto__","prototype","Object","create","constructor","bboxTo","toSegment","matrix","segmentAnchor","transformCopy","toSegmentAnchor","rect","_curveBoundingBox","_lineBoundingBox","p1","p2","fromPoints","cp1","cp2","points","extremesX","_curveExtremesFor","extremesY","xLimits","arrayLimits","min","max","x","yLimits","y","field","extremes","_curveExtremes","x1","x2","x3","x4","a","b","c","sqrt","Math","t1","t2","isNaN","_intersectionsTo","segment","point","intersectionsCount","_isOnCurveTo","width","endSegment","bbox","expand","containsPoint","p3","p4","distanceTo","rotation","rotate","rotatedPoints","_isOnLineTo","angle","atan2","_isOnPathTo","isOnPath","extend","arr","length","i"],"mappings":"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","sourcesContent":["import ObserversMixin from '../mixins/observers-mixin';\nimport { Class } from '../common';\nimport definePointAccessors from '../accessors/define-point-accessors';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\n\nvar Segment = (function (Class) {\n    function Segment(anchor, controlIn, controlOut) {\n        Class.call(this);\n\n        this.anchor(anchor || new Point());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    if ( Class ) Segment.__proto__ = Class;\n    Segment.prototype = Object.create( Class && Class.prototype );\n    Segment.prototype.constructor = Segment;\n\n    Segment.prototype.bboxTo = function bboxTo (toSegment, matrix) {\n        var segmentAnchor = this.anchor().transformCopy(matrix);\n        var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        var rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    };\n\n    Segment.prototype._lineBoundingBox = function _lineBoundingBox (p1, p2) {\n        return Rect.fromPoints(p1, p2);\n    };\n\n    Segment.prototype._curveBoundingBox = function _curveBoundingBox (p1, cp1, cp2, p2) {\n        var points = [ p1, cp1, cp2, p2 ];\n        var extremesX = this._curveExtremesFor(points, \"x\");\n        var extremesY = this._curveExtremesFor(points, \"y\");\n        var xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        var yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    };\n\n    Segment.prototype._curveExtremesFor = function _curveExtremesFor (points, field) {\n        var extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    };\n\n    Segment.prototype._curveExtremes = function _curveExtremes (x1, x2, x3, x4) {\n        var a = x1 - 3 * x2 + 3 * x3 - x4;\n        var b = - 2 * (x1 - 2 * x2 + x3);\n        var c = x1 - x2;\n        var sqrt = Math.sqrt(b * b - 4 * a * c);\n        var t1 = 0;\n        var t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        var min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        var max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    Segment.prototype._intersectionsTo = function _intersectionsTo (segment, point) {\n        var intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    };\n\n    Segment.prototype._isOnCurveTo = function _isOnCurveTo (segment, point, width, endSegment) {\n        var bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            var p1 = this.anchor();\n            var p2 = this.controlOut();\n            var p3 = segment.controlIn();\n            var p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            var points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            var rotation = transform().rotate(45, point);\n            var rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    };\n\n    Segment.prototype._isOnLineTo = function _isOnLineTo (segment, point, width) {\n        var p1 = this.anchor();\n        var p2 = segment.anchor();\n        var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        var rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    };\n\n    Segment.prototype._isOnPathTo = function _isOnPathTo (segment, point, width, endSegment) {\n        var isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    };\n\n    return Segment;\n}(Class));\n\ndefinePointAccessors(Segment.prototype, [ \"anchor\", \"controlIn\", \"controlOut\" ]);\nObserversMixin.extend(Segment.prototype);\n\nfunction arrayLimits(arr) {\n    var length = arr.length;\n    var min = MAX_NUM;\n    var max = MIN_NUM;\n\n    for (var i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nexport default Segment;"]},"metadata":{},"sourceType":"module"}