{"ast":null,"code":"import { Class } from '../common';\nimport MultiPath from '../shapes/multi-path';\nimport Point from '../geometry/point';\nimport ShapeMap from './shape-map';\nvar SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nvar SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nvar MOVE = \"m\";\nvar CLOSE = \"z\";\n\nfunction parseParameters(str) {\n  var parameters = [];\n  str.replace(SPLIT_REGEX, function (match, number) {\n    parameters.push(parseFloat(number));\n  });\n  return parameters;\n}\n\nvar PathParser = function (Class) {\n  function PathParser() {\n    Class.apply(this, arguments);\n  }\n\n  if (Class) PathParser.__proto__ = Class;\n  PathParser.prototype = Object.create(Class && Class.prototype);\n  PathParser.prototype.constructor = PathParser;\n\n  PathParser.prototype.parse = function parse(str, options) {\n    var multiPath = new MultiPath(options);\n    var position = new Point();\n    var previousCommand;\n    str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\n      var command = element.toLowerCase();\n      var isRelative = command === element;\n      var parameters = parseParameters(params.trim());\n\n      if (command === MOVE) {\n        if (isRelative) {\n          position.x += parameters[0];\n          position.y += parameters[1];\n        } else {\n          position.x = parameters[0];\n          position.y = parameters[1];\n        }\n\n        multiPath.moveTo(position.x, position.y);\n\n        if (parameters.length > 2) {\n          command = \"l\";\n          parameters.splice(0, 2);\n        }\n      }\n\n      if (ShapeMap[command]) {\n        ShapeMap[command](multiPath, {\n          parameters: parameters,\n          position: position,\n          isRelative: isRelative,\n          previousCommand: previousCommand\n        });\n\n        if (closePath && closePath.toLowerCase() === CLOSE) {\n          multiPath.close();\n        }\n      } else if (command !== MOVE) {\n        throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n      }\n\n      previousCommand = command;\n    });\n    return multiPath;\n  };\n\n  return PathParser;\n}(Class);\n\nPathParser.current = new PathParser();\nexport default PathParser;","map":{"version":3,"sources":["/home/infinity/Desktop/supermarket/NTUA-Databases/app/client/node_modules/@progress/kendo-drawing/dist/es/parsing/path-parser.js"],"names":["Class","MultiPath","Point","ShapeMap","SEGMENT_REGEX","SPLIT_REGEX","MOVE","CLOSE","parseParameters","str","parameters","replace","match","number","push","parseFloat","PathParser","apply","arguments","__proto__","prototype","Object","create","constructor","parse","options","multiPath","position","previousCommand","element","params","closePath","command","toLowerCase","isRelative","trim","x","y","moveTo","length","splice","close","Error","current"],"mappings":"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","sourcesContent":["import { Class } from '../common';\nimport MultiPath from '../shapes/multi-path';\nimport Point from '../geometry/point';\nimport ShapeMap from './shape-map';\n\nvar SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nvar SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nvar MOVE = \"m\";\nvar CLOSE = \"z\";\n\nfunction parseParameters(str) {\n    var parameters = [];\n    str.replace(SPLIT_REGEX, function(match, number) {\n        parameters.push(parseFloat(number));\n    });\n    return parameters;\n}\n\nvar PathParser = (function (Class) {\n    function PathParser () {\n        Class.apply(this, arguments);\n    }\n\n    if ( Class ) PathParser.__proto__ = Class;\n    PathParser.prototype = Object.create( Class && Class.prototype );\n    PathParser.prototype.constructor = PathParser;\n\n    PathParser.prototype.parse = function parse (str, options) {\n        var multiPath = new MultiPath(options);\n        var position = new Point();\n        var previousCommand;\n\n        str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\n            var command = element.toLowerCase();\n            var isRelative = command === element;\n            var parameters = parseParameters(params.trim());\n\n            if (command === MOVE) {\n                if (isRelative) {\n                    position.x += parameters[0];\n                    position.y += parameters[1];\n                } else {\n                    position.x = parameters[0];\n                    position.y = parameters[1];\n                }\n\n                multiPath.moveTo(position.x, position.y);\n\n                if (parameters.length > 2) {\n                    command = \"l\";\n                    parameters.splice(0, 2);\n                }\n            }\n\n            if (ShapeMap[command]) {\n                ShapeMap[command](\n                    multiPath, {\n                        parameters: parameters,\n                        position: position,\n                        isRelative: isRelative,\n                        previousCommand: previousCommand\n                    }\n                );\n\n                if (closePath && closePath.toLowerCase() === CLOSE) {\n                    multiPath.close();\n                }\n            } else if (command !== MOVE) {\n                throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n            }\n\n            previousCommand = command;\n        });\n\n        return multiPath;\n    };\n\n    return PathParser;\n}(Class));\n\nPathParser.current = new PathParser();\n\nexport default PathParser;\n"]},"metadata":{},"sourceType":"module"}