{"ast":null,"code":"import { parseColor as parse, Color } from '@progress/kendo-drawing';\nimport { isPresent, fitIntoBounds } from './misc';\n/**\n * @hidden\n *\n * Returns the hex or RGBA string representation of the color.\n */\n\nexport var parseColor = function (value, format, safe) {\n  if (safe === void 0) {\n    safe = true;\n  }\n\n  var allowedFormats = ['hex', 'rgba']; // TODO: constant?\n  // Angular supports third type: name : const allowedFormats: Array<string> = ['hex', 'rgba', 'name'];\n\n  if (allowedFormats.indexOf(format) === -1) {\n    throw new Error(\"Unsupported color output format '\" + format + \"'. The available options are 'hex' or 'rgba'.\");\n  }\n\n  if (!isPresent(value)) {\n    return;\n  }\n\n  var parsedColor = parse(value.trim(), safe);\n\n  if (!isPresent(parsedColor)) {\n    return;\n  }\n\n  return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\n\nexport var getHSV = function (value, safe) {\n  if (safe === void 0) {\n    safe = true;\n  }\n\n  var parsed = parse(value, safe);\n\n  if (!isPresent(parsed)) {\n    return {};\n  }\n\n  return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\n\nexport var getRGBA = function (value, safe) {\n  if (safe === void 0) {\n    safe = true;\n  }\n\n  var parsed = parse(value, safe);\n\n  if (!isPresent(parsed)) {\n    return {};\n  }\n\n  return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\n\nexport var getColorFromHSV = function (hsva) {\n  var hue = fitIntoBounds(hsva.h, 0, 359.9);\n  var saturation = fitIntoBounds(hsva.s, 0, 1);\n  var value = fitIntoBounds(hsva.v, 0, 1);\n  var alpha = fitIntoBounds(hsva.a, 0, 1);\n  return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue` and\n * assuming the `value`, `saturation`, and `alpha` have a value of `1`.\n */\n\nexport var getColorFromHue = function (hue) {\n  return getColorFromHSV({\n    h: hue,\n    s: 1,\n    v: 1,\n    a: 1\n  });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\n\nexport var getColorFromRGBA = function (rgba) {\n  var red = fitIntoBounds(rgba.r, 0, 255);\n  var green = fitIntoBounds(rgba.g, 0, 255);\n  var blue = fitIntoBounds(rgba.b, 0, 255);\n  var alpha = fitIntoBounds(rgba.a, 0, 1);\n  return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};","map":{"version":3,"sources":["../../../../src/colors/utils/color-parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { parseColor as parse, Color } from '@progress/kendo-drawing';\nimport { isPresent, fitIntoBounds } from './misc';\n/**\n * @hidden\n *\n * Returns the hex or RGBA string representation of the color.\n */\nexport var parseColor = function (value, format, safe) {\n    if (safe === void 0) { safe = true; }\n    var allowedFormats = ['hex', 'rgba']; // TODO: constant?\n    // Angular supports third type: name : const allowedFormats: Array<string> = ['hex', 'rgba', 'name'];\n    if (allowedFormats.indexOf(format) === -1) {\n        throw new Error(\"Unsupported color output format '\" + format + \"'. The available options are 'hex' or 'rgba'.\");\n    }\n    if (!isPresent(value)) {\n        return;\n    }\n    var parsedColor = parse(value.trim(), safe);\n    if (!isPresent(parsedColor)) {\n        return;\n    }\n    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns an HSV object representation of the color string.\n */\nexport var getHSV = function (value, safe) {\n    if (safe === void 0) { safe = true; }\n    var parsed = parse(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toHSV();\n};\n/**\n * @hidden\n *\n * Returns an RGBA object representation of the color string.\n */\nexport var getRGBA = function (value, safe) {\n    if (safe === void 0) { safe = true; }\n    var parsed = parse(value, safe);\n    if (!isPresent(parsed)) {\n        return {};\n    }\n    return parsed.toBytes();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nexport var getColorFromHSV = function (hsva) {\n    var hue = fitIntoBounds(hsva.h, 0, 359.9);\n    var saturation = fitIntoBounds(hsva.s, 0, 1);\n    var value = fitIntoBounds(hsva.v, 0, 1);\n    var alpha = fitIntoBounds(hsva.a, 0, 1);\n    return Color.fromHSV(hue, saturation, value, alpha).toCssRgba();\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color based on the `hue` and\n * assuming the `value`, `saturation`, and `alpha` have a value of `1`.\n */\nexport var getColorFromHue = function (hue) {\n    return getColorFromHSV({ h: hue, s: 1, v: 1, a: 1 });\n};\n/**\n * @hidden\n *\n * Returns the RGBA string representation of the color.\n */\nexport var getColorFromRGBA = function (rgba) {\n    var red = fitIntoBounds(rgba.r, 0, 255);\n    var green = fitIntoBounds(rgba.g, 0, 255);\n    var blue = fitIntoBounds(rgba.b, 0, 255);\n    var alpha = fitIntoBounds(rgba.a, 0, 1);\n    return Color.fromBytes(red, green, blue, alpha).toCssRgba();\n};\n//# sourceMappingURL=color-parser.js.map"]},"metadata":{},"sourceType":"module"}