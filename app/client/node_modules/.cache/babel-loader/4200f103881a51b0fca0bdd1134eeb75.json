{"ast":null,"code":"import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap } from './../utils';\n/**\n * @hidden\n */\n\nvar KendoDate =\n/** @class */\nfunction () {\n  function KendoDate(intlProvider, formatPlaceholder, format) {\n    this.year = true;\n    this.month = true;\n    this.date = true;\n    this.hours = true;\n    this.minutes = true;\n    this.seconds = true;\n    this.milliseconds = true;\n    this.leadingZero = null;\n    this.typedMonthPart = '';\n    this.knownParts = 'adHhmMsEy';\n    this.symbols = {\n      'E': 'E',\n      'H': 'H',\n      'M': 'M',\n      'a': 'a',\n      'd': 'd',\n      'h': 'h',\n      'm': 'm',\n      's': 's',\n      'y': 'y'\n    };\n    this._value = getDate(new Date());\n    this.intlProvider = intlProvider;\n    this.formatPlaceholder = formatPlaceholder;\n    this.format = format;\n    this.monthNames = this.allFormatedMonths();\n  }\n\n  Object.defineProperty(KendoDate.prototype, \"intl\", {\n    get: function () {\n      return this.intlProvider();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(KendoDate.prototype, \"value\", {\n    get: function () {\n      return this._value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  KendoDate.prototype.setValue = function (value) {\n    if (!value) {\n      this._value = getDate(new Date());\n      this.modifyExisting(false);\n    } else if (!isEqual(value, this._value)) {\n      this._value = cloneDate(value);\n      this.modifyExisting(true);\n    }\n  };\n\n  KendoDate.prototype.hasValue = function () {\n    var _this = this;\n\n    var pred = function (a, p) {\n      return a || p.type !== 'literal' && p.type !== 'dayperiod' && _this.getExisting(p.pattern[0]);\n    };\n\n    return this.intl.splitDateFormat(this.format).reduce(pred, false);\n  };\n\n  KendoDate.prototype.getDateObject = function () {\n    for (var i = 0; i < this.knownParts.length; i++) {\n      if (!this.getExisting(this.knownParts[i])) {\n        return null;\n      }\n    }\n\n    return cloneDate(this.value);\n  };\n\n  KendoDate.prototype.getTextAndFormat = function () {\n    return this.merge(this.intl.formatDate(this.value, this.format), this.dateFormatString(this.value, this.format));\n  };\n\n  KendoDate.prototype.modifyExisting = function (value) {\n    var sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n\n    for (var i = 0; i < sampleFormat.length; i++) {\n      this.setExisting(sampleFormat[i], value);\n    }\n  };\n\n  KendoDate.prototype.getExisting = function (symbol) {\n    switch (symbol) {\n      case 'y':\n        return this.year;\n\n      case 'M':\n      case 'L':\n        return this.month;\n\n      case 'd':\n        return this.date;\n\n      case 'E':\n        return this.date && this.month && this.year;\n\n      case 'h':\n      case 'H':\n        return this.hours;\n\n      case 'm':\n        return this.minutes;\n\n      case 's':\n        return this.seconds;\n\n      default:\n        return true;\n    }\n  };\n\n  KendoDate.prototype.setExisting = function (symbol, value) {\n    switch (symbol) {\n      case 'y':\n        // allow 2/29 dates\n        this.year = value;\n\n        if (value === false) {\n          this._value.setFullYear(2000);\n        }\n\n        break;\n\n      case 'M':\n        // make sure you can type 31 in the day part\n        this.month = value;\n\n        if (value === false) {\n          this._value.setMonth(0);\n        }\n\n        break;\n\n      case 'd':\n        this.date = value;\n        break;\n\n      case 'h':\n      case 'H':\n        this.hours = value;\n        break;\n\n      case 'm':\n        this.minutes = value;\n        break;\n\n      case 's':\n        this.seconds = value;\n        break;\n\n      default:\n        return;\n    }\n  };\n\n  KendoDate.prototype.modifyPart = function (symbol, offset) {\n    var newValue = cloneDate(this.value);\n\n    switch (symbol) {\n      case 'y':\n        newValue.setFullYear(newValue.getFullYear() + offset);\n        break;\n\n      case 'M':\n        newValue = addMonths(this.value, offset);\n        break;\n\n      case 'd':\n      case 'E':\n        newValue.setDate(newValue.getDate() + offset);\n        break;\n\n      case 'h':\n      case 'H':\n        newValue.setHours(newValue.getHours() + offset);\n        break;\n\n      case 'm':\n        newValue.setMinutes(newValue.getMinutes() + offset);\n        break;\n\n      case 's':\n        newValue.setSeconds(newValue.getSeconds() + offset);\n        break;\n\n      case 'a':\n        newValue.setHours(newValue.getHours() + 12 * offset);\n        break;\n\n      default:\n        break;\n    }\n\n    this.setExisting(symbol, true);\n    this._value = newValue;\n  };\n\n  KendoDate.prototype.parsePart = function (symbol, currentChar) {\n    var _a;\n\n    this.resetLeadingZero();\n\n    if (!currentChar) {\n      this.setExisting(symbol, false);\n      return {\n        value: null\n      };\n    }\n\n    var baseDate = this.intl.formatDate(this.value, this.format);\n    var dateParts = this.dateFormatString(this.value, this.format);\n    var baseFormat = dateParts.symbols;\n    var replaced = false;\n    var prefix = '';\n    var current = '';\n    var suffix = '';\n\n    for (var i = 0; i < baseDate.length; i++) {\n      if (baseFormat[i] === symbol) {\n        current += this.getExisting(symbol) ? baseDate[i] : '0';\n        replaced = true;\n      } else if (!replaced) {\n        prefix += baseDate[i];\n      } else {\n        suffix += baseDate[i];\n      }\n    }\n\n    var parsedDate = null;\n    var month = this.matchMonth(currentChar);\n\n    while (current.length > 0 && current.charAt(0) === '0') {\n      current = current.slice(1);\n    }\n\n    if (current.length >= 4) {\n      current = '';\n    }\n\n    for (var i = 0; i < 2; i++) {\n      var middle = current + currentChar;\n      var middleNumber = parseInt(middle, 10);\n      parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n\n      if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n        if (symbol === 'M' && !month) {\n          var monthNumber = middleNumber - 1;\n\n          if (monthNumber > -1 && monthNumber < 12) {\n            parsedDate = cloneDate(this.value);\n            parsedDate.setMonth(monthNumber);\n\n            if (parsedDate.getMonth() !== monthNumber) {\n              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n            }\n          }\n        }\n\n        if (symbol === 'y') {\n          parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n\n          if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n          }\n        }\n      }\n\n      if (parsedDate) {\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value\n        };\n      }\n\n      current = '';\n    }\n\n    if (month) {\n      parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n\n      if (parsedDate) {\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        return {\n          value: this.value\n        };\n      }\n    }\n\n    if (currentChar === '0') {\n      this.leadingZero = !this.isAbbrMonth(dateParts.partMap, symbol) ? (_a = {}, _a[symbol] = true, _a) : null;\n      this.setExisting(symbol, false);\n    }\n\n    return {\n      value: null\n    };\n  };\n\n  KendoDate.prototype.symbolMap = function (symbol) {\n    return this.intl.splitDateFormat(this.format).reduce(dateSymbolMap, {})[symbol];\n  };\n\n  KendoDate.prototype.resetLeadingZero = function () {\n    var hasLeadingZero = this.leadingZero !== null;\n    this.leadingZero = null;\n    return hasLeadingZero;\n  };\n\n  KendoDate.prototype.isAbbrMonth = function (parts, symbol) {\n    var pattern = this.partPattern(parts, symbol);\n    return pattern.type === 'month' && pattern.names;\n  };\n\n  KendoDate.prototype.partPattern = function (parts, symbol) {\n    return parts.filter(function (part) {\n      return part.pattern.indexOf(symbol) !== -1;\n    })[0];\n  };\n\n  KendoDate.prototype.matchMonth = function (typedChar) {\n    this.typedMonthPart += typedChar.toLowerCase();\n\n    if (this.monthNames.length === 0) {\n      return '';\n    }\n\n    while (this.typedMonthPart.length > 0) {\n      for (var i = 0; i < this.monthNames.length; i++) {\n        if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n          return this.monthNames[i];\n        }\n      }\n\n      var monthAsNum = parseInt(this.typedMonthPart, 10);\n      /* ensure they exact match */\n\n      if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {\n        return this.monthNames[monthAsNum - 1];\n      }\n\n      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n    }\n\n    return '';\n  };\n\n  KendoDate.prototype.allFormatedMonths = function () {\n    var dateFormatParts = this.intl.splitDateFormat(this.format);\n\n    for (var i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(dateFormatParts[i].names);\n      }\n    }\n\n    return [];\n  };\n\n  KendoDate.prototype.dateFormatString = function (date, format) {\n    var dateFormatParts = this.intl.splitDateFormat(format);\n    var parts = [];\n    var partMap = [];\n\n    for (var i = 0; i < dateFormatParts.length; i++) {\n      var partLength = this.intl.formatDate(date, {\n        pattern: dateFormatParts[i].pattern\n      }).length;\n\n      while (partLength > 0) {\n        parts.push(this.symbols[dateFormatParts[i].pattern[0]] || '_');\n        partMap.push(dateFormatParts[i]);\n        partLength--;\n      }\n    }\n\n    var returnValue = new Mask();\n    returnValue.symbols = parts.join('');\n    returnValue.partMap = partMap;\n    return returnValue;\n  };\n\n  KendoDate.prototype.merge = function (text, mask) {\n    // Important: right to left.\n    var resultText = '';\n    var resultFormat = '';\n    var format = mask.symbols;\n\n    for (var r = format.length - 1; r >= 0; r--) {\n      if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n        resultText = text[r] + resultText;\n        resultFormat = format[r] + resultFormat;\n      } else {\n        var currentSymbol = format[r];\n\n        while (r >= 0 && currentSymbol === format[r]) {\n          r--;\n        }\n\n        r++;\n\n        if (this.leadingZero && this.leadingZero[currentSymbol]) {\n          resultText = '0' + resultText;\n        } else {\n          resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n        }\n\n        while (resultFormat.length < resultText.length) {\n          resultFormat = format[r] + resultFormat;\n        }\n      }\n    }\n\n    return {\n      text: resultText,\n      format: resultFormat\n    };\n  };\n\n  KendoDate.prototype.dateFieldName = function (part) {\n    var formatPlaceholder = this.formatPlaceholder || 'wide';\n\n    if (formatPlaceholder[part.type]) {\n      return formatPlaceholder[part.type];\n    }\n\n    if (formatPlaceholder === 'formatPattern') {\n      return part.pattern;\n    }\n\n    return this.intl.dateFieldName(Object.assign(part, {\n      nameType: formatPlaceholder\n    }));\n  };\n\n  return KendoDate;\n}();\n\nexport { KendoDate };","map":{"version":3,"sources":["../../../../src/dateinput/models/kendo-date.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap } from './../utils';\n/**\n * @hidden\n */\nvar KendoDate = /** @class */ (function () {\n    function KendoDate(intlProvider, formatPlaceholder, format) {\n        this.year = true;\n        this.month = true;\n        this.date = true;\n        this.hours = true;\n        this.minutes = true;\n        this.seconds = true;\n        this.milliseconds = true;\n        this.leadingZero = null;\n        this.typedMonthPart = '';\n        this.knownParts = 'adHhmMsEy';\n        this.symbols = {\n            'E': 'E',\n            'H': 'H',\n            'M': 'M',\n            'a': 'a',\n            'd': 'd',\n            'h': 'h',\n            'm': 'm',\n            's': 's',\n            'y': 'y'\n        };\n        this._value = getDate(new Date());\n        this.intlProvider = intlProvider;\n        this.formatPlaceholder = formatPlaceholder;\n        this.format = format;\n        this.monthNames = this.allFormatedMonths();\n    }\n    Object.defineProperty(KendoDate.prototype, \"intl\", {\n        get: function () {\n            return this.intlProvider();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(KendoDate.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    KendoDate.prototype.setValue = function (value) {\n        if (!value) {\n            this._value = getDate(new Date());\n            this.modifyExisting(false);\n        }\n        else if (!isEqual(value, this._value)) {\n            this._value = cloneDate(value);\n            this.modifyExisting(true);\n        }\n    };\n    KendoDate.prototype.hasValue = function () {\n        var _this = this;\n        var pred = function (a, p) { return a || p.type !== 'literal' && p.type !== 'dayperiod' && _this.getExisting(p.pattern[0]); };\n        return this.intl.splitDateFormat(this.format).reduce(pred, false);\n    };\n    KendoDate.prototype.getDateObject = function () {\n        for (var i = 0; i < this.knownParts.length; i++) {\n            if (!this.getExisting(this.knownParts[i])) {\n                return null;\n            }\n        }\n        return cloneDate(this.value);\n    };\n    KendoDate.prototype.getTextAndFormat = function () {\n        return this.merge(this.intl.formatDate(this.value, this.format), this.dateFormatString(this.value, this.format));\n    };\n    KendoDate.prototype.modifyExisting = function (value) {\n        var sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n        for (var i = 0; i < sampleFormat.length; i++) {\n            this.setExisting(sampleFormat[i], value);\n        }\n    };\n    KendoDate.prototype.getExisting = function (symbol) {\n        switch (symbol) {\n            case 'y': return this.year;\n            case 'M':\n            case 'L': return this.month;\n            case 'd': return this.date;\n            case 'E': return this.date && this.month && this.year;\n            case 'h':\n            case 'H': return this.hours;\n            case 'm': return this.minutes;\n            case 's': return this.seconds;\n            default: return true;\n        }\n    };\n    KendoDate.prototype.setExisting = function (symbol, value) {\n        switch (symbol) {\n            case 'y':\n                // allow 2/29 dates\n                this.year = value;\n                if (value === false) {\n                    this._value.setFullYear(2000);\n                }\n                break;\n            case 'M':\n                // make sure you can type 31 in the day part\n                this.month = value;\n                if (value === false) {\n                    this._value.setMonth(0);\n                }\n                break;\n            case 'd':\n                this.date = value;\n                break;\n            case 'h':\n            case 'H':\n                this.hours = value;\n                break;\n            case 'm':\n                this.minutes = value;\n                break;\n            case 's':\n                this.seconds = value;\n                break;\n            default: return;\n        }\n    };\n    KendoDate.prototype.modifyPart = function (symbol, offset) {\n        var newValue = cloneDate(this.value);\n        switch (symbol) {\n            case 'y':\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n            case 'M':\n                newValue = addMonths(this.value, offset);\n                break;\n            case 'd':\n            case 'E':\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n            case 'h':\n            case 'H':\n                newValue.setHours(newValue.getHours() + offset);\n                break;\n            case 'm':\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                break;\n            case 's':\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                break;\n            case 'a':\n                newValue.setHours(newValue.getHours() + (12 * offset));\n                break;\n            default: break;\n        }\n        this.setExisting(symbol, true);\n        this._value = newValue;\n    };\n    KendoDate.prototype.parsePart = function (symbol, currentChar) {\n        var _a;\n        this.resetLeadingZero();\n        if (!currentChar) {\n            this.setExisting(symbol, false);\n            return { value: null };\n        }\n        var baseDate = this.intl.formatDate(this.value, this.format);\n        var dateParts = this.dateFormatString(this.value, this.format);\n        var baseFormat = dateParts.symbols;\n        var replaced = false;\n        var prefix = '';\n        var current = '';\n        var suffix = '';\n        for (var i = 0; i < baseDate.length; i++) {\n            if (baseFormat[i] === symbol) {\n                current += this.getExisting(symbol) ? baseDate[i] : '0';\n                replaced = true;\n            }\n            else if (!replaced) {\n                prefix += baseDate[i];\n            }\n            else {\n                suffix += baseDate[i];\n            }\n        }\n        var parsedDate = null;\n        var month = this.matchMonth(currentChar);\n        while (current.length > 0 && current.charAt(0) === '0') {\n            current = current.slice(1);\n        }\n        if (current.length >= 4) {\n            current = '';\n        }\n        for (var i = 0; i < 2; i++) {\n            var middle = current + currentChar;\n            var middleNumber = parseInt(middle, 10);\n            parsedDate = this.intl.parseDate(prefix + middle + suffix, this.format);\n            if (!parsedDate && !isNaN(middleNumber) && !isNaN(parseInt(currentChar, 10))) {\n                if (symbol === 'M' && !month) {\n                    var monthNumber = middleNumber - 1;\n                    if (monthNumber > -1 && monthNumber < 12) {\n                        parsedDate = cloneDate(this.value);\n                        parsedDate.setMonth(monthNumber);\n                        if (parsedDate.getMonth() !== monthNumber) {\n                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                        }\n                    }\n                }\n                if (symbol === 'y') {\n                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n                    if (this.date && parsedDate.getDate() !== this.value.getDate()) {\n                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                    }\n                }\n            }\n            if (parsedDate) {\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                return { value: this.value };\n            }\n            current = '';\n        }\n        if (month) {\n            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format);\n            if (parsedDate) {\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                return { value: this.value };\n            }\n        }\n        if (currentChar === '0') {\n            this.leadingZero = !this.isAbbrMonth(dateParts.partMap, symbol) ? (_a = {}, _a[symbol] = true, _a) : null;\n            this.setExisting(symbol, false);\n        }\n        return { value: null };\n    };\n    KendoDate.prototype.symbolMap = function (symbol) {\n        return this.intl.splitDateFormat(this.format).reduce(dateSymbolMap, {})[symbol];\n    };\n    KendoDate.prototype.resetLeadingZero = function () {\n        var hasLeadingZero = this.leadingZero !== null;\n        this.leadingZero = null;\n        return hasLeadingZero;\n    };\n    KendoDate.prototype.isAbbrMonth = function (parts, symbol) {\n        var pattern = this.partPattern(parts, symbol);\n        return pattern.type === 'month' && pattern.names;\n    };\n    KendoDate.prototype.partPattern = function (parts, symbol) {\n        return parts.filter(function (part) { return part.pattern.indexOf(symbol) !== -1; })[0];\n    };\n    KendoDate.prototype.matchMonth = function (typedChar) {\n        this.typedMonthPart += typedChar.toLowerCase();\n        if (this.monthNames.length === 0) {\n            return '';\n        }\n        while (this.typedMonthPart.length > 0) {\n            for (var i = 0; i < this.monthNames.length; i++) {\n                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n                    return this.monthNames[i];\n                }\n            }\n            var monthAsNum = parseInt(this.typedMonthPart, 10);\n            /* ensure they exact match */\n            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {\n                return this.monthNames[monthAsNum - 1];\n            }\n            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n        }\n        return '';\n    };\n    KendoDate.prototype.allFormatedMonths = function () {\n        var dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (var i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(dateFormatParts[i].names);\n            }\n        }\n        return [];\n    };\n    KendoDate.prototype.dateFormatString = function (date, format) {\n        var dateFormatParts = this.intl.splitDateFormat(format);\n        var parts = [];\n        var partMap = [];\n        for (var i = 0; i < dateFormatParts.length; i++) {\n            var partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }).length;\n            while (partLength > 0) {\n                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || '_');\n                partMap.push(dateFormatParts[i]);\n                partLength--;\n            }\n        }\n        var returnValue = new Mask();\n        returnValue.symbols = parts.join('');\n        returnValue.partMap = partMap;\n        return returnValue;\n    };\n    KendoDate.prototype.merge = function (text, mask) {\n        // Important: right to left.\n        var resultText = '';\n        var resultFormat = '';\n        var format = mask.symbols;\n        for (var r = format.length - 1; r >= 0; r--) {\n            if (this.knownParts.indexOf(format[r]) === -1 || this.getExisting(format[r])) {\n                resultText = text[r] + resultText;\n                resultFormat = format[r] + resultFormat;\n            }\n            else {\n                var currentSymbol = format[r];\n                while (r >= 0 && currentSymbol === format[r]) {\n                    r--;\n                }\n                r++;\n                if (this.leadingZero && this.leadingZero[currentSymbol]) {\n                    resultText = '0' + resultText;\n                }\n                else {\n                    resultText = this.dateFieldName(mask.partMap[r]) + resultText;\n                }\n                while (resultFormat.length < resultText.length) {\n                    resultFormat = format[r] + resultFormat;\n                }\n            }\n        }\n        return { text: resultText, format: resultFormat };\n    };\n    KendoDate.prototype.dateFieldName = function (part) {\n        var formatPlaceholder = this.formatPlaceholder || 'wide';\n        if (formatPlaceholder[part.type]) {\n            return formatPlaceholder[part.type];\n        }\n        if (formatPlaceholder === 'formatPattern') {\n            return part.pattern;\n        }\n        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));\n    };\n    return KendoDate;\n}());\nexport { KendoDate };\n//# sourceMappingURL=kendo-date.js.map"]},"metadata":{},"sourceType":"module"}