var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Button } from './../main';
import { classNames, guid, Keys } from '@progress/kendo-react-common';
import { dispatchEvent } from '@progress/kendo-react-common';
import ButtonItem from './ButtonItem';
import SplitButtonItem from './SplitButtonItem';
import navigation from './utils/navigation';
import { Popup } from '@progress/kendo-react-popup';
import { getAnchorAlign, getPopupAlign } from './utils/popup';
/**
 * Represents the [KendoReact SplitButton component]({% slug overview_splitbutton %}).
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *    render() {
 *        return (
 *            <SplitButton text="Act">
 *                <SplitButtonItem text="Item1" />
 *                <SplitButtonItem text="Item2" />
 *                <SplitButtonItem text="Item3" />
 *            </SplitButton>
 *        );
 *    }
 * }
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
var SplitButton = /** @class */ (function (_super) {
    __extends(SplitButton, _super);
    function SplitButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * @hidden
         */
        _this.state = {
            focused: false,
            focusedIndex: -1,
            opened: false
        };
        _this.wrapper = null;
        _this.mainButton = null;
        _this.guid = guid();
        _this.buttonsData = [];
        _this.onKeyDown = function (event) {
            var _a = _this.state, opened = _a.opened, focusedIndex = _a.focusedIndex;
            if (event.altKey) {
                if (!opened && event.keyCode === Keys.down) {
                    _this.dispatchPopupEvent(event, true);
                    _this.setState({ focusedIndex: 0, opened: true });
                }
                else if (opened && event.keyCode === Keys.up) {
                    _this.dispatchPopupEvent(event, false);
                    _this.setState({ focusedIndex: -1, opened: false });
                }
                return;
            }
            var newState = undefined;
            if (event.keyCode === Keys.enter || event.keyCode === Keys.space) {
                // Prevent default because otherwise when an item is selected
                // click on the default button gets emitted which opens the popup again.
                event.preventDefault();
                _this.dispatchClickEvent(event, focusedIndex);
                if (focusedIndex >= 0) {
                    newState = {
                        focusedIndex: opened ? -1 : 0,
                        opened: !opened
                    };
                    _this.dispatchPopupEvent(event, newState.opened);
                }
            }
            else if (opened && event.keyCode === Keys.esc) {
                newState = {
                    focusedIndex: -1,
                    opened: false
                };
                _this.dispatchPopupEvent(event, newState.opened);
            }
            if (opened) {
                var newFocused = navigation(focusedIndex, event.keyCode, event.altKey, _this.buttonsData.length);
                if (newFocused !== focusedIndex) {
                    newState = newState || {};
                    newState.focusedIndex = newFocused;
                }
                var arrowKey = event.keyCode === Keys.up || event.keyCode === Keys.down ||
                    event.keyCode === Keys.left || event.keyCode === Keys.right;
                if (!event.altKey && arrowKey) {
                    // Needed to notify the parent listeners that event is handled.
                    event.preventDefault();
                }
            }
            if (newState) {
                _this.setState(newState);
            }
        };
        _this.onFocus = function (event) {
            dispatchEvent(_this.props.onFocus, event, _this, undefined);
            _this.setState({ focused: true, focusedIndex: -1 });
        };
        _this.onItemClick = function (event, clickedItemIndex) {
            var opened = _this.state.opened;
            if (opened) {
                _this.setState({ focusedIndex: 0, opened: false });
            }
            _this.dispatchClickEvent(event, clickedItemIndex);
            if (opened) {
                _this.dispatchPopupEvent(event, false);
            }
        };
        _this.onBlur = function (event) {
            _this.setState({
                focused: false,
                focusedIndex: -1,
                opened: false
            });
            dispatchEvent(_this.props.onBlur, event, _this, undefined);
            if (_this.state.opened) {
                _this.dispatchPopupEvent(event, false);
            }
        };
        _this.onSplitPartClick = function (event) {
            if (_this.buttonsData.length) {
                var opened = _this.state.opened;
                var toOpen = !opened;
                _this.dispatchPopupEvent(event, toOpen);
                _this.setState({
                    focusedIndex: toOpen ? 0 : -1,
                    opened: toOpen,
                    focused: true
                });
            }
        };
        _this.onDownSplitPart = function (event) {
            event.preventDefault();
            if (_this.element && document.activeElement !== _this.element) {
                _this.element.focus();
            }
        };
        _this.onItemDown = function (event) {
            if (document.activeElement === _this.element) {
                event.preventDefault();
            }
        };
        _this.dispatchPopupEvent = function (dispatchedEvent, open) {
            dispatchEvent(open ? _this.props.onOpen : _this.props.onClose, dispatchedEvent, _this, undefined);
        };
        return _this;
    }
    /**
     * @hidden
     */
    SplitButton.prototype.render = function () {
        var _this = this;
        this.buttonsData = this.props.items ||
            React.Children.toArray(this.props.children)
                .filter(function (child) { return child && child.type === SplitButtonItem; })
                .map(function (child) { return child.props; });
        var rtl = this.isRtl();
        var dir = rtl ? 'rtl' : undefined;
        var _a = this.props, tabIndex = _a.tabIndex, disabled = _a.disabled;
        var focusedIndex = this.state.focusedIndex;
        return (React.createElement("div", { className: classNames('k-widget', 'k-split-button', 'k-button-group', this.props.className, {
                'k-state-focused': this.state.focused
            }), onKeyDown: this.onKeyDown, onFocus: this.onFocus, onBlur: this.onBlur, dir: dir, ref: function (el) { return _this.wrapper = el; } },
            React.createElement(Button, { onClick: function (event) { return _this.onItemClick(event, -1); }, disabled: disabled || undefined, tabIndex: tabIndex, accessKey: this.props.accessKey, className: this.props.buttonClass, icon: this.props.icon, iconClass: this.props.iconClass, imageUrl: this.props.imageUrl, look: this.props.look, dir: dir, ref: function (el) { return _this.mainButton = el && el.element; }, type: "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": this.state.opened, "aria-label": this.props.text + " splitbutton", "aria-owns": this.guid, "aria-activedescendant": focusedIndex >= 0 ? this.guid + "-" + focusedIndex : undefined }, this.props.text),
            React.createElement(Button, { icon: "arrow-s", disabled: disabled || undefined, tabIndex: -1, look: this.props.look, onClick: this.onSplitPartClick, onMouseDown: this.onDownSplitPart, onPointerDown: this.onDownSplitPart, dir: dir, "aria-label": "menu toggling button" }),
            this.renderPopup(rtl)));
    };
    /**
     * @hidden
     */
    SplitButton.prototype.componentDidMount = function () {
        if (this.props.dir === undefined && this.isRtl()) {
            this.forceUpdate();
        }
    };
    Object.defineProperty(SplitButton.prototype, "element", {
        /**
         * The DOM element of main button.
         */
        get: function () {
            return this.mainButton;
        },
        enumerable: true,
        configurable: true
    });
    SplitButton.prototype.dispatchClickEvent = function (dispatchedEvent, clickedItemIndex) {
        if (!this.isItemDisabled(clickedItemIndex)) {
            if (clickedItemIndex === -1) {
                dispatchEvent(this.props.onButtonClick, dispatchedEvent, this, undefined);
            }
            else {
                dispatchEvent(this.props.onItemClick, dispatchedEvent, this, {
                    item: this.buttonsData[clickedItemIndex],
                    itemIndex: clickedItemIndex
                });
            }
        }
    };
    SplitButton.prototype.renderPopup = function (rtl) {
        var _a = this.props.popupSettings, popupSettings = _a === void 0 ? {} : _a;
        return (React.createElement(Popup, { anchor: this.wrapper || undefined, show: this.state.opened, animate: popupSettings.animate, popupClass: classNames('k-list-container k-reset k-group', popupSettings.popupClass), anchorAlign: popupSettings.anchorAlign || getAnchorAlign(rtl), popupAlign: popupSettings.popupAlign || getPopupAlign(rtl), style: rtl ? { direction: 'rtl' } : undefined },
            React.createElement("ul", { className: "k-list k-reset", role: "menu", id: this.guid }, this.renderChildItems())));
    };
    SplitButton.prototype.renderChildItems = function () {
        var _this = this;
        var _a = this.props, itemRender = _a.itemRender, textField = _a.textField;
        return this.buttonsData.length > 0 ? (this.buttonsData.map(function (item, index) {
            return (React.createElement(ButtonItem, { dataItem: item, textField: textField, focused: _this.state.focusedIndex === index, onClick: _this.onItemClick, onDown: _this.onItemDown, itemRender: itemRender, key: index, index: index, id: _this.guid + "-" + index }));
        })) : null;
    };
    SplitButton.prototype.isItemDisabled = function (index) {
        return this.buttonsData[index] ? this.buttonsData[index].disabled : this.props.disabled;
    };
    SplitButton.prototype.isRtl = function () {
        return this.props.dir !== undefined ? this.props.dir === 'rtl' :
            !!this.wrapper && getComputedStyle(this.wrapper).direction === 'rtl';
    };
    /**
     * @hidden
     */
    SplitButton.propTypes = {
        accessKey: PropTypes.string,
        onButtonClick: PropTypes.func,
        onFocus: PropTypes.func,
        onBlur: PropTypes.func,
        onItemClick: PropTypes.func,
        onOpen: PropTypes.func,
        onClose: PropTypes.func,
        text: PropTypes.string,
        items: PropTypes.arrayOf(PropTypes.any),
        textField: PropTypes.string,
        tabIndex: PropTypes.number,
        disabled: PropTypes.bool,
        icon: PropTypes.string,
        iconClass: PropTypes.string,
        imageUrl: PropTypes.string,
        popupSettings: PropTypes.object,
        itemRender: PropTypes.any,
        look: PropTypes.string,
        className: PropTypes.string,
        buttonClass: PropTypes.string,
        dir: PropTypes.string
    };
    return SplitButton;
}(React.Component));
export default SplitButton;
//# sourceMappingURL=SplitButton.js.map