var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { guid, classNames } from '@progress/kendo-react-common';
import { FloatingLabel } from '@progress/kendo-react-labels';
var Input = /** @class */ (function (_super) {
    __extends(Input, _super);
    function Input(props) {
        var _this = _super.call(this, props) || this;
        _this._inputId = guid();
        /**
         * @hidden
         */
        _this.focus = function () {
            if (_this._input) {
                _this._input.focus();
            }
        };
        _this.isInvalid = function (state) {
            var result = false;
            for (var prop in state) {
                if (state.hasOwnProperty(prop)) {
                    result = result || state[prop];
                }
            }
            return result;
        };
        /**
         * @hidden
         */
        _this.setValidity = function () {
            if (_this._input && _this._input.setCustomValidity) {
                _this.validity.valid || !_this.validityStyles
                    ? _this._input.classList.remove('k-state-invalid')
                    : _this._input.classList.add('k-state-invalid');
                _this._input.setCustomValidity(_this.validity.valid
                    ? ''
                    : _this.props.validationMessage || '');
            }
        };
        _this.handleChange = function (event) {
            _this.setState({
                value: event.target.value
            });
            _this.valueDuringOnChange = event.target.value;
            if (_this.props.onChange) {
                _this.props.onChange.call(undefined, {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    value: event.target.value,
                    target: _this
                });
            }
            _this.valueDuringOnChange = undefined;
        };
        /**
         * @hidden
         */
        _this.handleAutoFill = function (e) {
            if (e.animationName === 'autoFillStart') {
                var parent_1 = e.target.parentNode;
                if (parent_1 && parent_1.classList.contains('k-state-empty')) {
                    parent_1.classList.remove('k-state-empty');
                }
            }
        };
        _this.state = {
            value: _this.props.defaultValue || Input.defaultProps.defaultValue
        };
        return _this;
    }
    Object.defineProperty(Input.prototype, "element", {
        /**
         * Gets the native input element of the Input component.
         */
        get: function () {
            return this._input;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "value", {
        /**
         * Gets the value of the Input.
         */
        get: function () {
            return this.valueDuringOnChange !== undefined
                ? this.valueDuringOnChange
                : this.props.value !== undefined
                    ? this.props.value
                    : this.state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "name", {
        /**
         * Gets the `name` property of the Input.
         */
        get: function () {
            return this.props.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "validity", {
        /**
         * Represents the validity state into which the Input is set.
         */
        get: function () {
            var result = {
                badInput: this._input ? this._input.validity.badInput : false,
                patternMismatch: this._input
                    ? this._input.validity.patternMismatch
                    : false,
                rangeOverflow: this._input ? this._input.validity.rangeOverflow : false,
                rangeUnderflow: this._input ? this._input.validity.rangeUnderflow : false,
                stepMismatch: this._input ? this._input.validity.stepMismatch : false,
                tooLong: this._input ? this._input.validity.tooLong : false,
                typeMismatch: this._input ? this._input.validity.typeMismatch : false,
                valueMissing: this._input ? this._input.validity.valueMissing : false
            };
            return __assign({}, result, { customError: this.props.validationMessage !== undefined, valid: this.props.valid !== undefined
                    ? this.props.valid
                    : this._input
                        ? !this.isInvalid(result)
                        : true });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Input.prototype, "validityStyles", {
        /**
         * @hidden
         */
        get: function () {
            return this.props.validityStyles !== undefined
                ? this.props.validityStyles
                : Input.defaultProps.validityStyles;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    Input.prototype.componentDidMount = function () {
        this.forceUpdate();
    };
    /**
     * @hidden
     */
    Input.prototype.componentDidUpdate = function () {
        this.setValidity();
    };
    /**
     * @hidden
     */
    Input.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, label = _a.label, id = _a.id, validationMessage = _a.validationMessage, defaultValue = _a.defaultValue, valid = _a.valid, 
        // Removed to support direct use in Form Field component
        visited = _a.visited, touched = _a.touched, modified = _a.modified, ariaLabelledBy = _a.ariaLabelledBy, ariaDescribedBy = _a.ariaDescribedBy, validityStyles = _a.validityStyles, style = _a.style, props = __rest(_a, ["className", "label", "id", "validationMessage", "defaultValue", "valid", "visited", "touched", "modified", "ariaLabelledBy", "ariaDescribedBy", "validityStyles", "style"]);
        var inputId = id || this._inputId;
        var isValid = !this.validityStyles || this.validity.valid;
        var inputClassName = classNames(className, 'k-textbox');
        var textbox = (React.createElement("input", __assign({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, props, { style: !label
                ? style
                : undefined, value: this.value, id: inputId, className: inputClassName, onChange: this.handleChange, onAnimationStart: this.handleAutoFill, ref: function (el) { _this._input = el; } })));
        return label ?
            (React.createElement(FloatingLabel, { label: label, editorId: inputId, editorValue: String(this.value), editorValid: isValid, editorDisabled: props.disabled, editorPlaceholder: props.placeholder, children: textbox, style: style, dir: props.dir }))
            : textbox;
    };
    /**
     * @hidden
     */
    Input.propTypes = {
        label: PropTypes.string,
        validationMessage: PropTypes.string,
        required: PropTypes.bool,
        validate: PropTypes.bool,
        id: PropTypes.string,
        ariaLabelledBy: PropTypes.string,
        ariaDescribedBy: PropTypes.string
    };
    /**
     * @hidden
     */
    Input.defaultProps = {
        defaultValue: '',
        required: false,
        validityStyles: true
    };
    return Input;
}(React.Component));
export { Input };
//# sourceMappingURL=Input.js.map