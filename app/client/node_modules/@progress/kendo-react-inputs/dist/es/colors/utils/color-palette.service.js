import { isPresent } from './misc';
import { parseColor } from '@progress/kendo-drawing';
/**
 * @hidden
 */
var ColorPaletteService = /** @class */ (function () {
    function ColorPaletteService() {
        this.colorRows = [];
    }
    ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {
        this.colorRows = [];
        if (!(isPresent(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (var start = 0; start < palette.length; start += columns) {
            var row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    };
    ColorPaletteService.prototype.getCellCoordsFor = function (color) {
        var _this = this;
        if (!isPresent(color)) {
            return;
        }
        var parsedColor = color ? parseColor(color, true) : color;
        var colors = [color];
        if (isPresent(parsedColor)) {
            colors.push(parsedColor.toCss(), parsedColor.toCssRgba());
        }
        var _loop_1 = function (row) {
            var _loop_2 = function (col) {
                if (colors.some(function (c) { return c === _this.colorRows[row][col]; })) {
                    return { value: { row: row, col: col } };
                }
            };
            for (var col = 0; col < this_1.colorRows[row].length; col++) {
                var state_2 = _loop_2(col);
                if (typeof state_2 === "object")
                    return state_2;
            }
        };
        var this_1 = this;
        for (var row = 0; row < this.colorRows.length; row++) {
            var state_1 = _loop_1(row);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    ColorPaletteService.prototype.getColorAt = function (cellCoords) {
        if (!(isPresent(cellCoords) && isPresent(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    };
    ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {
        if (!(isPresent(current) && isPresent(current.row) && isPresent(current.col))) {
            return { row: 0, col: 0 };
        }
        var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row: row, col: col };
    };
    ColorPaletteService.prototype.clampIndex = function (index, max) {
        var minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    };
    return ColorPaletteService;
}());
export { ColorPaletteService };
//# sourceMappingURL=color-palette.service.js.map