var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { classNames, Keys, useDir, getTabIndex } from '@progress/kendo-react-common';
import { Picker } from './Picker';
import { ColorGradient } from './ColorGradient';
import { ColorPalette, DEFAULT_PRESET, DEFAULT_TILE_SIZE } from './ColorPalette';
/**
 * @hidden
 */
var DEFAULT_GRADIENT_SETTINGS = {
    opacity: true
};
/**
 * @hidden
 */
var DEFAULT_PALETTE_SETTINGS = {
    palette: DEFAULT_PRESET,
    tileSize: DEFAULT_TILE_SIZE
};
/**
 * @hidden
 */
var isControlled = function (prop) {
    return prop !== undefined;
};
/**
 * Represents the [KendoReact ColorPicker component]({% slug overview_colorpicker %}).
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *     render() {
 *         return <ColorPicker />;
 *     }
 * }
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
export var ColorPicker = React.forwardRef(function (props, target) {
    var popupSettings = props.popupSettings, gradientSettings = props.gradientSettings, paletteSettings = props.paletteSettings, valid = props.valid, disabled = props.disabled, tabIndex = props.tabIndex, view = props.view, icon = props.icon, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur;
    var focusableElementRef = React.useRef(null);
    var gradientRef = React.useRef(null);
    var paletteRef = React.useRef(null);
    var blurTimeoutRef = React.useRef();
    var buttonRef = React.useRef(null);
    var focusElement = React.useCallback(function () {
        if (focusableElementRef.current) {
            focusableElementRef.current.focus();
        }
    }, []);
    React.useImperativeHandle(target, function () { return ({
        // we agreed that each element will have focus method exposed
        element: focusableElementRef.current,
        actionElement: buttonRef.current,
        focus: focusElement
    }); });
    var _a = React.useState(false), focused = _a[0], setFocused = _a[1];
    var _b = React.useState(props.defaultValue), stateValue = _b[0], setStateValue = _b[1];
    var _c = React.useState(false), stateOpen = _c[0], setStateOpen = _c[1];
    var isValueControlled = isControlled(props.value);
    var isOpenControlled = isControlled(props.open);
    var value = isValueControlled ? props.value : stateValue;
    var open = isOpenControlled ? props.open : stateOpen;
    var setOpen = React.useCallback(function (nextOpen, isBlur) {
        if (!isOpenControlled) {
            if (!nextOpen && !isBlur && focusableElementRef && focusableElementRef.current) {
                focusableElementRef.current.focus();
            }
            setStateOpen(nextOpen);
        }
    }, [isOpenControlled]);
    var onKeyDownHandler = React.useCallback(function (event) {
        var altKey = event.altKey, keyCode = event.keyCode;
        if (keyCode === Keys.esc) {
            setOpen(false);
            return;
        }
        if (keyCode === Keys.enter && !isOpenControlled) {
            event.preventDefault();
            event.stopPropagation();
            setOpen(!open);
            return;
        }
        if (altKey && (keyCode === Keys.up || keyCode === Keys.down)) {
            event.preventDefault();
            event.stopPropagation();
            if (keyCode === Keys.up && focusableElementRef && focusableElementRef.current) {
                focusableElementRef.current.focus();
                setOpen(false);
            }
            if (keyCode === Keys.down) {
                setOpen(true);
            }
        }
    }, [open, isOpenControlled]);
    var onOpenHandler = React.useCallback(function () {
        // Skip content autofocus when in controlled mode
        if (!isOpenControlled) {
            if (gradientRef.current) {
                gradientRef.current.focus();
            }
            else if (paletteRef.current) {
                paletteRef.current.focus();
            }
        }
    }, [isOpenControlled]);
    var onClickHandler = React.useCallback(function () {
        setOpen(!open, true);
    }, [open]);
    var onFocusHandler = React.useCallback(function (event) {
        if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
            blurTimeoutRef.current = undefined;
            // case where moving back to input from popup
            // if (event.target === focusableElementRef.current) {
            // setOpen(false); // in this case we should focus input on keydown
            // }
        }
        else {
            setFocused(true);
        }
        if (onFocus) {
            onFocus.call(undefined, {
                nativeEvent: event.nativeEvent,
                syntheticEvent: event
            });
        }
    }, [onFocus]);
    var onBlurTimeout = React.useCallback(function () {
        setOpen(false, true);
        setFocused(false);
        blurTimeoutRef.current = undefined;
    }, []);
    var onBlurHandler = React.useCallback(function (event) {
        clearTimeout(blurTimeoutRef.current);
        blurTimeoutRef.current = setTimeout(onBlurTimeout);
        if (onBlur) {
            onBlur.call(undefined, {
                nativeEvent: event.nativeEvent,
                syntheticEvent: event
            });
        }
    }, [onBlur]);
    var onChangeHandler = React.useCallback(function (event, isPalette) {
        var currentValue = isPalette ? event.rgbaValue : event.value;
        if (!isValueControlled) {
            setStateValue(currentValue);
        }
        if (isPalette) {
            setOpen(false);
        }
        if (onChange) {
            onChange.call(undefined, {
                value: currentValue,
                nativeEvent: event.nativeEvent,
                syntheticEvent: event.syntheticEvent
            });
        }
    }, [isValueControlled, onChange]);
    var onPaletteChangeHandler = React.useCallback(function (event) { return onChangeHandler(event, true); }, [isControlled, onChangeHandler]);
    var dir = useDir(focusableElementRef, props.dir);
    var iconClassName = props.iconClassName || (icon && "k-icon k-i-" + icon);
    var wrapperClassName = classNames({
        'k-widget': true,
        'k-colorpicker': true,
        'k-state-invalid': valid === false
    });
    var className = React.useMemo(function () { return classNames({
        'k-picker-wrap': true,
        'k-state-default': !disabled,
        'k-state-disabled': disabled,
        'k-state-focused': focused
    }); }, [focused, disabled]);
    return (React.createElement("span", { className: wrapperClassName, dir: dir },
        React.createElement("span", { id: props.id, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy, className: className, ref: focusableElementRef, tabIndex: getTabIndex(tabIndex, disabled), onKeyDown: onKeyDownHandler, onFocus: onFocusHandler, onBlur: onBlurHandler },
            React.createElement(Picker, { dir: dir, open: open, onOpen: onOpenHandler, popupAnchor: focusableElementRef.current || undefined, popupSettings: __assign({}, popupSettings), input: (!iconClassName ? (React.createElement("span", { className: 'k-selected-color', style: { backgroundColor: value } }, !value && React.createElement("span", { className: 'k-icon k-i-line' }))) : (React.createElement("span", { className: classNames('k-tool-icon', iconClassName) },
                    React.createElement("span", { className: 'k-selected-color', style: { backgroundColor: value } })))), button: (React.createElement("span", { onClick: onClickHandler, className: 'k-select', ref: buttonRef },
                    React.createElement("span", { className: 'k-icon k-i-arrow-s' }))), content: (React.createElement(React.Fragment, null,
                    (view === 'combo' || view === 'gradient') && (React.createElement(ColorGradient, __assign({}, gradientSettings, { tabIndex: 0, ref: gradientRef, value: value, onChange: onChangeHandler }))),
                    (view === 'combo' || view === 'palette') && (React.createElement(ColorPalette, __assign({}, paletteSettings, { ref: paletteRef, value: value, onChange: onPaletteChangeHandler }))))) }))));
});
ColorPicker.propTypes = {
    value: PropTypes.string,
    defaultValue: PropTypes.string,
    disabled: PropTypes.bool,
    view: PropTypes.oneOf(['gradient', 'palette', 'combo']),
    dir: PropTypes.string,
    id: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string
};
ColorPicker.defaultProps = {
    view: 'palette',
    gradientSettings: DEFAULT_GRADIENT_SETTINGS,
    paletteSettings: DEFAULT_PALETTE_SETTINGS
};
ColorPicker.displayName = 'KendoColorPicker';
//# sourceMappingURL=ColorPicker.js.map